<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../fmx.xsl"?>
<fmx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="vector.f90">
    <context>
        <time>2025-03-09T11:42:15</time>
        <version>1.0.0.1</version>
        <path>src</path>
        <path_to_root>../</path_to_root>
        <project>FTL</project>
        <name>vector.f90</name>
        <copyright>Copyright © 2020, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</copyright>
    </context>
    <units>
        <unit name="xxmodulebase___vector_ftl" type="module">
            <main>
                <lines>
                    <source percent="23.27">37</source>
                    <comments percent="42.77">68</comments>
                    <empty percent="33.96">54</empty>
                    <total>159</total>
                </lines>
                <complexity>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </complexity>
                <nesting>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </nesting>
                <methods>0</methods>
            </main>
            <methods>
                <method name="element_assign_allocatable" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="element_assign_pointer" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="quick_sort" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="46.55">27</source>
                            <comments percent="24.14">14</comments>
                            <empty percent="29.31">17</empty>
                            <total>58</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="recursive_binary_search" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.68">37</source>
                            <comments percent="22.22">18</comments>
                            <empty percent="32.10">26</empty>
                            <total>81</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>11</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.77">4</source>
                            <comments percent="30.77">4</comments>
                            <empty percent="38.46">5</empty>
                            <total>13</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_array" type="function">
                    <statistics>
                        <lines>
                            <source percent="41.38">12</source>
                            <comments percent="24.14">7</comments>
                            <empty percent="34.48">10</empty>
                            <total>29</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_assign_from_array" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="40.74">11</source>
                            <comments percent="25.93">7</comments>
                            <empty percent="33.33">9</empty>
                            <total>27</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_assign_from_fill" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="34.38">11</source>
                            <comments percent="34.38">11</comments>
                            <empty percent="31.25">10</empty>
                            <total>32</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_assign_from_range" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="34.62">18</source>
                            <comments percent="36.54">19</comments>
                            <empty percent="28.85">15</empty>
                            <total>52</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_assign_from_vector" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.36">12</source>
                            <comments percent="30.30">10</comments>
                            <empty percent="33.33">11</empty>
                            <total>33</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_at_get" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.45">10</source>
                            <comments percent="22.73">5</comments>
                            <empty percent="31.82">7</empty>
                            <total>22</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_back" type="function">
                    <statistics>
                        <lines>
                            <source percent="29.41">5</source>
                            <comments percent="35.29">6</comments>
                            <empty percent="35.29">6</empty>
                            <total>17</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_begin" type="function">
                    <statistics>
                        <lines>
                            <source percent="41.67">10</source>
                            <comments percent="29.17">7</comments>
                            <empty percent="29.17">7</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_binary_search" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">9</source>
                            <comments percent="29.63">8</comments>
                            <empty percent="37.04">10</empty>
                            <total>27</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_capacity" type="function">
                    <statistics>
                        <lines>
                            <source percent="32.14">9</source>
                            <comments percent="46.43">13</comments>
                            <empty percent="21.43">6</empty>
                            <total>28</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_clear" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.67">11</source>
                            <comments percent="30.00">9</comments>
                            <empty percent="33.33">10</empty>
                            <total>30</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_copy" type="function">
                    <statistics>
                        <lines>
                            <source percent="29.41">5</source>
                            <comments percent="35.29">6</comments>
                            <empty percent="35.29">6</empty>
                            <total>17</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_copy_from_array" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_default" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="33.33">4</comments>
                            <empty percent="33.33">4</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_element_from_index" type="function">
                    <statistics>
                        <lines>
                            <source percent="34.78">8</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="39.13">9</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_element_ptr_from_index" type="function">
                    <statistics>
                        <lines>
                            <source percent="34.78">8</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="39.13">9</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_element_to_index" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.00">9</source>
                            <comments percent="28.00">7</comments>
                            <empty percent="36.00">9</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_empty" type="function">
                    <statistics>
                        <lines>
                            <source percent="29.41">5</source>
                            <comments percent="35.29">6</comments>
                            <empty percent="35.29">6</empty>
                            <total>17</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_end" type="function">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_erase_range" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="25.00">6</source>
                            <comments percent="45.83">11</comments>
                            <empty percent="29.17">7</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_erase_range_at" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="42.31">22</source>
                            <comments percent="28.85">15</comments>
                            <empty percent="28.85">15</empty>
                            <total>52</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_erase_single" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="23.81">5</source>
                            <comments percent="47.62">10</comments>
                            <empty percent="28.57">6</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_erase_single_at" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="42.55">20</source>
                            <comments percent="27.66">13</comments>
                            <empty percent="29.79">14</empty>
                            <total>47</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_fill" type="function">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_front" type="function">
                    <statistics>
                        <lines>
                            <source percent="29.41">5</source>
                            <comments percent="35.29">6</comments>
                            <empty percent="35.29">6</empty>
                            <total>17</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_array" type="function">
                    <statistics>
                        <lines>
                            <source percent="25.81">8</source>
                            <comments percent="45.16">14</comments>
                            <empty percent="29.03">9</empty>
                            <total>31</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_array_at" type="function">
                    <statistics>
                        <lines>
                            <source percent="35.71">20</source>
                            <comments percent="32.14">18</comments>
                            <empty percent="32.14">18</empty>
                            <total>56</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_fill" type="function">
                    <statistics>
                        <lines>
                            <source percent="26.47">9</source>
                            <comments percent="44.12">15</comments>
                            <empty percent="29.41">10</empty>
                            <total>34</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_fill_at" type="function">
                    <statistics>
                        <lines>
                            <source percent="35.71">20</source>
                            <comments percent="32.14">18</comments>
                            <empty percent="32.14">18</empty>
                            <total>56</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_range" type="function">
                    <statistics>
                        <lines>
                            <source percent="26.47">9</source>
                            <comments percent="44.12">15</comments>
                            <empty percent="29.41">10</empty>
                            <total>34</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_range_at" type="function">
                    <statistics>
                        <lines>
                            <source percent="35.71">25</source>
                            <comments percent="34.29">24</comments>
                            <empty percent="30.00">21</empty>
                            <total>70</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_single" type="function">
                    <statistics>
                        <lines>
                            <source percent="25.81">8</source>
                            <comments percent="45.16">14</comments>
                            <empty percent="29.03">9</empty>
                            <total>31</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_insert_single_at" type="function">
                    <statistics>
                        <lines>
                            <source percent="34.00">17</source>
                            <comments percent="34.00">17</comments>
                            <empty percent="32.00">16</empty>
                            <total>50</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_assign" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="28.57">6</source>
                            <comments percent="38.10">8</comments>
                            <empty percent="33.33">7</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_associated" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_distance" type="function">
                    <statistics>
                        <lines>
                            <source percent="43.48">10</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="30.43">7</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_equal" type="function">
                    <statistics>
                        <lines>
                            <source percent="30.43">7</source>
                            <comments percent="34.78">8</comments>
                            <empty percent="34.78">8</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_get_element" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">7</source>
                            <comments percent="23.81">5</comments>
                            <empty percent="42.86">9</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_get_element_ptr" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">7</source>
                            <comments percent="23.81">5</comments>
                            <empty percent="42.86">9</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_index" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_next" type="function">
                    <statistics>
                        <lines>
                            <source percent="32.26">10</source>
                            <comments percent="16.13">5</comments>
                            <empty percent="51.61">16</empty>
                            <total>31</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_not_equal" type="function">
                    <statistics>
                        <lines>
                            <source percent="28.57">6</source>
                            <comments percent="38.10">8</comments>
                            <empty percent="33.33">7</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_nullify" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="25.00">3</comments>
                            <empty percent="41.67">5</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_previous" type="function">
                    <statistics>
                        <lines>
                            <source percent="43.48">10</source>
                            <comments percent="21.74">5</comments>
                            <empty percent="34.78">8</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_set_element" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">7</source>
                            <comments percent="23.81">5</comments>
                            <empty percent="42.86">9</empty>
                            <total>21</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_iterator_swap_iterators" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="31.25">5</source>
                            <comments percent="25.00">4</comments>
                            <empty percent="43.75">7</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_max_size" type="function">
                    <statistics>
                        <lines>
                            <source percent="23.53">4</source>
                            <comments percent="47.06">8</comments>
                            <empty percent="29.41">5</empty>
                            <total>17</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_merge" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.27">37</source>
                            <comments percent="40.20">41</comments>
                            <empty percent="23.53">24</empty>
                            <total>102</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>10</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>7</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_pop_back" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.43">7</source>
                            <comments percent="34.78">8</comments>
                            <empty percent="34.78">8</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_pop_front" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="35.48">11</source>
                            <comments percent="32.26">10</comments>
                            <empty percent="32.26">10</empty>
                            <total>31</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_push_back" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="29.17">7</source>
                            <comments percent="37.50">9</comments>
                            <empty percent="33.33">8</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_push_front" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="34.38">11</source>
                            <comments percent="34.38">11</comments>
                            <empty percent="31.25">10</empty>
                            <total>32</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_range" type="function">
                    <statistics>
                        <lines>
                            <source percent="25.00">6</source>
                            <comments percent="45.83">11</comments>
                            <empty percent="29.17">7</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_realloc" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="34.78">8</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="39.13">9</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_remove" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.36">16</source>
                            <comments percent="29.55">13</comments>
                            <empty percent="34.09">15</empty>
                            <total>44</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_remove_if" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="34.04">16</source>
                            <comments percent="34.04">16</comments>
                            <empty percent="31.91">15</empty>
                            <total>47</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_reserve" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="38.10">24</source>
                            <comments percent="33.33">21</comments>
                            <empty percent="28.57">18</empty>
                            <total>63</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_resize" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="43.64">24</source>
                            <comments percent="32.73">18</comments>
                            <empty percent="23.64">13</empty>
                            <total>55</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>8</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_reverse" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="37.50">12</source>
                            <comments percent="28.13">9</comments>
                            <empty percent="34.38">11</empty>
                            <total>32</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_select" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.00">18</source>
                            <comments percent="22.50">9</comments>
                            <empty percent="32.50">13</empty>
                            <total>40</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_size" type="function">
                    <statistics>
                        <lines>
                            <source percent="31.25">5</source>
                            <comments percent="31.25">5</comments>
                            <empty percent="37.50">6</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_sort" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="20.00">5</source>
                            <comments percent="56.00">14</comments>
                            <empty percent="24.00">6</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_splice_nodes" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="46.99">39</source>
                            <comments percent="24.10">20</comments>
                            <empty percent="28.92">24</empty>
                            <total>83</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>11</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_splice_range" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="25.71">9</source>
                            <comments percent="45.71">16</comments>
                            <empty percent="28.57">10</empty>
                            <total>35</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_splice_single" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="25.00">8</source>
                            <comments percent="46.88">15</comments>
                            <empty percent="28.13">9</empty>
                            <total>32</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_splice_vector" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="24.14">7</source>
                            <comments percent="48.28">14</comments>
                            <empty percent="27.59">8</empty>
                            <total>29</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_swap" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="55.36">31</source>
                            <comments percent="26.79">15</comments>
                            <empty percent="17.86">10</empty>
                            <total>56</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>8</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_swap_index" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="39.13">9</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="34.78">8</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="vector_unique" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="40.74">22</source>
                            <comments percent="33.33">18</comments>
                            <empty percent="25.93">14</empty>
                            <total>54</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
            </methods>
            <statistics>
                <lines>
                    <source percent="35.04">890</source>
                    <comments percent="33.31">846</comments>
                    <empty percent="31.65">804</empty>
                    <total>2540</total>
                </lines>
                <complexity>
                    <minimum>1</minimum>
                    <maximum>11</maximum>
                    <average>2.80</average>
                </complexity>
                <nesting>
                    <minimum>1</minimum>
                    <maximum>7</maximum>
                    <average>2.11</average>
                </nesting>
                <methods>74</methods>
            </statistics>
        </unit>
    </units>
    <statistics>
        <lines>
            <source percent="35.04">890</source>
            <comments percent="33.31">846</comments>
            <empty percent="31.65">804</empty>
            <total>2540</total>
        </lines>
        <complexity>
            <minimum>1</minimum>
            <maximum>11</maximum>
            <average>2.80</average>
        </complexity>
        <nesting>
            <minimum>1</minimum>
            <maximum>7</maximum>
            <average>2.11</average>
        </nesting>
        <methods>74</methods>
    </statistics>
    <code>
        <line t="M" i="1" b="0" n="0">module xxmodulebase___vector_ftl</line>
        <line t="M" i="2" b="0" n="0"></line>
        <line t="C" i="3" b="0" n="0">!-------------------------------------------------------------------------------</line>
        <line t="C" i="4" b="0" n="0">! Copyright : 2022, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</line>
        <line t="C" i="5" b="0" n="0">! Project   : Atlantis</line>
        <line t="C" i="6" b="0" n="0">! Author    : Fran Martinez Fadrique</line>
        <line t="C" i="7" b="0" n="0">! Language  : Object Oriented Fortran 2018</line>
        <line t="C" i="8" b="0" n="0">! Reference : http://www.cplusplus.com/reference/vector</line>
        <line t="C" i="9" b="0" n="0">!             http://www.cplusplus.com/reference/list</line>
        <line t="C" i="10" b="0" n="0">! Synopsis  : Vector (dynamic) container template</line>
        <line t="C" i="11" b="0" n="0">!             Limitations with respect to STL C++</line>
        <line t="C" i="12" b="0" n="0">!              - No reverse iteration.</line>
        <line t="C" i="13" b="0" n="0">!              - No constant iterators.</line>
        <line t="C" i="14" b="0" n="0">!              - Max size is dummy (dummy value not computed from architecture).</line>
        <line t="C" i="15" b="0" n="0">!              - No emplace functions.</line>
        <line t="C" i="16" b="0" n="0">!              - No operator [].</line>
        <line t="C" i="17" b="0" n="0">!              - Splice can append lists with an extension on the STL C++</line>
        <line t="C" i="18" b="0" n="0">!                interface that emulates the past-last-element with null iterator</line>
        <line t="C" i="19" b="0" n="0">!</line>
        <line t="C" i="20" b="0" n="0">! License   : This file is part of the Fortran Template Library (FTL).</line>
        <line t="C" i="21" b="0" n="0">!</line>
        <line t="C" i="22" b="0" n="0">!             FTL is free software: you can redistribute it and/or modify</line>
        <line t="C" i="23" b="0" n="0">!             it under the terms of the GNU Lesser General Public License as</line>
        <line t="C" i="24" b="0" n="0">!             published by the Free Software Foundation, either version 3 of</line>
        <line t="C" i="25" b="0" n="0">!             the License, or (at your option) any later version.</line>
        <line t="C" i="26" b="0" n="0">!</line>
        <line t="C" i="27" b="0" n="0">!             FTL is distributed in the hope that it will be useful,</line>
        <line t="C" i="28" b="0" n="0">!             but WITHOUT ANY WARRANTY; without even the implied warranty of</line>
        <line t="C" i="29" b="0" n="0">!             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</line>
        <line t="C" i="30" b="0" n="0">!             See the GNU Lesser General Public License for more details.</line>
        <line t="C" i="31" b="0" n="0">!</line>
        <line t="C" i="32" b="0" n="0">!             You should have received a copy of the GNU Lesser General Public</line>
        <line t="C" i="33" b="0" n="0">!             License along with FTL.  </line>
        <line t="C" i="34" b="0" n="0">!             If not, see &lt;http://www.gnu.org/licenses/&gt;.</line>
        <line t="C" i="35" b="0" n="0">!-------------------------------------------------------------------------------</line>
        <line t="C" i="36" b="0" n="0"></line>
        <line t="C" i="37" b="0" n="0">!---USE statements--------------------------------------------------------------</line>
        <line t="C" i="38" b="0" n="0"></line>
        <line t="X" i="39" b="0" n="0">  use m_object</line>
        <line t="X" i="40" b="0" n="0">  use xxuse__</line>
        <line t="X" i="41" b="0" n="0"></line>
        <line t="C" i="42" b="0" n="0">!---End of use statements-------------------------------------------------------</line>
        <line t="C" i="43" b="0" n="0"></line>
        <line t="X" i="44" b="0" n="0">  implicit none</line>
        <line t="X" i="45" b="0" n="0"></line>
        <line t="C" i="46" b="0" n="0">!---Public/Private declarations-------------------------------------------------</line>
        <line t="C" i="47" b="0" n="0"></line>
        <line t="X" i="48" b="0" n="0">  private</line>
        <line t="X" i="49" b="0" n="0"></line>
        <line t="X" i="50" b="0" n="0">  public xxtypebase___vector_ftl, xxconstructor___vector_ftl</line>
        <line t="X" i="51" b="0" n="0">  public xxtypebase___vector_ftl_iterator</line>
        <line t="X" i="52" b="0" n="0"></line>
        <line t="X" i="53" b="0" n="0">  public distance, swap</line>
        <line t="X" i="54" b="0" n="0"></line>
        <line t="C" i="55" b="0" n="0">!---End of public/private declarations------------------------------------------</line>
        <line t="C" i="56" b="0" n="0"></line>
        <line t="C" i="57" b="0" n="0">!---Declaration of module variables---------------------------------------------</line>
        <line t="C" i="58" b="0" n="0"></line>
        <line t="C" i="59" b="0" n="0">! Vector node type</line>
        <line t="T" i="60" b="0" n="0">  type t_node</line>
        <line t="X" i="61" b="0" n="0">    private</line>
        <line t="X" i="62" b="0" n="0"></line>
        <line t="C" i="63" b="0" n="0">!   The element data instance</line>
        <line t="X" i="64" b="0" n="0">    class(xxtypebase__), pointer :: element =&gt; null()</line>
        <line t="X" i="65" b="0" n="0"></line>
        <line t="T" i="66" b="0" n="0">  end type t_node</line>
        <line t="T" i="67" b="0" n="0"></line>
        <line t="T" i="68" b="0" n="0"></line>
        <line t="C" i="69" b="0" n="0">! Vector container type</line>
        <line t="T" i="70" b="0" n="0">  type, extends(t_object) :: xxtypebase___vector_ftl</line>
        <line t="X" i="71" b="0" n="0">    private</line>
        <line t="X" i="72" b="0" n="0"></line>
        <line t="C" i="73" b="0" n="0">!     The number of nodes in the vector</line>
        <line t="X" i="74" b="0" n="0">      integer :: count = 0</line>
        <line t="X" i="75" b="0" n="0"></line>
        <line t="C" i="76" b="0" n="0">!     The internal array</line>
        <line t="X" i="77" b="0" n="0">      type(t_node), dimension(:), allocatable :: data</line>
        <line t="X" i="78" b="0" n="0"></line>
        <line t="X" i="79" b="0" n="0">    contains</line>
        <line t="X" i="80" b="0" n="0"></line>
        <line t="C" i="81" b="0" n="0">!     Assign content</line>
        <line t="X" i="82" b="0" n="0">      generic :: assignment(=) =&gt; vector_assign_from_vector</line>
        <line t="X" i="83" b="0" n="0">      procedure :: vector_assign_from_vector</line>
        <line t="X" i="84" b="0" n="0"></line>
        <line t="C" i="85" b="0" n="0">!     Destructor</line>
        <line t="X" i="86" b="0" n="0">      final :: vector_</line>
        <line t="X" i="87" b="0" n="0"></line>
        <line t="C" i="88" b="0" n="0">!     Iterators</line>
        <line t="X" i="89" b="0" n="0">      procedure :: begin =&gt; vector_begin</line>
        <line t="X" i="90" b="0" n="0">      procedure :: end =&gt; vector_end</line>
        <line t="X" i="91" b="0" n="0"></line>
        <line t="C" i="92" b="0" n="0">!     Capacity</line>
        <line t="X" i="93" b="0" n="0">      procedure :: empty =&gt; vector_empty</line>
        <line t="X" i="94" b="0" n="0">      procedure :: size =&gt; vector_size</line>
        <line t="X" i="95" b="0" n="0">      procedure, nopass :: max_size =&gt; vector_max_size</line>
        <line t="X" i="96" b="0" n="0">      procedure :: capacity =&gt; vector_capacity</line>
        <line t="X" i="97" b="0" n="0">      </line>
        <line t="C" i="98" b="0" n="0">!     Element access</line>
        <line t="X" i="99" b="0" n="0">      procedure :: front =&gt; vector_front</line>
        <line t="X" i="100" b="0" n="0">      procedure :: back =&gt; vector_back</line>
        <line t="X" i="101" b="0" n="0"></line>
        <line t="C" i="102" b="0" n="0">!     Modifiers</line>
        <line t="X" i="103" b="0" n="0">      generic :: assign =&gt; vector_assign_from_vector, &amp;</line>
        <line t="X" i="104" b="0" n="0">                           vector_assign_from_range, &amp;</line>
        <line t="X" i="105" b="0" n="0">                           vector_assign_from_fill, &amp;</line>
        <line t="X" i="106" b="0" n="0">                           vector_assign_from_array</line>
        <line t="X" i="107" b="0" n="0">      procedure, private :: vector_assign_from_range</line>
        <line t="X" i="108" b="0" n="0">      procedure, private :: vector_assign_from_fill</line>
        <line t="X" i="109" b="0" n="0">      procedure, private :: vector_assign_from_array</line>
        <line t="X" i="110" b="0" n="0">      procedure :: push_front =&gt; vector_push_front</line>
        <line t="X" i="111" b="0" n="0">      procedure :: pop_front =&gt; vector_pop_front</line>
        <line t="X" i="112" b="0" n="0">      procedure :: push_back =&gt; vector_push_back</line>
        <line t="X" i="113" b="0" n="0">      procedure :: pop_back =&gt; vector_pop_back</line>
        <line t="X" i="114" b="0" n="0">      generic :: insert =&gt; vector_insert_single, &amp;</line>
        <line t="X" i="115" b="0" n="0">                           vector_insert_single_at, &amp;</line>
        <line t="X" i="116" b="0" n="0">                           vector_insert_fill, &amp;</line>
        <line t="X" i="117" b="0" n="0">                           vector_insert_fill_at, &amp;</line>
        <line t="X" i="118" b="0" n="0">                           vector_insert_range, &amp;</line>
        <line t="X" i="119" b="0" n="0">                           vector_insert_range_at, &amp;</line>
        <line t="X" i="120" b="0" n="0">                           vector_insert_array, &amp;</line>
        <line t="X" i="121" b="0" n="0">                           vector_insert_array_at</line>
        <line t="X" i="122" b="0" n="0">      procedure, private :: vector_insert_single</line>
        <line t="X" i="123" b="0" n="0">      procedure, private :: vector_insert_single_at</line>
        <line t="X" i="124" b="0" n="0">      procedure, private :: vector_insert_fill</line>
        <line t="X" i="125" b="0" n="0">      procedure, private :: vector_insert_fill_at</line>
        <line t="X" i="126" b="0" n="0">      procedure, private :: vector_insert_range</line>
        <line t="X" i="127" b="0" n="0">      procedure, private :: vector_insert_range_at</line>
        <line t="X" i="128" b="0" n="0">      procedure, private :: vector_insert_array</line>
        <line t="X" i="129" b="0" n="0">      procedure, private :: vector_insert_array_at</line>
        <line t="X" i="130" b="0" n="0">      generic :: erase =&gt; vector_erase_single, &amp;</line>
        <line t="X" i="131" b="0" n="0">                          vector_erase_single_at, &amp;</line>
        <line t="X" i="132" b="0" n="0">                          vector_erase_range, &amp;</line>
        <line t="X" i="133" b="0" n="0">                          vector_erase_range_at</line>
        <line t="X" i="134" b="0" n="0">      procedure, private :: vector_erase_single</line>
        <line t="X" i="135" b="0" n="0">      procedure, private :: vector_erase_single_at</line>
        <line t="X" i="136" b="0" n="0">      procedure, private :: vector_erase_range</line>
        <line t="X" i="137" b="0" n="0">      procedure, private :: vector_erase_range_at</line>
        <line t="X" i="138" b="0" n="0">      generic :: swap =&gt; vector_swap_index, &amp;</line>
        <line t="X" i="139" b="0" n="0">                         vector_swap</line>
        <line t="X" i="140" b="0" n="0">      procedure, private :: vector_swap_index</line>
        <line t="X" i="141" b="0" n="0">      procedure, private :: vector_swap</line>
        <line t="X" i="142" b="0" n="0">      procedure :: resize =&gt; vector_resize</line>
        <line t="X" i="143" b="0" n="0">      procedure :: clear =&gt; vector_clear</line>
        <line t="X" i="144" b="0" n="0"></line>
        <line t="C" i="145" b="0" n="0">!     Operations</line>
        <line t="X" i="146" b="0" n="0">      generic :: splice =&gt; vector_splice_vector, &amp;</line>
        <line t="X" i="147" b="0" n="0">                           vector_splice_range, &amp;</line>
        <line t="X" i="148" b="0" n="0">                           vector_splice_single</line>
        <line t="X" i="149" b="0" n="0">      procedure, private :: vector_splice_vector</line>
        <line t="X" i="150" b="0" n="0">      procedure, private :: vector_splice_range</line>
        <line t="X" i="151" b="0" n="0">      procedure, private :: vector_splice_single</line>
        <line t="X" i="152" b="0" n="0">      procedure, private :: vector_splice_nodes</line>
        <line t="X" i="153" b="0" n="0">      procedure :: remove =&gt; vector_remove</line>
        <line t="X" i="154" b="0" n="0">      procedure :: remove_if =&gt; vector_remove_if</line>
        <line t="X" i="155" b="0" n="0">      procedure :: unique =&gt; vector_unique</line>
        <line t="X" i="156" b="0" n="0">      procedure :: merge =&gt; vector_merge</line>
        <line t="X" i="157" b="0" n="0">      procedure :: sort =&gt; vector_sort</line>
        <line t="X" i="158" b="0" n="0">      procedure, private :: quick_sort</line>
        <line t="X" i="159" b="0" n="0">      procedure :: reverse =&gt; vector_reverse</line>
        <line t="X" i="160" b="0" n="0"></line>
        <line t="C" i="161" b="0" n="0">!     Selection</line>
        <line t="X" i="162" b="0" n="0">      procedure :: binary_search =&gt; vector_binary_search</line>
        <line t="X" i="163" b="0" n="0">      procedure :: select =&gt; vector_select</line>
        <line t="X" i="164" b="0" n="0">      procedure :: at =&gt; vector_at_get</line>
        <line t="X" i="165" b="0" n="0"></line>
        <line t="C" i="166" b="0" n="0">!     Element access</line>
        <line t="X" i="167" b="0" n="0">      procedure :: get_element =&gt; vector_element_from_index</line>
        <line t="X" i="168" b="0" n="0">      procedure :: get_element_ptr =&gt; vector_element_ptr_from_index</line>
        <line t="X" i="169" b="0" n="0">      procedure :: set_element =&gt; vector_element_to_index</line>
        <line t="X" i="170" b="0" n="0"></line>
        <line t="C" i="171" b="0" n="0">!     Conversion</line>
        <line t="X" i="172" b="0" n="0">      procedure :: array =&gt; vector_array</line>
        <line t="X" i="173" b="0" n="0"></line>
        <line t="C" i="174" b="0" n="0">!     Memory allocation management</line>
        <line t="X" i="175" b="0" n="0">      procedure :: reserve =&gt; vector_reserve</line>
        <line t="X" i="176" b="0" n="0">      procedure, private :: realloc =&gt; vector_realloc</line>
        <line t="X" i="177" b="0" n="0"></line>
        <line t="T" i="178" b="0" n="0">  end type xxtypebase___vector_ftl</line>
        <line t="T" i="179" b="0" n="0"></line>
        <line t="C" i="180" b="0" n="0">! Reference vector size parameters</line>
        <line t="X" i="181" b="0" n="0">  integer, parameter :: vector_base_capacity          = 100</line>
        <line t="X" i="182" b="0" n="0">  real,    parameter :: vector_base_capacity_increase = 1.5</line>
        <line t="X" i="183" b="0" n="0"></line>
        <line t="X" i="184" b="0" n="0"></line>
        <line t="C" i="185" b="0" n="0">  ! Constructor interface</line>
        <line t="X" i="186" b="0" n="0">  interface xxconstructor___vector_ftl</line>
        <line t="X" i="187" b="0" n="0">    module procedure vector_default</line>
        <line t="X" i="188" b="0" n="0">    module procedure vector_fill</line>
        <line t="X" i="189" b="0" n="0">    module procedure vector_range</line>
        <line t="X" i="190" b="0" n="0">    module procedure vector_copy</line>
        <line t="X" i="191" b="0" n="0">    module procedure vector_copy_from_array</line>
        <line t="X" i="192" b="0" n="0">  end interface xxconstructor___vector_ftl</line>
        <line t="X" i="193" b="0" n="0"></line>
        <line t="X" i="194" b="0" n="0"></line>
        <line t="C" i="195" b="0" n="0">! Interface to provide user comparison functions</line>
        <line t="X" i="196" b="0" n="0">  abstract interface</line>
        <line t="X" i="197" b="1" n="1">    pure function comparison( from_vector, reference ) result(res)</line>
        <line t="X" i="198" b="1" n="1">      use xxuse__</line>
        <line t="X" i="199" b="1" n="1">      class(xxtypebase__), intent(in) :: from_vector</line>
        <line t="X" i="200" b="1" n="1">      class(xxtypebase__), intent(in) :: reference</line>
        <line t="X" i="201" b="1" n="1">      logical :: res</line>
        <line t="X" i="202" b="1" n="1">    end function comparison</line>
        <line t="X" i="203" b="1" n="1">  end interface</line>
        <line t="X" i="204" b="1" n="1"></line>
        <line t="C" i="205" b="1" n="1">! Interface to provide predicate algorithm to the contained element</line>
        <line t="X" i="206" b="1" n="1">  abstract interface</line>
        <line t="X" i="207" b="1" n="1">    pure function predicate( a ) result(res)</line>
        <line t="X" i="208" b="1" n="1">      use xxuse__</line>
        <line t="X" i="209" b="1" n="1">      class(xxtypebase__), intent(in) :: a</line>
        <line t="X" i="210" b="1" n="1">      logical :: res</line>
        <line t="X" i="211" b="1" n="1">    end function predicate</line>
        <line t="X" i="212" b="1" n="1">  end interface</line>
        <line t="X" i="213" b="1" n="1"></line>
        <line t="C" i="214" b="1" n="1">! Interface to provide binary predicate algorithm to the contained elements</line>
        <line t="X" i="215" b="1" n="1">  abstract interface</line>
        <line t="X" i="216" b="1" n="1">    pure function binary_predicate( a, b ) result(res)</line>
        <line t="X" i="217" b="1" n="1">      use xxuse__</line>
        <line t="X" i="218" b="1" n="1">      class(xxtypebase__), intent(in) :: a</line>
        <line t="X" i="219" b="1" n="1">      class(xxtypebase__), intent(in) :: b</line>
        <line t="X" i="220" b="1" n="1">      logical :: res</line>
        <line t="X" i="221" b="1" n="1">    end function binary_predicate</line>
        <line t="X" i="222" b="1" n="1">  end interface</line>
        <line t="X" i="223" b="1" n="1"></line>
        <line t="X" i="224" b="1" n="1"></line>
        <line t="C" i="225" b="1" n="1">! Vector iterator type</line>
        <line t="T" i="226" b="1" n="1">  type, extends(t_object) :: xxtypebase___vector_ftl_iterator</line>
        <line t="X" i="227" b="1" n="1">    private</line>
        <line t="X" i="228" b="1" n="1"></line>
        <line t="C" i="229" b="1" n="1">!   The element index within the array (iterator not initialised if 0)</line>
        <line t="X" i="230" b="1" n="1">    integer :: idx = 0</line>
        <line t="X" i="231" b="1" n="1"></line>
        <line t="C" i="232" b="1" n="1">!   Pointer to the container vector</line>
        <line t="X" i="233" b="1" n="1">    type(xxtypebase___vector_ftl), pointer :: parent =&gt; null()</line>
        <line t="X" i="234" b="1" n="1"></line>
        <line t="X" i="235" b="1" n="1">    contains</line>
        <line t="X" i="236" b="1" n="1"></line>
        <line t="C" i="237" b="1" n="1">!     Access</line>
        <line t="X" i="238" b="1" n="1">      procedure :: get_element =&gt; vector_iterator_get_element</line>
        <line t="X" i="239" b="1" n="1">      procedure :: set_element =&gt; vector_iterator_set_element</line>
        <line t="X" i="240" b="1" n="1">      procedure :: get_element_ptr =&gt; vector_iterator_get_element_ptr</line>
        <line t="X" i="241" b="1" n="1"></line>
        <line t="C" i="242" b="1" n="1">!     Navigation</line>
        <line t="X" i="243" b="1" n="1">      procedure :: next =&gt; vector_iterator_next</line>
        <line t="X" i="244" b="1" n="1">      procedure :: previous =&gt; vector_iterator_previous</line>
        <line t="X" i="245" b="1" n="1">      procedure :: associated =&gt; vector_iterator_associated</line>
        <line t="X" i="246" b="1" n="1">      procedure :: nullify =&gt; vector_iterator_nullify</line>
        <line t="X" i="247" b="1" n="1">      procedure :: index =&gt; vector_iterator_index</line>
        <line t="X" i="248" b="1" n="1">      procedure :: distance =&gt; vector_iterator_distance</line>
        <line t="X" i="249" b="1" n="1">      procedure :: swap =&gt; vector_iterator_swap_iterators</line>
        <line t="X" i="250" b="1" n="1"></line>
        <line t="X" i="251" b="1" n="1"></line>
        <line t="C" i="252" b="1" n="1">!     Assignment</line>
        <line t="X" i="253" b="1" n="1">      generic :: assignment(=) =&gt; vector_iterator_assign</line>
        <line t="X" i="254" b="1" n="1">      procedure, private :: vector_iterator_assign</line>
        <line t="X" i="255" b="1" n="1"></line>
        <line t="C" i="256" b="1" n="1">!     Comparison operators</line>
        <line t="X" i="257" b="1" n="1">      generic :: operator(==) =&gt; vector_iterator_equal</line>
        <line t="X" i="258" b="1" n="1">      procedure, private :: vector_iterator_equal</line>
        <line t="X" i="259" b="1" n="1">      generic :: operator(/=) =&gt; vector_iterator_not_equal</line>
        <line t="X" i="260" b="1" n="1">      procedure, private :: vector_iterator_not_equal</line>
        <line t="X" i="261" b="1" n="1"></line>
        <line t="T" i="262" b="1" n="1">  end type xxtypebase___vector_ftl_iterator</line>
        <line t="T" i="263" b="1" n="1"></line>
        <line t="T" i="264" b="1" n="1"></line>
        <line t="C" i="265" b="1" n="1">! Interfaces for procedures not bound to type</line>
        <line t="X" i="266" b="1" n="1">  interface distance</line>
        <line t="X" i="267" b="1" n="1">    module procedure vector_iterator_distance</line>
        <line t="X" i="268" b="1" n="1">  end interface distance</line>
        <line t="X" i="269" b="1" n="1">  interface swap</line>
        <line t="X" i="270" b="1" n="1">    module procedure vector_iterator_swap_iterators</line>
        <line t="X" i="271" b="1" n="1">  end interface swap</line>
        <line t="X" i="272" b="1" n="1"></line>
        <line t="C" i="273" b="1" n="1">!---End of declaration of module variables--------------------------------------</line>
        <line t="C" i="274" b="1" n="1"></line>
        <line t="X" i="275" b="1" n="1">contains</line>
        <line t="X" i="276" b="1" n="1"></line>
        <line t="C" i="277" b="1" n="1">! (1) empty container constructor (default constructor)</line>
        <line t="C" i="278" b="1" n="1">!     Constructs an empty container, with no elements.</line>
        <line k="vector_default" t="F" i="279" b="1" n="1">function vector_default() result( res )</line>
        <line t="F" i="280" b="1" n="1"></line>
        <line t="C" i="281" b="1" n="1">! The result vector</line>
        <line t="X" i="282" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="283" b="1" n="1"></line>
        <line t="C" i="284" b="1" n="1">! Initialise counter</line>
        <line t="X" i="285" b="1" n="1">  res%count = 0</line>
        <line t="X" i="286" b="1" n="1"></line>
        <line t="EF" i="287" b="1" n="1">end function vector_default</line>
        <line t="EF" i="288" b="1" n="1"></line>
        <line t="EF" i="289" b="1" n="1"></line>
        <line t="C" i="290" b="1" n="1">! (2) fill constructor</line>
        <line t="C" i="291" b="1" n="1">!     Constructs a container with n elements.</line>
        <line t="C" i="292" b="1" n="1">!     Each element is a copy of val.</line>
        <line k="vector_fill" t="F" i="293" b="1" n="1">function vector_fill( n, val ) result( res )</line>
        <line t="F" i="294" b="1" n="1"></line>
        <line t="C" i="295" b="1" n="1">! The number of elements</line>
        <line t="X" i="296" b="1" n="1">  integer, intent(in) :: n</line>
        <line t="X" i="297" b="1" n="1"></line>
        <line t="C" i="298" b="1" n="1">! The element to use to fill the vector</line>
        <line t="X" i="299" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="300" b="1" n="1"></line>
        <line t="C" i="301" b="1" n="1">! The result vector</line>
        <line t="X" i="302" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="303" b="1" n="1"></line>
        <line t="C" i="304" b="1" n="1">! Assign input to output</line>
        <line t="X" i="305" b="1" n="1">  call res%assign( n, val )</line>
        <line t="X" i="306" b="1" n="1"></line>
        <line t="EF" i="307" b="1" n="1">end function vector_fill</line>
        <line t="EF" i="308" b="1" n="1"></line>
        <line t="EF" i="309" b="1" n="1"></line>
        <line t="C" i="310" b="1" n="1">! (3) range constructor</line>
        <line t="C" i="311" b="1" n="1">!     Constructs a container with as many elements as the range (first,last),</line>
        <line t="C" i="312" b="1" n="1">!     with each element constructed from its corresponding element in that range,</line>
        <line t="C" i="313" b="1" n="1">!     in the same order.</line>
        <line t="C" i="314" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="315" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="316" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_range" t="F" i="317" b="1" n="1">function vector_range( first, last ) result( res )</line>
        <line t="F" i="318" b="1" n="1"></line>
        <line t="C" i="319" b="1" n="1">! Iterator to first node to insert</line>
        <line t="X" i="320" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="321" b="1" n="1"></line>
        <line t="C" i="322" b="1" n="1">! Iterator to last node to insert</line>
        <line t="X" i="323" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="324" b="1" n="1"></line>
        <line t="C" i="325" b="1" n="1">! The result vector</line>
        <line t="X" i="326" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="327" b="1" n="1"></line>
        <line t="C" i="328" b="1" n="1">! Assign input to output</line>
        <line t="X" i="329" b="1" n="1">  call res%assign( first, last )</line>
        <line t="X" i="330" b="1" n="1"></line>
        <line t="EF" i="331" b="1" n="1">end function vector_range</line>
        <line t="EF" i="332" b="1" n="1"></line>
        <line t="EF" i="333" b="1" n="1"></line>
        <line t="C" i="334" b="1" n="1">! (4) copy constructor</line>
        <line t="C" i="335" b="1" n="1">!     Constructs a container with a copy of each of the elements in other,</line>
        <line t="C" i="336" b="1" n="1">!     in the same order.</line>
        <line k="vector_copy" t="F" i="337" b="1" n="1">function vector_copy( other ) result( res )</line>
        <line t="F" i="338" b="1" n="1"></line>
        <line t="C" i="339" b="1" n="1">! The input vector</line>
        <line t="X" i="340" b="1" n="1">  type(xxtypebase___vector_ftl), intent(in) :: other</line>
        <line t="X" i="341" b="1" n="1"></line>
        <line t="C" i="342" b="1" n="1">! The result vector</line>
        <line t="X" i="343" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="344" b="1" n="1"></line>
        <line t="C" i="345" b="1" n="1">! Assign input to output</line>
        <line t="X" i="346" b="1" n="1">  call res%assign( other )</line>
        <line t="X" i="347" b="1" n="1"></line>
        <line t="EF" i="348" b="1" n="1">end function vector_copy</line>
        <line t="EF" i="349" b="1" n="1"></line>
        <line t="EF" i="350" b="1" n="1"></line>
        <line t="C" i="351" b="1" n="1">! Copy constructor from array</line>
        <line k="vector_copy_from_array" t="F" i="352" b="1" n="1">function vector_copy_from_array( val ) result(res)</line>
        <line t="F" i="353" b="1" n="1"></line>
        <line t="C" i="354" b="1" n="1">! The input array</line>
        <line t="X" i="355" b="1" n="1">  class(xxtypebase__), dimension(:), intent(in) :: val</line>
        <line t="X" i="356" b="1" n="1"></line>
        <line t="C" i="357" b="1" n="1">! The result vector</line>
        <line t="X" i="358" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="359" b="1" n="1"></line>
        <line t="C" i="360" b="1" n="1">! Assign input to output</line>
        <line t="X" i="361" b="1" n="1">  call res%assign( val )</line>
        <line t="X" i="362" b="1" n="1"></line>
        <line t="EF" i="363" b="1" n="1">end function vector_copy_from_array</line>
        <line t="EF" i="364" b="1" n="1"></line>
        <line t="EF" i="365" b="1" n="1"></line>
        <line t="C" i="366" b="1" n="1">! Assign content</line>
        <line t="C" i="367" b="1" n="1">! Assigns new contents to the container, replacing its current contents, and</line>
        <line t="C" i="368" b="1" n="1">! modifying its size accordingly.</line>
        <line k="vector_assign_from_vector" t="S" i="369" b="1" n="1">subroutine vector_assign_from_vector( this, other )</line>
        <line t="S" i="370" b="1" n="1"></line>
        <line t="C" i="371" b="1" n="1">! The output vector</line>
        <line t="X" i="372" b="1" n="1">  class(xxtypebase___vector_ftl), intent(out) :: this</line>
        <line t="X" i="373" b="1" n="1"></line>
        <line t="C" i="374" b="1" n="1">! The input vector</line>
        <line t="X" i="375" b="1" n="1">  type(xxtypebase___vector_ftl), intent(in) :: other</line>
        <line t="X" i="376" b="1" n="1"></line>
        <line t="C" i="377" b="1" n="1">! Local variables</line>
        <line t="X" i="378" b="1" n="1">  integer :: i</line>
        <line t="X" i="379" b="1" n="1"></line>
        <line t="C" i="380" b="1" n="1">! Check if source is allocated</line>
        <line t="X" i="381" b="2" n="2">  if( other%count &gt; 0 ) then</line>
        <line t="X" i="382" b="2" n="2"></line>
        <line t="C" i="383" b="2" n="2">!   Allocate memory</line>
        <line t="X" i="384" b="2" n="2">    allocate(this%data( size(other%data) ))</line>
        <line t="X" i="385" b="2" n="2"></line>
        <line t="C" i="386" b="2" n="2">!   Copy the vector</line>
        <line t="X" i="387" b="3" n="3">    do i = 1, other%count</line>
        <line t="X" i="388" b="3" n="3">      allocate( this%data(i)%element, source=other%data(i)%element )</line>
        <line t="X" i="389" b="3" n="2">    end do</line>
        <line t="X" i="390" b="3" n="2"></line>
        <line t="C" i="391" b="3" n="2"> !   Set counter</line>
        <line t="X" i="392" b="3" n="2">     this%count = other%count</line>
        <line t="X" i="393" b="3" n="2"></line>
        <line t="X" i="394" b="3" n="1">  end if</line>
        <line t="X" i="395" b="3" n="1"></line>
        <line t="ES" i="396" b="3" n="1">end subroutine vector_assign_from_vector</line>
        <line t="ES" i="397" b="1" n="1"></line>
        <line t="ES" i="398" b="1" n="1"></line>
        <line t="C" i="399" b="1" n="1">! Vector destructor</line>
        <line t="C" i="400" b="1" n="1">! Destroys the container object.</line>
        <line k="vector_" t="S" i="401" b="1" n="1">subroutine vector_( this )</line>
        <line t="S" i="402" b="1" n="1"></line>
        <line t="C" i="403" b="1" n="1">! The vector</line>
        <line t="X" i="404" b="1" n="1">  type(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="405" b="1" n="1"></line>
        <line t="C" i="406" b="1" n="1">! Clear the vector</line>
        <line t="X" i="407" b="1" n="1">  call this%clear()</line>
        <line t="X" i="408" b="1" n="1"></line>
        <line t="ES" i="409" b="1" n="1">end subroutine vector_</line>
        <line t="ES" i="410" b="1" n="1"></line>
        <line t="ES" i="411" b="1" n="1"></line>
        <line t="C" i="412" b="1" n="1">! Return iterator to beginning</line>
        <line t="C" i="413" b="1" n="1">! Returns an iterator pointing to the first element in the vector container.</line>
        <line t="C" i="414" b="1" n="1">! If the container is empty, the returned iterator value shall not be dereferenced.</line>
        <line k="vector_begin" t="F" i="415" b="1" n="1">function vector_begin( this ) result(res)</line>
        <line t="F" i="416" b="1" n="1"></line>
        <line t="C" i="417" b="1" n="1">! The vector</line>
        <line t="X" i="418" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(in) :: this</line>
        <line t="X" i="419" b="1" n="1"></line>
        <line t="C" i="420" b="1" n="1">! Pointer to beginning of the vector</line>
        <line t="X" i="421" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="422" b="1" n="1"></line>
        <line t="C" i="423" b="1" n="1">! Return pointer to first node in the vector</line>
        <line t="X" i="424" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="425" b="2" n="2">    res%idx = 1</line>
        <line t="X" i="426" b="3" n="2">  else</line>
        <line t="X" i="427" b="3" n="2">    res%idx = 0</line>
        <line t="X" i="428" b="3" n="1">  end if</line>
        <line t="X" i="429" b="3" n="1"></line>
        <line t="C" i="430" b="3" n="1">! Assign the parent container</line>
        <line t="X" i="431" b="3" n="1">  res%parent =&gt; this</line>
        <line t="X" i="432" b="3" n="1"></line>
        <line t="EF" i="433" b="3" n="1">end function vector_begin</line>
        <line t="EF" i="434" b="1" n="1"></line>
        <line t="EF" i="435" b="1" n="1"></line>
        <line t="C" i="436" b="1" n="1">! Return iterator to end</line>
        <line t="C" i="437" b="1" n="1">! Returns an iterator referring to the last element in the vector container.</line>
        <line t="C" i="438" b="1" n="1">! If the container is empty, the returned iterator value shall not be dereferenced.</line>
        <line k="vector_end" t="F" i="439" b="1" n="1">function vector_end( this ) result(res)</line>
        <line t="F" i="440" b="1" n="1"></line>
        <line t="C" i="441" b="1" n="1">! The vector</line>
        <line t="X" i="442" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(in) :: this</line>
        <line t="X" i="443" b="1" n="1"></line>
        <line t="C" i="444" b="1" n="1">! Pointer to end of the vector</line>
        <line t="X" i="445" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="446" b="1" n="1"></line>
        <line t="C" i="447" b="1" n="1">! Return pointer to the last stored node in the vector</line>
        <line t="X" i="448" b="1" n="1">  res%idx = this%count</line>
        <line t="X" i="449" b="1" n="1"></line>
        <line t="C" i="450" b="1" n="1">!  Assign the parent container</line>
        <line t="X" i="451" b="1" n="1">   res%parent =&gt; this</line>
        <line t="X" i="452" b="1" n="1"></line>
        <line t="EF" i="453" b="1" n="1">end function vector_end</line>
        <line t="EF" i="454" b="1" n="1"></line>
        <line t="EF" i="455" b="1" n="1"></line>
        <line t="C" i="456" b="1" n="1">! Test whether container is empty</line>
        <line t="C" i="457" b="1" n="1">! Returns whether the vector container is empty (i.e. whether its size is 0).</line>
        <line t="C" i="458" b="1" n="1">! This function does not modify the container in any way.</line>
        <line k="vector_empty" t="F" i="459" b="1" n="1">pure function vector_empty( this ) result(res)</line>
        <line t="F" i="460" b="1" n="1"></line>
        <line t="C" i="461" b="1" n="1">! The vector</line>
        <line t="X" i="462" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="463" b="1" n="1"></line>
        <line t="C" i="464" b="1" n="1">! The vector empty status</line>
        <line t="X" i="465" b="1" n="1">  logical :: res</line>
        <line t="X" i="466" b="1" n="1"></line>
        <line t="C" i="467" b="1" n="1">! Assign the return value</line>
        <line t="X" i="468" b="1" n="1">  res = ( this%count == 0 )</line>
        <line t="X" i="469" b="1" n="1"></line>
        <line t="EF" i="470" b="1" n="1">end function vector_empty</line>
        <line t="EF" i="471" b="1" n="1"></line>
        <line t="EF" i="472" b="1" n="1"></line>
        <line t="C" i="473" b="1" n="1">! Return size</line>
        <line t="C" i="474" b="1" n="1">! Returns the number of elements in the vector container.</line>
        <line k="vector_size" t="F" i="475" b="1" n="1">pure function vector_size( this ) result(res)</line>
        <line t="F" i="476" b="1" n="1"></line>
        <line t="C" i="477" b="1" n="1">! The vector</line>
        <line t="X" i="478" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="479" b="1" n="1"></line>
        <line t="C" i="480" b="1" n="1">! The vector size</line>
        <line t="X" i="481" b="1" n="1">  integer :: res</line>
        <line t="X" i="482" b="1" n="1"></line>
        <line t="C" i="483" b="1" n="1">! Assign the return value</line>
        <line t="X" i="484" b="1" n="1">  res = this%count</line>
        <line t="X" i="485" b="1" n="1"></line>
        <line t="EF" i="486" b="1" n="1">end function vector_size</line>
        <line t="EF" i="487" b="1" n="1"></line>
        <line t="EF" i="488" b="1" n="1"></line>
        <line t="C" i="489" b="1" n="1">! Return maximum size</line>
        <line t="C" i="490" b="1" n="1">! Returns the maximum number of elements that the vector container can hold.</line>
        <line t="C" i="491" b="1" n="1">! This is the maximum potential size the container can reach due to known system</line>
        <line t="C" i="492" b="1" n="1">! or library implementation limitations, but the container is by no means</line>
        <line t="C" i="493" b="1" n="1">! guaranteed to be able to reach that size: it can still fail to allocate</line>
        <line t="C" i="494" b="1" n="1">! storage at any point before that size is reached.</line>
        <line k="vector_max_size" t="F" i="495" b="1" n="1">pure function vector_max_size() result(res)</line>
        <line t="F" i="496" b="1" n="1"></line>
        <line t="C" i="497" b="1" n="1">! The vector size</line>
        <line t="X" i="498" b="1" n="1">  integer :: res</line>
        <line t="X" i="499" b="1" n="1"></line>
        <line t="C" i="500" b="1" n="1">! Assign the return value (dummy from C++)</line>
        <line t="X" i="501" b="1" n="1">  res = 1073741823</line>
        <line t="X" i="502" b="1" n="1"></line>
        <line t="EF" i="503" b="1" n="1">end function vector_max_size</line>
        <line t="EF" i="504" b="1" n="1"></line>
        <line t="EF" i="505" b="1" n="1"></line>
        <line t="C" i="506" b="1" n="1">! Return size of allocated storage capacity</line>
        <line t="C" i="507" b="1" n="1">! Returns the size of the storage space currently allocated for the vector, </line>
        <line t="C" i="508" b="1" n="1">! expressed in terms of elements.</line>
        <line t="C" i="509" b="1" n="1">! This capacity is not necessarily equal to the vector size. </line>
        <line t="C" i="510" b="1" n="1">! It can be equal or greater, with the extra space allowing to accommodate </line>
        <line t="C" i="511" b="1" n="1">! for growth without the need to reallocate on each insertion.</line>
        <line t="C" i="512" b="1" n="1">! Notice that this capacity does not suppose a limit on the size of the vector. </line>
        <line t="C" i="513" b="1" n="1">! When this capacity is exhausted and more is needed, it is automatically expanded</line>
        <line t="C" i="514" b="1" n="1">! by the container (reallocating it storage space). </line>
        <line t="C" i="515" b="1" n="1">! The capacity of a vector can be explicitly altered by calling member vecto::reserve.</line>
        <line k="vector_capacity" t="F" i="516" b="1" n="1">pure function vector_capacity( this ) result(res)</line>
        <line t="F" i="517" b="1" n="1"></line>
        <line t="C" i="518" b="1" n="1">! The vector</line>
        <line t="X" i="519" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="520" b="1" n="1"></line>
        <line t="C" i="521" b="1" n="1">! The vector capacity</line>
        <line t="X" i="522" b="1" n="1">  integer :: res</line>
        <line t="X" i="523" b="1" n="1"></line>
        <line t="C" i="524" b="1" n="1">! Assign the return value (dummy from C++)</line>
        <line t="X" i="525" b="2" n="2">  if( allocated(this%data) ) then</line>
        <line t="X" i="526" b="2" n="2">    res = size(this%data)</line>
        <line t="X" i="527" b="3" n="2">  else</line>
        <line t="X" i="528" b="3" n="2">    res = 0</line>
        <line t="X" i="529" b="3" n="1">  end if</line>
        <line t="X" i="530" b="3" n="1"></line>
        <line t="EF" i="531" b="3" n="1">end function vector_capacity</line>
        <line t="EF" i="532" b="1" n="1"></line>
        <line t="EF" i="533" b="1" n="1"></line>
        <line t="C" i="534" b="1" n="1">! Access first element</line>
        <line t="C" i="535" b="1" n="1">! Returns a reference to the first element in the vector container.</line>
        <line t="C" i="536" b="1" n="1">! Calling this function on an empty container causes undefined behaviour.</line>
        <line k="vector_front" t="F" i="537" b="1" n="1">pure function vector_front( this ) result(res)</line>
        <line t="F" i="538" b="1" n="1"></line>
        <line t="C" i="539" b="1" n="1">! The vector</line>
        <line t="X" i="540" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="541" b="1" n="1"></line>
        <line t="C" i="542" b="1" n="1">! Pointer to the element in the first node in the vector</line>
        <line t="X" i="543" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="544" b="1" n="1"></line>
        <line t="C" i="545" b="1" n="1">! Assign the return value</line>
        <line t="X" i="546" b="1" n="1">  call element_assign_allocatable( res, this%data(1)%element )</line>
        <line t="X" i="547" b="1" n="1"></line>
        <line t="EF" i="548" b="1" n="1">end function vector_front</line>
        <line t="EF" i="549" b="1" n="1"></line>
        <line t="EF" i="550" b="1" n="1"></line>
        <line t="C" i="551" b="1" n="1">! Access last element</line>
        <line t="C" i="552" b="1" n="1">! Returns a reference to the last element in the vector container.</line>
        <line t="C" i="553" b="1" n="1">! Calling this function on an empty container causes undefined behaviour.</line>
        <line k="vector_back" t="F" i="554" b="1" n="1">pure function vector_back( this ) result(res)</line>
        <line t="F" i="555" b="1" n="1"></line>
        <line t="C" i="556" b="1" n="1">! The vector</line>
        <line t="X" i="557" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="558" b="1" n="1"></line>
        <line t="C" i="559" b="1" n="1">! Pointer to the element in the last node in the vector</line>
        <line t="X" i="560" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="561" b="1" n="1"></line>
        <line t="C" i="562" b="1" n="1">! Assign the return value</line>
        <line t="X" i="563" b="1" n="1">  call element_assign_allocatable( res, this%data(this%count)%element )</line>
        <line t="X" i="564" b="1" n="1"></line>
        <line t="EF" i="565" b="1" n="1">end function vector_back</line>
        <line t="EF" i="566" b="1" n="1"></line>
        <line t="EF" i="567" b="1" n="1"></line>
        <line t="C" i="568" b="1" n="1">! Assign new content to container</line>
        <line t="C" i="569" b="1" n="1">! Assigns new contents to the vector container, replacing its current contents,</line>
        <line t="C" i="570" b="1" n="1">! and modifying its size accordingly.</line>
        <line t="C" i="571" b="1" n="1">! (1), the new contents are elements constructed from each of the elements in the</line>
        <line t="C" i="572" b="1" n="1">!      range between first and last, in the same order.</line>
        <line t="C" i="573" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="574" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="575" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_assign_from_range" t="S" i="576" b="1" n="1">subroutine vector_assign_from_range( this, first, last )</line>
        <line t="S" i="577" b="1" n="1"></line>
        <line t="C" i="578" b="1" n="1">! The output vector</line>
        <line t="X" i="579" b="1" n="1">  class(xxtypebase___vector_ftl), intent(out) :: this</line>
        <line t="X" i="580" b="1" n="1"></line>
        <line t="C" i="581" b="1" n="1">! Iterator to first node to insert</line>
        <line t="X" i="582" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="583" b="1" n="1"></line>
        <line t="C" i="584" b="1" n="1">! Iterator to last node to insert</line>
        <line t="X" i="585" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="586" b="1" n="1"></line>
        <line t="C" i="587" b="1" n="1">! Local variables</line>
        <line t="X" i="588" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: it</line>
        <line t="X" i="589" b="1" n="1">  integer :: i, n</line>
        <line t="X" i="590" b="1" n="1"></line>
        <line t="C" i="591" b="1" n="1">! Allocate the vector storage</line>
        <line t="X" i="592" b="1" n="1">  n = distance( first, last ) + 1</line>
        <line t="X" i="593" b="1" n="1">  call this%reserve(n)</line>
        <line t="X" i="594" b="1" n="1"></line>
        <line t="C" i="595" b="1" n="1">! Initialise navigation pointer</line>
        <line t="X" i="596" b="1" n="1">  it = first</line>
        <line t="X" i="597" b="1" n="1">  i = 1</line>
        <line t="X" i="598" b="1" n="1"></line>
        <line t="C" i="599" b="1" n="1">! Loop on the vector</line>
        <line t="X" i="600" b="2" n="2">  do while( it%associated() )</line>
        <line t="X" i="601" b="2" n="2"></line>
        <line t="C" i="602" b="2" n="2">!   Add this element</line>
        <line t="X" i="603" b="2" n="2">    allocate( this%data(i)%element, source=it%parent%data(it%idx)%element )</line>
        <line t="X" i="604" b="2" n="2"></line>
        <line t="C" i="605" b="2" n="2">!   Check if this was the last element</line>
        <line t="X" i="606" b="3" n="3">    if( it == last ) exit</line>
        <line t="X" i="607" b="3" n="3"></line>
        <line t="C" i="608" b="3" n="3">!   Iterate</line>
        <line t="X" i="609" b="3" n="3">    it = it%next()</line>
        <line t="X" i="610" b="3" n="3">    i = i + 1</line>
        <line t="X" i="611" b="3" n="3"></line>
        <line t="X" i="612" b="3" n="2">  end do</line>
        <line t="X" i="613" b="3" n="2"></line>
        <line t="C" i="614" b="3" n="2">! Set the counter</line>
        <line t="X" i="615" b="3" n="2">  this%count = n</line>
        <line t="X" i="616" b="3" n="2"></line>
        <line t="ES" i="617" b="3" n="2">end subroutine vector_assign_from_range</line>
        <line t="ES" i="618" b="1" n="2"></line>
        <line t="ES" i="619" b="1" n="2"></line>
        <line t="C" i="620" b="1" n="2">! Assign new content to container</line>
        <line t="C" i="621" b="1" n="2">! Assigns new contents to the vector container, replacing its current contents,</line>
        <line t="C" i="622" b="1" n="2">! and modifying its size accordingly.</line>
        <line t="C" i="623" b="1" n="2">! (2), the new contents are n elements, each initialized to a copy of val.</line>
        <line k="vector_assign_from_fill" t="S" i="624" b="1" n="1">subroutine vector_assign_from_fill( this, n, val )</line>
        <line t="S" i="625" b="1" n="1"></line>
        <line t="C" i="626" b="1" n="1">! The output vector</line>
        <line t="X" i="627" b="1" n="1">  class(xxtypebase___vector_ftl), intent(out) :: this</line>
        <line t="X" i="628" b="1" n="1"></line>
        <line t="C" i="629" b="1" n="1">! The number of elements</line>
        <line t="X" i="630" b="1" n="1">  integer, intent(in) :: n</line>
        <line t="X" i="631" b="1" n="1"></line>
        <line t="C" i="632" b="1" n="1">! The element to used to populate the container</line>
        <line t="X" i="633" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="634" b="1" n="1"></line>
        <line t="C" i="635" b="1" n="1">! Local variables</line>
        <line t="X" i="636" b="1" n="1">  integer :: i</line>
        <line t="X" i="637" b="1" n="1"></line>
        <line t="C" i="638" b="1" n="1">! Allocate the vector storage</line>
        <line t="X" i="639" b="1" n="1">  call this%reserve(n)</line>
        <line t="X" i="640" b="1" n="1"></line>
        <line t="C" i="641" b="1" n="1">! Add the element to the vector, the prescribed number of times</line>
        <line t="X" i="642" b="2" n="2">  do i = 1, n</line>
        <line t="X" i="643" b="2" n="2">    call element_assign_pointer( this%data(i)%element, val )</line>
        <line t="X" i="644" b="2" n="1">  end do</line>
        <line t="X" i="645" b="2" n="1"></line>
        <line t="C" i="646" b="2" n="1">! Set the counter</line>
        <line t="X" i="647" b="2" n="1">  this%count = n</line>
        <line t="X" i="648" b="2" n="1"></line>
        <line t="ES" i="649" b="2" n="1">end subroutine vector_assign_from_fill</line>
        <line t="ES" i="650" b="1" n="1"></line>
        <line t="ES" i="651" b="1" n="1"></line>
        <line t="C" i="652" b="1" n="1">! Assign a vector from an array</line>
        <line k="vector_assign_from_array" t="S" i="653" b="1" n="1">subroutine vector_assign_from_array( this, val )</line>
        <line t="S" i="654" b="1" n="1"></line>
        <line t="C" i="655" b="1" n="1">! The output vector</line>
        <line t="X" i="656" b="1" n="1">  class(xxtypebase___vector_ftl), intent(out) :: this</line>
        <line t="X" i="657" b="1" n="1"></line>
        <line t="C" i="658" b="1" n="1">! The input array</line>
        <line t="X" i="659" b="1" n="1">  class(xxtypebase__), dimension(:), intent(in) :: val</line>
        <line t="X" i="660" b="1" n="1"></line>
        <line t="C" i="661" b="1" n="1">! Local variables</line>
        <line t="X" i="662" b="1" n="1">  integer :: i, n</line>
        <line t="X" i="663" b="1" n="1"></line>
        <line t="C" i="664" b="1" n="1">! Allocate the vector storage</line>
        <line t="X" i="665" b="1" n="1">  n = size(val)</line>
        <line t="X" i="666" b="1" n="1">  call this%reserve(n)</line>
        <line t="X" i="667" b="1" n="1"></line>
        <line t="C" i="668" b="1" n="1">! Copy the vector</line>
        <line t="X" i="669" b="2" n="2">  do i = 1, n</line>
        <line t="X" i="670" b="2" n="2">    call element_assign_pointer( this%data(i)%element, val(i) )</line>
        <line t="X" i="671" b="2" n="1">  end do</line>
        <line t="X" i="672" b="2" n="1"></line>
        <line t="C" i="673" b="2" n="1">! Set the counter</line>
        <line t="X" i="674" b="2" n="1">  this%count = n</line>
        <line t="X" i="675" b="2" n="1"></line>
        <line t="ES" i="676" b="2" n="1">end subroutine vector_assign_from_array</line>
        <line t="ES" i="677" b="1" n="1"></line>
        <line t="ES" i="678" b="1" n="1"></line>
        <line t="C" i="679" b="1" n="1">! Insert element at beginning</line>
        <line t="C" i="680" b="1" n="1">! Inserts a new element at the beginning of the vector, right before its current</line>
        <line t="C" i="681" b="1" n="1">! first element. The content of val is copied (or moved) to the inserted element.</line>
        <line t="C" i="682" b="1" n="1">! This effectively increases the container size by one.</line>
        <line k="vector_push_front" t="S" i="683" b="1" n="1">subroutine vector_push_front( this, val )</line>
        <line t="S" i="684" b="1" n="1"></line>
        <line t="C" i="685" b="1" n="1">! The vector</line>
        <line t="X" i="686" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="687" b="1" n="1"></line>
        <line t="C" i="688" b="1" n="1">! The element</line>
        <line t="X" i="689" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="690" b="1" n="1"></line>
        <line t="C" i="691" b="1" n="1">! Local variables</line>
        <line t="X" i="692" b="1" n="1">  integer :: i</line>
        <line t="X" i="693" b="1" n="1"></line>
        <line t="C" i="694" b="1" n="1">! Check for allocation status and initialize if required</line>
        <line t="X" i="695" b="1" n="1">  call this%realloc()</line>
        <line t="X" i="696" b="1" n="1"></line>
        <line t="C" i="697" b="1" n="1">! Move all elements one position forward</line>
        <line t="X" i="698" b="2" n="2">  do i = this%count, 1, -1</line>
        <line t="X" i="699" b="2" n="2">    this%data(i+1)%element =&gt; this%data(i)%element</line>
        <line t="X" i="700" b="2" n="1">  end do</line>
        <line t="X" i="701" b="2" n="1"></line>
        <line t="C" i="702" b="2" n="1">! Copy the element into the array</line>
        <line t="X" i="703" b="2" n="1">  call element_assign_pointer( this%data(1)%element, val )</line>
        <line t="X" i="704" b="2" n="1"></line>
        <line t="C" i="705" b="2" n="1">! Increase counter</line>
        <line t="X" i="706" b="2" n="1">  this%count = this%count + 1</line>
        <line t="X" i="707" b="2" n="1"></line>
        <line t="ES" i="708" b="2" n="1">end subroutine vector_push_front</line>
        <line t="ES" i="709" b="1" n="1"></line>
        <line t="ES" i="710" b="1" n="1"></line>
        <line t="C" i="711" b="1" n="1">! Delete first element</line>
        <line t="C" i="712" b="1" n="1">! Removes the first element in the vector container,</line>
        <line t="C" i="713" b="1" n="1">! effectively reducing its size by one.</line>
        <line t="C" i="714" b="1" n="1">! This destroys the removed element.</line>
        <line k="vector_pop_front" t="S" i="715" b="1" n="1">subroutine vector_pop_front( this )</line>
        <line t="S" i="716" b="1" n="1"></line>
        <line t="C" i="717" b="1" n="1">! The vector</line>
        <line t="X" i="718" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="719" b="1" n="1"></line>
        <line t="C" i="720" b="1" n="1">! Local counter</line>
        <line t="X" i="721" b="1" n="1">  integer :: i</line>
        <line t="X" i="722" b="1" n="1"></line>
        <line t="C" i="723" b="1" n="1">! Check if the vector is already empty</line>
        <line t="X" i="724" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="725" b="2" n="2"></line>
        <line t="C" i="726" b="2" n="2">!   Destroy data element in the first vector node</line>
        <line t="X" i="727" b="2" n="2">    deallocate( this%data(1)%element )</line>
        <line t="X" i="728" b="2" n="2"></line>
        <line t="C" i="729" b="2" n="2">!   Shift all elements one position backwards</line>
        <line t="X" i="730" b="3" n="3">    do i = 1, this%count - 1</line>
        <line t="X" i="731" b="3" n="3">      this%data(i)%element =&gt; this%data(i+1)%element</line>
        <line t="X" i="732" b="3" n="2">    end do</line>
        <line t="X" i="733" b="3" n="2"></line>
        <line t="C" i="734" b="3" n="2">!   Decrease counter</line>
        <line t="X" i="735" b="3" n="2">    this%count = this%count - 1</line>
        <line t="X" i="736" b="3" n="2"></line>
        <line t="X" i="737" b="3" n="1">  end if</line>
        <line t="X" i="738" b="3" n="1"></line>
        <line t="ES" i="739" b="3" n="1">end subroutine vector_pop_front</line>
        <line t="ES" i="740" b="1" n="1"></line>
        <line t="ES" i="741" b="1" n="1"></line>
        <line t="C" i="742" b="1" n="1">! Add element at the end</line>
        <line t="C" i="743" b="1" n="1">! Adds a new element at the end of the vector container, after its current</line>
        <line t="C" i="744" b="1" n="1">! last element. The content of val is copied (or moved) to the new element.</line>
        <line t="C" i="745" b="1" n="1">! This effectively increases the container size by one.</line>
        <line k="vector_push_back" t="S" i="746" b="1" n="1">subroutine vector_push_back( this, val )</line>
        <line t="S" i="747" b="1" n="1"></line>
        <line t="C" i="748" b="1" n="1">! The vector</line>
        <line t="X" i="749" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="750" b="1" n="1"></line>
        <line t="C" i="751" b="1" n="1">! The element</line>
        <line t="X" i="752" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="753" b="1" n="1"></line>
        <line t="C" i="754" b="1" n="1">! Check for allocation status and initialize if required</line>
        <line t="X" i="755" b="1" n="1">  call this%realloc()</line>
        <line t="X" i="756" b="1" n="1"></line>
        <line t="C" i="757" b="1" n="1">! Increase counter</line>
        <line t="X" i="758" b="1" n="1">  this%count = this%count + 1</line>
        <line t="X" i="759" b="1" n="1"></line>
        <line t="C" i="760" b="1" n="1">! Copy the element into the array</line>
        <line t="X" i="761" b="1" n="1">  call element_assign_pointer( this%data(this%count)%element, val )</line>
        <line t="X" i="762" b="1" n="1"></line>
        <line t="ES" i="763" b="1" n="1">end subroutine vector_push_back</line>
        <line t="ES" i="764" b="1" n="1"></line>
        <line t="ES" i="765" b="1" n="1"></line>
        <line t="C" i="766" b="1" n="1">! Delete last element</line>
        <line t="C" i="767" b="1" n="1">! Removes the last element in the vector container,</line>
        <line t="C" i="768" b="1" n="1">! effectively reducing the container size by one.</line>
        <line t="C" i="769" b="1" n="1">! This destroys the removed element.</line>
        <line k="vector_pop_back" t="S" i="770" b="1" n="1">subroutine vector_pop_back( this )</line>
        <line t="S" i="771" b="1" n="1"></line>
        <line t="C" i="772" b="1" n="1">! The vector</line>
        <line t="X" i="773" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="774" b="1" n="1"></line>
        <line t="C" i="775" b="1" n="1">! Check if the vector is already empty</line>
        <line t="X" i="776" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="777" b="2" n="2"></line>
        <line t="C" i="778" b="2" n="2">!   Destroy data element in the last vector node</line>
        <line t="X" i="779" b="2" n="2">    deallocate( this%data(this%count)%element )</line>
        <line t="X" i="780" b="2" n="2"></line>
        <line t="C" i="781" b="2" n="2">!   Decrease counter</line>
        <line t="X" i="782" b="2" n="2">    this%count = this%count - 1</line>
        <line t="X" i="783" b="2" n="2"></line>
        <line t="X" i="784" b="2" n="1">  end if</line>
        <line t="X" i="785" b="2" n="1"></line>
        <line t="ES" i="786" b="2" n="1">end subroutine vector_pop_back</line>
        <line t="ES" i="787" b="1" n="1"></line>
        <line t="ES" i="788" b="1" n="1"></line>
        <line t="C" i="789" b="1" n="1">! Insert elements</line>
        <line t="C" i="790" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="791" b="1" n="1">! the specified position.</line>
        <line t="C" i="792" b="1" n="1">! This effectively increases the vector size by one.</line>
        <line t="C" i="793" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line t="C" i="794" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="795" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="796" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_insert_single" t="F" i="797" b="1" n="1">function vector_insert_single( this, iterator, val ) result(res)</line>
        <line t="F" i="798" b="1" n="1"></line>
        <line t="C" i="799" b="1" n="1">! The vector</line>
        <line t="X" i="800" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(inout) :: this</line>
        <line t="X" i="801" b="1" n="1"></line>
        <line t="C" i="802" b="1" n="1">! Iterator to node used as reference for insertion</line>
        <line t="X" i="803" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="804" b="1" n="1"></line>
        <line t="C" i="805" b="1" n="1">! The element</line>
        <line t="X" i="806" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="807" b="1" n="1"></line>
        <line t="C" i="808" b="1" n="1">! Iterator to the inserted element</line>
        <line t="X" i="809" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="810" b="1" n="1"></line>
        <line t="C" i="811" b="1" n="1">! Insert by index</line>
        <line t="X" i="812" b="1" n="1">  res%idx = this%insert( iterator%idx, val )</line>
        <line t="X" i="813" b="1" n="1"></line>
        <line t="C" i="814" b="1" n="1">! Set pointer to parent</line>
        <line t="X" i="815" b="1" n="1">  res%parent =&gt; this</line>
        <line t="X" i="816" b="1" n="1"></line>
        <line t="EF" i="817" b="1" n="1">end function vector_insert_single</line>
        <line t="EF" i="818" b="1" n="1"></line>
        <line t="EF" i="819" b="1" n="1"></line>
        <line t="C" i="820" b="1" n="1">! Insert elements</line>
        <line t="C" i="821" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="822" b="1" n="1">! the specified position (by absolute index)</line>
        <line t="C" i="823" b="1" n="1">! This effectively increases the vector size by one.</line>
        <line t="C" i="824" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line k="vector_insert_single_at" t="F" i="825" b="1" n="1">function vector_insert_single_at( this, index, val ) result(res)</line>
        <line t="F" i="826" b="1" n="1"></line>
        <line t="C" i="827" b="1" n="1">! The vector</line>
        <line t="X" i="828" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="829" b="1" n="1"></line>
        <line t="C" i="830" b="1" n="1">! Index to element used as reference for insertion</line>
        <line t="X" i="831" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="832" b="1" n="1"></line>
        <line t="C" i="833" b="1" n="1">! The element</line>
        <line t="X" i="834" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="835" b="1" n="1"></line>
        <line t="C" i="836" b="1" n="1">! The index in this of the inserted element</line>
        <line t="X" i="837" b="1" n="1">  integer :: res</line>
        <line t="X" i="838" b="1" n="1"></line>
        <line t="C" i="839" b="1" n="1">! Counter</line>
        <line t="X" i="840" b="1" n="1">  integer :: i</line>
        <line t="X" i="841" b="1" n="1"></line>
        <line t="C" i="842" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="843" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="844" b="2" n="2"></line>
        <line t="C" i="845" b="2" n="2">!   Check for allocation status and initialize if required</line>
        <line t="X" i="846" b="2" n="2">    call this%realloc()</line>
        <line t="X" i="847" b="2" n="2"></line>
        <line t="C" i="848" b="2" n="2">!   Make room for the inserted element. Move pointers, not memory</line>
        <line t="X" i="849" b="3" n="3">    do i = this%count, index, -1</line>
        <line t="X" i="850" b="3" n="3">      this%data(i+1)%element =&gt; this%data(i)%element</line>
        <line t="X" i="851" b="3" n="2">    end do</line>
        <line t="X" i="852" b="3" n="2"></line>
        <line t="C" i="853" b="3" n="2">!   Allocate memory for the new element</line>
        <line t="X" i="854" b="3" n="2">    allocate( this%data(index)%element, mold=val )</line>
        <line t="X" i="855" b="3" n="2"></line>
        <line t="C" i="856" b="3" n="2">!   Copy element</line>
        <line t="X" i="857" b="3" n="2">    call element_assign_pointer( this%data(index)%element, val )</line>
        <line t="X" i="858" b="3" n="2"></line>
        <line t="C" i="859" b="3" n="2">!   Increase vector size</line>
        <line t="X" i="860" b="3" n="2">    this%count = this%count + 1</line>
        <line t="X" i="861" b="3" n="2"></line>
        <line t="C" i="862" b="3" n="2">!   Set the return index</line>
        <line t="X" i="863" b="3" n="2">    res = index</line>
        <line t="X" i="864" b="3" n="2"></line>
        <line t="X" i="865" b="3" n="1">  end if</line>
        <line t="X" i="866" b="3" n="1"></line>
        <line t="EF" i="867" b="3" n="1">end function vector_insert_single_at</line>
        <line t="EF" i="868" b="1" n="1"></line>
        <line t="EF" i="869" b="1" n="1"></line>
        <line t="C" i="870" b="1" n="1">! Insert elements</line>
        <line t="C" i="871" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="872" b="1" n="1">! the specified position.</line>
        <line t="C" i="873" b="1" n="1">! This effectively increases the vector size by n.</line>
        <line t="C" i="874" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line t="C" i="875" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="876" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="877" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_insert_fill" t="F" i="878" b="1" n="1">function vector_insert_fill( this, iterator, n, val ) result(res)</line>
        <line t="F" i="879" b="1" n="1"></line>
        <line t="C" i="880" b="1" n="1">! The vector</line>
        <line t="X" i="881" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(inout) :: this</line>
        <line t="X" i="882" b="1" n="1"></line>
        <line t="C" i="883" b="1" n="1">! Iterator to node used as reference for insertion</line>
        <line t="X" i="884" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="885" b="1" n="1"></line>
        <line t="C" i="886" b="1" n="1">! The number of times to insert the element</line>
        <line t="X" i="887" b="1" n="1">  integer, intent(in) :: n</line>
        <line t="X" i="888" b="1" n="1"></line>
        <line t="C" i="889" b="1" n="1">! Iterator to the inserted element</line>
        <line t="X" i="890" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="891" b="1" n="1"></line>
        <line t="C" i="892" b="1" n="1">! The element</line>
        <line t="X" i="893" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="894" b="1" n="1"></line>
        <line t="C" i="895" b="1" n="1">! Insert by index</line>
        <line t="X" i="896" b="1" n="1">  res%idx = this%insert( iterator%idx, n, val )</line>
        <line t="X" i="897" b="1" n="1"></line>
        <line t="C" i="898" b="1" n="1">! Set pointer to parent</line>
        <line t="X" i="899" b="1" n="1">  res%parent =&gt; this</line>
        <line t="X" i="900" b="1" n="1"></line>
        <line t="EF" i="901" b="1" n="1">end function vector_insert_fill</line>
        <line t="EF" i="902" b="1" n="1"></line>
        <line t="EF" i="903" b="1" n="1"></line>
        <line t="C" i="904" b="1" n="1">! Insert elements</line>
        <line t="C" i="905" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="906" b="1" n="1">! the specified position (by absolute index)</line>
        <line t="C" i="907" b="1" n="1">! This effectively increases the vector size by n.</line>
        <line t="C" i="908" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line k="vector_insert_fill_at" t="F" i="909" b="1" n="1">function vector_insert_fill_at( this, index, n, val ) result(res)</line>
        <line t="F" i="910" b="1" n="1"></line>
        <line t="C" i="911" b="1" n="1">! The vector</line>
        <line t="X" i="912" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="913" b="1" n="1"></line>
        <line t="C" i="914" b="1" n="1">! Index to element used as reference for insertion</line>
        <line t="X" i="915" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="916" b="1" n="1"></line>
        <line t="C" i="917" b="1" n="1">! The number of times to insert the element</line>
        <line t="X" i="918" b="1" n="1">  integer, intent(in) :: n</line>
        <line t="X" i="919" b="1" n="1"></line>
        <line t="C" i="920" b="1" n="1">! The element</line>
        <line t="X" i="921" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="922" b="1" n="1"></line>
        <line t="C" i="923" b="1" n="1">! Index in this to the start of the inserted section</line>
        <line t="X" i="924" b="1" n="1">  integer :: res</line>
        <line t="X" i="925" b="1" n="1"></line>
        <line t="C" i="926" b="1" n="1">! Counter</line>
        <line t="X" i="927" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="928" b="1" n="1"></line>
        <line t="C" i="929" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="930" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="931" b="2" n="2"></line>
        <line t="C" i="932" b="2" n="2">!   Check for allocation status</line>
        <line t="X" i="933" b="2" n="2">    call this%reserve( this%count + n )</line>
        <line t="X" i="934" b="2" n="2"></line>
        <line t="C" i="935" b="2" n="2">!   Make room for the inserted elements. Move pointers, not memory</line>
        <line t="X" i="936" b="3" n="3">    do i = this%count, index, -1</line>
        <line t="X" i="937" b="3" n="3">      this%data(i+n)%element =&gt; this%data(i)%element</line>
        <line t="X" i="938" b="3" n="2">    end do</line>
        <line t="X" i="939" b="3" n="2"></line>
        <line t="C" i="940" b="3" n="2">!   Loop on the number of elements to insert</line>
        <line t="X" i="941" b="4" n="3">    do i = 1, n</line>
        <line t="X" i="942" b="4" n="3"></line>
        <line t="C" i="943" b="4" n="3">!     Allocate memory for the new element and copy</line>
        <line t="X" i="944" b="4" n="3">      j = index + i - 1</line>
        <line t="X" i="945" b="4" n="3">      call element_assign_pointer( this%data(j)%element, val )</line>
        <line t="X" i="946" b="4" n="3"></line>
        <line t="X" i="947" b="4" n="2">    end do</line>
        <line t="X" i="948" b="4" n="2"></line>
        <line t="C" i="949" b="4" n="2">!   Increase vector size</line>
        <line t="X" i="950" b="4" n="2">    this%count = this%count + n</line>
        <line t="X" i="951" b="4" n="2"></line>
        <line t="C" i="952" b="4" n="2">!   Set the return index</line>
        <line t="X" i="953" b="4" n="2">    res = index</line>
        <line t="X" i="954" b="4" n="2"></line>
        <line t="X" i="955" b="4" n="1">  end if</line>
        <line t="X" i="956" b="4" n="1"></line>
        <line t="EF" i="957" b="4" n="1">end function vector_insert_fill_at</line>
        <line t="EF" i="958" b="1" n="1"></line>
        <line t="EF" i="959" b="1" n="1"></line>
        <line t="C" i="960" b="1" n="1">! Insert elements</line>
        <line t="C" i="961" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="962" b="1" n="1">! the specified position.</line>
        <line t="C" i="963" b="1" n="1">! This effectively increases the vector size by the number of element in (first,last].</line>
        <line t="C" i="964" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line t="C" i="965" b="1" n="1">! This assumes that the range (first,last) is an actual connected range,</line>
        <line t="C" i="966" b="1" n="1">! i.e. it is possible to navigate from first to last, otherwise the resulting</line>
        <line t="C" i="967" b="1" n="1">! vector is corrupted.</line>
        <line k="vector_insert_range" t="F" i="968" b="1" n="1">function vector_insert_range( this, iterator, first, last ) result(res)</line>
        <line t="F" i="969" b="1" n="1"></line>
        <line t="C" i="970" b="1" n="1">! The vector</line>
        <line t="X" i="971" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(inout) :: this</line>
        <line t="X" i="972" b="1" n="1"></line>
        <line t="C" i="973" b="1" n="1">! Iterator to node used as reference for insertion</line>
        <line t="X" i="974" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="975" b="1" n="1"></line>
        <line t="C" i="976" b="1" n="1">! Iterator to first node to insert</line>
        <line t="X" i="977" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="978" b="1" n="1"></line>
        <line t="C" i="979" b="1" n="1">! Iterator to last node to insert</line>
        <line t="X" i="980" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="981" b="1" n="1"></line>
        <line t="C" i="982" b="1" n="1">! Iterator to the inserted section</line>
        <line t="X" i="983" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="984" b="1" n="1"></line>
        <line t="C" i="985" b="1" n="1">! Insert by index</line>
        <line t="X" i="986" b="1" n="1">  res%idx = this%insert( iterator%idx, first, last )</line>
        <line t="X" i="987" b="1" n="1"></line>
        <line t="C" i="988" b="1" n="1">! Set pointer to parent</line>
        <line t="X" i="989" b="1" n="1">  res%parent =&gt; this</line>
        <line t="X" i="990" b="1" n="1"></line>
        <line t="EF" i="991" b="1" n="1">end function vector_insert_range</line>
        <line t="EF" i="992" b="1" n="1"></line>
        <line t="EF" i="993" b="1" n="1"></line>
        <line t="C" i="994" b="1" n="1">! Insert elements</line>
        <line t="C" i="995" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="996" b="1" n="1">! the specified position (by absolute index)</line>
        <line t="C" i="997" b="1" n="1">! This effectively increases the vector size by the number of element in (first,last].</line>
        <line t="C" i="998" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line t="C" i="999" b="1" n="1">! This assumes that the range (first,last) is an actual connected range,</line>
        <line t="C" i="1000" b="1" n="1">! i.e. it is possible to navigate from first to last, otherwise the resulting</line>
        <line t="C" i="1001" b="1" n="1">! vector is corrupted.</line>
        <line k="vector_insert_range_at" t="F" i="1002" b="1" n="1">function vector_insert_range_at( this, index, first, last ) result(res)</line>
        <line t="F" i="1003" b="1" n="1"></line>
        <line t="C" i="1004" b="1" n="1">! The vector</line>
        <line t="X" i="1005" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1006" b="1" n="1"></line>
        <line t="C" i="1007" b="1" n="1">! Index to element used as reference for insertion</line>
        <line t="X" i="1008" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1009" b="1" n="1"></line>
        <line t="C" i="1010" b="1" n="1">! Iterator to first node to insert</line>
        <line t="X" i="1011" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="1012" b="1" n="1"></line>
        <line t="C" i="1013" b="1" n="1">! Iterator to last node to insert</line>
        <line t="X" i="1014" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="1015" b="1" n="1"></line>
        <line t="C" i="1016" b="1" n="1">! Index in this to the start of the inserted section</line>
        <line t="X" i="1017" b="1" n="1">  integer :: res</line>
        <line t="X" i="1018" b="1" n="1"></line>
        <line t="C" i="1019" b="1" n="1">! Local nodes</line>
        <line t="X" i="1020" b="1" n="1">  integer :: inode, ifirst, ilast</line>
        <line t="X" i="1021" b="1" n="1">  integer :: i, n</line>
        <line t="X" i="1022" b="1" n="1"></line>
        <line t="C" i="1023" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="1024" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1025" b="2" n="2"></line>
        <line t="C" i="1026" b="2" n="2">!   Check the number of nodes to insert</line>
        <line t="X" i="1027" b="2" n="2">    n = distance( first, last ) + 1</line>
        <line t="X" i="1028" b="2" n="2"></line>
        <line t="C" i="1029" b="2" n="2">!   Check for allocation status and initialize if required</line>
        <line t="X" i="1030" b="2" n="2">    call this%reserve( this%count + n )</line>
        <line t="X" i="1031" b="2" n="2"></line>
        <line t="C" i="1032" b="2" n="2">!   Make room for the inserted elements. Move pointers, not memory</line>
        <line t="X" i="1033" b="3" n="3">    do i = this%count, index, -1</line>
        <line t="X" i="1034" b="3" n="3">      this%data(i+n)%element =&gt; this%data(i)%element</line>
        <line t="X" i="1035" b="3" n="2">    end do</line>
        <line t="X" i="1036" b="3" n="2"></line>
        <line t="C" i="1037" b="3" n="2">!   Initialise input node navigation</line>
        <line t="X" i="1038" b="3" n="2">    ifirst = first%idx</line>
        <line t="X" i="1039" b="3" n="2">    ilast = last%idx</line>
        <line t="X" i="1040" b="3" n="2">    i = 1</line>
        <line t="X" i="1041" b="3" n="2"></line>
        <line t="C" i="1042" b="3" n="2">!   Navigate the input nodes</line>
        <line t="X" i="1043" b="4" n="3">    do inode = ifirst, ilast</line>
        <line t="X" i="1044" b="4" n="3"></line>
        <line t="C" i="1045" b="4" n="3">!     Allocate memory for the new element and copy</line>
        <line t="X" i="1046" b="4" n="3">      call element_assign_pointer( this%data(index+i-1)%element, first%parent%data(inode)%element )</line>
        <line t="X" i="1047" b="4" n="3"></line>
        <line t="C" i="1048" b="4" n="3">!     Iterate</line>
        <line t="X" i="1049" b="4" n="3">      i = i + 1</line>
        <line t="X" i="1050" b="4" n="3"></line>
        <line t="X" i="1051" b="4" n="2">    end do</line>
        <line t="X" i="1052" b="4" n="2"></line>
        <line t="C" i="1053" b="4" n="2">!   Increase vector size</line>
        <line t="X" i="1054" b="4" n="2">    this%count = this%count + n</line>
        <line t="X" i="1055" b="4" n="2"></line>
        <line t="C" i="1056" b="4" n="2">!   Set the return index</line>
        <line t="X" i="1057" b="4" n="2">    res = index</line>
        <line t="X" i="1058" b="4" n="2"></line>
        <line t="X" i="1059" b="4" n="1">  end if</line>
        <line t="X" i="1060" b="4" n="1"></line>
        <line t="EF" i="1061" b="4" n="1">end function vector_insert_range_at</line>
        <line t="EF" i="1062" b="1" n="1"></line>
        <line t="EF" i="1063" b="1" n="1"></line>
        <line t="C" i="1064" b="1" n="1">! Insert elements</line>
        <line t="C" i="1065" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="1066" b="1" n="1">! the specified position.</line>
        <line t="C" i="1067" b="1" n="1">! This effectively increases the vector size by the size of the array.</line>
        <line t="C" i="1068" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line t="C" i="1069" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1070" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1071" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_insert_array" t="F" i="1072" b="1" n="1">function vector_insert_array( this, iterator, val ) result(res)</line>
        <line t="F" i="1073" b="1" n="1"></line>
        <line t="C" i="1074" b="1" n="1">! The vector</line>
        <line t="X" i="1075" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(inout) :: this</line>
        <line t="X" i="1076" b="1" n="1"></line>
        <line t="C" i="1077" b="1" n="1">! Iterator to node used as reference for insertion</line>
        <line t="X" i="1078" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="1079" b="1" n="1"></line>
        <line t="C" i="1080" b="1" n="1">! The element</line>
        <line t="X" i="1081" b="1" n="1">  class(xxtypebase__), dimension(:), intent(in) :: val</line>
        <line t="X" i="1082" b="1" n="1"></line>
        <line t="C" i="1083" b="1" n="1">! Iterator to the inserted element</line>
        <line t="X" i="1084" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="1085" b="1" n="1"></line>
        <line t="C" i="1086" b="1" n="1">! Insert by index</line>
        <line t="X" i="1087" b="1" n="1">  res%idx = this%insert( iterator%idx, val )</line>
        <line t="X" i="1088" b="1" n="1"></line>
        <line t="C" i="1089" b="1" n="1">! Assign pointer to parent</line>
        <line t="X" i="1090" b="1" n="1">  res%parent =&gt; this</line>
        <line t="X" i="1091" b="1" n="1"></line>
        <line t="EF" i="1092" b="1" n="1">end function vector_insert_array</line>
        <line t="EF" i="1093" b="1" n="1"></line>
        <line t="EF" i="1094" b="1" n="1"></line>
        <line t="C" i="1095" b="1" n="1">! Insert elements</line>
        <line t="C" i="1096" b="1" n="1">! The container is extended by inserting new elements before the element at</line>
        <line t="C" i="1097" b="1" n="1">! the specified position (by absolute index)</line>
        <line t="C" i="1098" b="1" n="1">! This effectively increases the vector size by n.</line>
        <line t="C" i="1099" b="1" n="1">! Iterator remains associated to the node in input</line>
        <line k="vector_insert_array_at" t="F" i="1100" b="1" n="1">function vector_insert_array_at( this, index, val ) result(res)</line>
        <line t="F" i="1101" b="1" n="1"></line>
        <line t="C" i="1102" b="1" n="1">! The vector</line>
        <line t="X" i="1103" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1104" b="1" n="1"></line>
        <line t="C" i="1105" b="1" n="1">! Index to element used as reference for insertion</line>
        <line t="X" i="1106" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1107" b="1" n="1"></line>
        <line t="C" i="1108" b="1" n="1">! The element</line>
        <line t="X" i="1109" b="1" n="1">  class(xxtypebase__), dimension(:), intent(in) :: val</line>
        <line t="X" i="1110" b="1" n="1"></line>
        <line t="C" i="1111" b="1" n="1">! Index in this to the start of the inserted section</line>
        <line t="X" i="1112" b="1" n="1">  integer :: res</line>
        <line t="X" i="1113" b="1" n="1"></line>
        <line t="C" i="1114" b="1" n="1">! Counter</line>
        <line t="X" i="1115" b="1" n="1">  integer :: i, j, n</line>
        <line t="X" i="1116" b="1" n="1"></line>
        <line t="C" i="1117" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="1118" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1119" b="2" n="2"></line>
        <line t="C" i="1120" b="2" n="2">!   Compute the number of elements</line>
        <line t="X" i="1121" b="2" n="2">    n = size(val)</line>
        <line t="X" i="1122" b="2" n="2"></line>
        <line t="C" i="1123" b="2" n="2">!   Check for allocation status and initialize if required</line>
        <line t="X" i="1124" b="2" n="2">    call this%reserve( this%count + n )</line>
        <line t="X" i="1125" b="2" n="2"></line>
        <line t="C" i="1126" b="2" n="2">!   Make room for the inserted elements. Move pointers, not memory</line>
        <line t="X" i="1127" b="3" n="3">    do i = this%count, index, -1</line>
        <line t="X" i="1128" b="3" n="3">      this%data(i+n)%element =&gt; this%data(i)%element</line>
        <line t="X" i="1129" b="3" n="2">    end do</line>
        <line t="X" i="1130" b="3" n="2"></line>
        <line t="C" i="1131" b="3" n="2">!   Loop on the number of elements to insert</line>
        <line t="X" i="1132" b="4" n="3">    do i = 1, n</line>
        <line t="X" i="1133" b="4" n="3"></line>
        <line t="C" i="1134" b="4" n="3">!     Allocate memory for the new element nd copy</line>
        <line t="X" i="1135" b="4" n="3">      j = index + i - 1</line>
        <line t="X" i="1136" b="4" n="3">      call element_assign_pointer( this%data(j)%element, val(i) )</line>
        <line t="X" i="1137" b="4" n="3"></line>
        <line t="X" i="1138" b="4" n="2">    end do</line>
        <line t="X" i="1139" b="4" n="2"></line>
        <line t="C" i="1140" b="4" n="2">!   Increase vector size</line>
        <line t="X" i="1141" b="4" n="2">    this%count = this%count + n</line>
        <line t="X" i="1142" b="4" n="2"></line>
        <line t="C" i="1143" b="4" n="2">!   Set the return index</line>
        <line t="X" i="1144" b="4" n="2">    res = index</line>
        <line t="X" i="1145" b="4" n="2"></line>
        <line t="X" i="1146" b="4" n="1">  end if</line>
        <line t="X" i="1147" b="4" n="1"></line>
        <line t="EF" i="1148" b="4" n="1">end function vector_insert_array_at</line>
        <line t="EF" i="1149" b="1" n="1"></line>
        <line t="EF" i="1150" b="1" n="1"></line>
        <line t="C" i="1151" b="1" n="1">! Erase elements</line>
        <line t="C" i="1152" b="1" n="1">! Removes from the vector container either a single element (position)</line>
        <line t="C" i="1153" b="1" n="1">! This effectively reduces the container size by one element, which is destroyed.</line>
        <line t="C" i="1154" b="1" n="1">! Input iterator returns not associated</line>
        <line t="C" i="1155" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1156" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1157" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_erase_single" t="S" i="1158" b="1" n="1">subroutine vector_erase_single( this, iterator )</line>
        <line t="S" i="1159" b="1" n="1"></line>
        <line t="C" i="1160" b="1" n="1">! The vector</line>
        <line t="X" i="1161" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1162" b="1" n="1"></line>
        <line t="C" i="1163" b="1" n="1">! Iterator to node to remove</line>
        <line t="X" i="1164" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="1165" b="1" n="1"></line>
        <line t="C" i="1166" b="1" n="1">! Erase by index</line>
        <line t="X" i="1167" b="1" n="1">  call this%erase( iterator%idx )</line>
        <line t="X" i="1168" b="1" n="1"></line>
        <line t="ES" i="1169" b="1" n="1">end subroutine vector_erase_single</line>
        <line t="ES" i="1170" b="1" n="1"></line>
        <line t="ES" i="1171" b="1" n="1"></line>
        <line t="C" i="1172" b="1" n="1">! Erase elements</line>
        <line t="C" i="1173" b="1" n="1">! Removes from the vector container either a single element (position by absolute index)</line>
        <line t="C" i="1174" b="1" n="1">! This effectively reduces the container size by one element, which is destroyed.</line>
        <line t="C" i="1175" b="1" n="1">! Input iterator returns not associated</line>
        <line k="vector_erase_single_at" t="S" i="1176" b="1" n="1">subroutine vector_erase_single_at( this, index )</line>
        <line t="S" i="1177" b="1" n="1"></line>
        <line t="C" i="1178" b="1" n="1">! The vector</line>
        <line t="X" i="1179" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1180" b="1" n="1"></line>
        <line t="C" i="1181" b="1" n="1">! Index to element erase</line>
        <line t="X" i="1182" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1183" b="1" n="1"></line>
        <line t="C" i="1184" b="1" n="1">! Local variables</line>
        <line t="X" i="1185" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="1186" b="1" n="1"></line>
        <line t="C" i="1187" b="1" n="1">! Check that there are elements in the vector</line>
        <line t="X" i="1188" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="1189" b="2" n="2"></line>
        <line t="C" i="1190" b="2" n="2">!   Check that index is within bounds; else do nothing</line>
        <line t="X" i="1191" b="3" n="3">    if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1192" b="3" n="3"></line>
        <line t="C" i="1193" b="3" n="3">!     Delete the element</line>
        <line t="X" i="1194" b="3" n="3">      deallocate( this%data(index)%element )</line>
        <line t="X" i="1195" b="3" n="3"></line>
        <line t="C" i="1196" b="3" n="3">!     Reallocate the elements. Move pointers, not memory</line>
        <line t="X" i="1197" b="4" n="4">      do i = index, this%count</line>
        <line t="X" i="1198" b="4" n="4">        j = i + 1</line>
        <line t="X" i="1199" b="5" n="5">        if( j &lt;= size(this%data) ) then</line>
        <line t="X" i="1200" b="5" n="5">          this%data(i)%element =&gt; this%data(j)%element</line>
        <line t="X" i="1201" b="6" n="5">        else</line>
        <line t="X" i="1202" b="6" n="5">          this%data(i)%element =&gt; null()</line>
        <line t="X" i="1203" b="6" n="4">        end if</line>
        <line t="X" i="1204" b="6" n="3">      end do</line>
        <line t="X" i="1205" b="6" n="3"></line>
        <line t="C" i="1206" b="6" n="3">!     Nullify the last element</line>
        <line t="X" i="1207" b="6" n="3">      this%data(this%count)%element =&gt; null()</line>
        <line t="X" i="1208" b="6" n="3"></line>
        <line t="C" i="1209" b="6" n="3">!     Decrease counter</line>
        <line t="X" i="1210" b="6" n="3">      this%count = this%count - 1</line>
        <line t="X" i="1211" b="6" n="3"></line>
        <line t="X" i="1212" b="6" n="2">    end if</line>
        <line t="X" i="1213" b="6" n="2"></line>
        <line t="X" i="1214" b="6" n="1">  end if</line>
        <line t="X" i="1215" b="6" n="1"></line>
        <line t="ES" i="1216" b="6" n="1">end subroutine vector_erase_single_at</line>
        <line t="ES" i="1217" b="1" n="1"></line>
        <line t="ES" i="1218" b="1" n="1"></line>
        <line t="C" i="1219" b="1" n="1">! Erase elements</line>
        <line t="C" i="1220" b="1" n="1">! Removes from the vector container either a range of elements (first,last).</line>
        <line t="C" i="1221" b="1" n="1">! This effectively reduces the container size by the number of elements removed,</line>
        <line t="C" i="1222" b="1" n="1">! which are destroyed.</line>
        <line t="C" i="1223" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1224" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1225" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_erase_range" t="S" i="1226" b="1" n="1">subroutine vector_erase_range( this, first, last )</line>
        <line t="S" i="1227" b="1" n="1"></line>
        <line t="C" i="1228" b="1" n="1">! The vector</line>
        <line t="X" i="1229" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1230" b="1" n="1"></line>
        <line t="C" i="1231" b="1" n="1">! Iterator to first node to remove</line>
        <line t="X" i="1232" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="1233" b="1" n="1"></line>
        <line t="C" i="1234" b="1" n="1">! Iterator to last node to remove</line>
        <line t="X" i="1235" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="1236" b="1" n="1"></line>
        <line t="C" i="1237" b="1" n="1">! Erase using indexes</line>
        <line t="X" i="1238" b="1" n="1">  call this%erase( first%idx, last%idx )</line>
        <line t="X" i="1239" b="1" n="1"></line>
        <line t="ES" i="1240" b="1" n="1">end subroutine vector_erase_range</line>
        <line t="ES" i="1241" b="1" n="1"></line>
        <line t="ES" i="1242" b="1" n="1"></line>
        <line t="C" i="1243" b="1" n="1">! Erase elements</line>
        <line t="C" i="1244" b="1" n="1">! Removes from the vector container either a range of elements (first,last).</line>
        <line t="C" i="1245" b="1" n="1">! This effectively reduces the container size by the number of elements removed,</line>
        <line t="C" i="1246" b="1" n="1">! which are destroyed.</line>
        <line k="vector_erase_range_at" t="S" i="1247" b="1" n="1">subroutine vector_erase_range_at( this, ifirst, ilast )</line>
        <line t="S" i="1248" b="1" n="1"></line>
        <line t="C" i="1249" b="1" n="1">! The vector</line>
        <line t="X" i="1250" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1251" b="1" n="1"></line>
        <line t="C" i="1252" b="1" n="1">! Index to first node to remove</line>
        <line t="X" i="1253" b="1" n="1">  integer, intent(in) :: ifirst</line>
        <line t="X" i="1254" b="1" n="1"></line>
        <line t="C" i="1255" b="1" n="1">! Index to last node to remove</line>
        <line t="X" i="1256" b="1" n="1">  integer, intent(in) :: ilast</line>
        <line t="X" i="1257" b="1" n="1"></line>
        <line t="C" i="1258" b="1" n="1">! Local variables</line>
        <line t="X" i="1259" b="1" n="1">  integer :: i, n, m</line>
        <line t="X" i="1260" b="1" n="1"></line>
        <line t="C" i="1261" b="1" n="1">! Check that indexes are within bounds; else do nothing</line>
        <line t="X" i="1262" b="2" n="2">  if( ifirst &gt;= 1 .and. ifirst &lt;= this%count ) then</line>
        <line t="X" i="1263" b="3" n="3">    if( ilast &gt;= 1 .and. ilast &lt;= this%count ) then</line>
        <line t="X" i="1264" b="3" n="3"></line>
        <line t="C" i="1265" b="3" n="3">!     Compute the number of nodes to remove</line>
        <line t="X" i="1266" b="3" n="3">      n = ilast - ifirst + 1</line>
        <line t="X" i="1267" b="3" n="3"></line>
        <line t="C" i="1268" b="3" n="3">!     Compute the number of nodes after ilast</line>
        <line t="X" i="1269" b="3" n="3">      m = this%count - ilast</line>
        <line t="X" i="1270" b="3" n="3"></line>
        <line t="C" i="1271" b="3" n="3">!     Delete the elements</line>
        <line t="X" i="1272" b="4" n="4">      do i = ifirst, ilast</line>
        <line t="X" i="1273" b="4" n="4">        deallocate( this%data(i)%element )</line>
        <line t="X" i="1274" b="4" n="3">      end do</line>
        <line t="X" i="1275" b="4" n="3"></line>
        <line t="C" i="1276" b="4" n="3">!     Reallocate the elements at end of vector. Move pointers, not memory</line>
        <line t="X" i="1277" b="5" n="4">      do i = 1, m</line>
        <line t="X" i="1278" b="5" n="4">        this%data(ifirst+i-1)%element =&gt; this%data(ilast+i)%element</line>
        <line t="X" i="1279" b="5" n="3">      end do</line>
        <line t="X" i="1280" b="5" n="3"></line>
        <line t="C" i="1281" b="5" n="3">!     Nullify the last elements</line>
        <line t="X" i="1282" b="6" n="4">      do i = ifirst + m + 1, this%count</line>
        <line t="X" i="1283" b="6" n="4">        this%data(i)%element =&gt; null()</line>
        <line t="X" i="1284" b="6" n="3">      end do</line>
        <line t="X" i="1285" b="6" n="3"></line>
        <line t="C" i="1286" b="6" n="3">!     Decrease counter</line>
        <line t="X" i="1287" b="6" n="3">      this%count = this%count - n</line>
        <line t="X" i="1288" b="6" n="3"></line>
        <line t="X" i="1289" b="6" n="2">    end if</line>
        <line t="X" i="1290" b="6" n="1">  end if</line>
        <line t="X" i="1291" b="6" n="1"></line>
        <line t="ES" i="1292" b="6" n="1">end subroutine vector_erase_range_at</line>
        <line t="ES" i="1293" b="1" n="1"></line>
        <line t="ES" i="1294" b="1" n="1"></line>
        <line t="C" i="1295" b="1" n="1">! Swap content</line>
        <line t="C" i="1296" b="1" n="1">! Exchanges the content of the container by the content of other, which is another vector of the same type.</line>
        <line t="C" i="1297" b="1" n="1">! Sizes may differ.</line>
        <line t="C" i="1298" b="1" n="1">! After the call to this member function, the elements in this container are</line>
        <line t="C" i="1299" b="1" n="1">! those which were in other before the call,</line>
        <line t="C" i="1300" b="1" n="1">! and the elements of other are those which were in this.</line>
        <line t="C" i="1301" b="1" n="1">! All iterators, references and pointers remain valid for the swapped objects.</line>
        <line k="vector_swap" t="S" i="1302" b="1" n="1">pure subroutine vector_swap( this, other )</line>
        <line t="S" i="1303" b="1" n="1"></line>
        <line t="C" i="1304" b="1" n="1">! The vector</line>
        <line t="X" i="1305" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1306" b="1" n="1"></line>
        <line t="C" i="1307" b="1" n="1">! The vector to swap</line>
        <line t="X" i="1308" b="1" n="1">  type(xxtypebase___vector_ftl), intent(inout) :: other</line>
        <line t="X" i="1309" b="1" n="1"></line>
        <line t="C" i="1310" b="1" n="1">! Local variables</line>
        <line t="X" i="1311" b="1" n="1">  class(xxtypebase__), pointer :: tmpe</line>
        <line t="X" i="1312" b="1" n="1">  integer :: i, n</line>
        <line t="X" i="1313" b="1" n="1"></line>
        <line t="C" i="1314" b="1" n="1">! Check for required reallocations</line>
        <line t="C" i="1315" b="1" n="1">! Note that only one of the arrays requires reallocaiton; the other one should fit</line>
        <line t="X" i="1316" b="2" n="2">  if( this%count &gt; size(other%data) ) then</line>
        <line t="X" i="1317" b="2" n="2">    call other%reserve(this%count)</line>
        <line t="X" i="1318" b="3" n="2">  else if( other%count &gt; size(this%data) ) then</line>
        <line t="X" i="1319" b="3" n="2">    call this%reserve(other%count)</line>
        <line t="X" i="1320" b="3" n="1">  end if</line>
        <line t="X" i="1321" b="3" n="1"></line>
        <line t="C" i="1322" b="3" n="1">! Swap on the common part of the nodes (move pointers, not memory)</line>
        <line t="X" i="1323" b="3" n="1">  n = min( this%count, other%count )</line>
        <line t="X" i="1324" b="4" n="2">  do i = 1, n</line>
        <line t="X" i="1325" b="4" n="2">    tmpe =&gt; this%data(i)%element</line>
        <line t="X" i="1326" b="4" n="2">    this%data(i)%element =&gt; other%data(i)%element</line>
        <line t="X" i="1327" b="4" n="2">    other%data(i)%element =&gt; tmpe</line>
        <line t="X" i="1328" b="4" n="1">  end do</line>
        <line t="X" i="1329" b="4" n="1"></line>
        <line t="C" i="1330" b="4" n="1"> ! Swap the extra part of the nodes in the largest vector</line>
        <line t="X" i="1331" b="5" n="2">   if(this%count &gt; other%count ) then</line>
        <line t="X" i="1332" b="6" n="3">    do i = n + 1, this%count</line>
        <line t="X" i="1333" b="6" n="3">      other%data(i)%element =&gt; this%data(i)%element</line>
        <line t="X" i="1334" b="6" n="3">      this%data(i)%element =&gt; null()</line>
        <line t="X" i="1335" b="6" n="2">    end do</line>
        <line t="X" i="1336" b="7" n="2">   else</line>
        <line t="X" i="1337" b="8" n="3">    do i = n + 1, other%count</line>
        <line t="X" i="1338" b="8" n="3">      this%data(i)%element =&gt; other%data(i)%element</line>
        <line t="X" i="1339" b="8" n="3">      other%data(i)%element =&gt; null()</line>
        <line t="X" i="1340" b="8" n="2">    end do</line>
        <line t="X" i="1341" b="8" n="1">  end if</line>
        <line t="X" i="1342" b="8" n="1"></line>
        <line t="C" i="1343" b="8" n="1">! Swap the vector sizes</line>
        <line t="X" i="1344" b="8" n="1">  n = this%count</line>
        <line t="X" i="1345" b="8" n="1">  this%count = other%count</line>
        <line t="X" i="1346" b="8" n="1">  other%count = n</line>
        <line t="X" i="1347" b="8" n="1"></line>
        <line t="ES" i="1348" b="8" n="1">end subroutine vector_swap</line>
        <line t="ES" i="1349" b="1" n="1"></line>
        <line t="ES" i="1350" b="1" n="1"></line>
        <line t="C" i="1351" b="1" n="1">! Change size</line>
        <line t="C" i="1352" b="1" n="1">! Resizes the container so that it contains n elements.</line>
        <line t="C" i="1353" b="1" n="1">! If n is smaller than the current container size, the content is reduced to its</line>
        <line t="C" i="1354" b="1" n="1">! first n elements, removing those beyond (and destroying them).</line>
        <line t="C" i="1355" b="1" n="1">! If n is greater than the current container size, the content is expanded by</line>
        <line t="C" i="1356" b="1" n="1">! inserting at the end as many elements as needed to reach a size of n.</line>
        <line t="C" i="1357" b="1" n="1">! If val is specified, the new elements are initialized as copies of val,</line>
        <line t="C" i="1358" b="1" n="1">! otherwise, they are value-initialized.</line>
        <line k="vector_resize" t="S" i="1359" b="1" n="1">subroutine vector_resize( this, n, val )</line>
        <line t="S" i="1360" b="1" n="1"></line>
        <line t="C" i="1361" b="1" n="1">! The vector</line>
        <line t="X" i="1362" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1363" b="1" n="1"></line>
        <line t="C" i="1364" b="1" n="1">! The number of elements in the resulting vector</line>
        <line t="X" i="1365" b="1" n="1">  integer, intent(in) :: n</line>
        <line t="X" i="1366" b="1" n="1"></line>
        <line t="C" i="1367" b="1" n="1">! The element to use to initialise traling elements</line>
        <line t="X" i="1368" b="1" n="1">  class(xxtypebase__), optional, target, intent(in) :: val</line>
        <line t="X" i="1369" b="1" n="1"></line>
        <line t="C" i="1370" b="1" n="1">! Local variables</line>
        <line t="X" i="1371" b="1" n="1">  integer :: i</line>
        <line t="X" i="1372" b="1" n="1">  class(xxtypebase__), pointer :: init</line>
        <line t="X" i="1373" b="1" n="1">  class(xxtypebase__), allocatable, target :: default</line>
        <line t="X" i="1374" b="1" n="1"></line>
        <line t="C" i="1375" b="1" n="1">! Vector size is greater than requested size</line>
        <line t="X" i="1376" b="2" n="2">  if( this%count &lt; n ) then</line>
        <line t="X" i="1377" b="2" n="2"></line>
        <line t="C" i="1378" b="2" n="2">!   Check if initialisation value has been given</line>
        <line t="X" i="1379" b="3" n="3">    if( present(val) ) then</line>
        <line t="X" i="1380" b="3" n="3">      init =&gt; val</line>
        <line t="X" i="1381" b="4" n="3">    else</line>
        <line t="X" i="1382" b="4" n="3">      allocate( default, mold=this%data(1)%element )</line>
        <line t="X" i="1383" b="4" n="3">      init =&gt; default</line>
        <line t="X" i="1384" b="4" n="2">    end if</line>
        <line t="X" i="1385" b="4" n="2"></line>
        <line t="C" i="1386" b="4" n="2">!   Loop on the number of element to add</line>
        <line t="X" i="1387" b="5" n="3">    do i = this%count + 1, n</line>
        <line t="X" i="1388" b="5" n="3">      call this%push_back(init)</line>
        <line t="X" i="1389" b="5" n="2">    end do</line>
        <line t="X" i="1390" b="5" n="2"></line>
        <line t="C" i="1391" b="5" n="2">! Vector size is smaller than requested size</line>
        <line t="X" i="1392" b="6" n="2">  else if( this%count &gt; n ) then</line>
        <line t="X" i="1393" b="6" n="2"></line>
        <line t="C" i="1394" b="6" n="2">!   Loop on the number of element to remove</line>
        <line t="X" i="1395" b="7" n="3">    do i = this%count, n + 1, -1</line>
        <line t="X" i="1396" b="7" n="3">      call this%pop_back()</line>
        <line t="X" i="1397" b="7" n="2">    end do</line>
        <line t="X" i="1398" b="7" n="2"></line>
        <line t="C" i="1399" b="7" n="2">! Vector size is the same as the requested size</line>
        <line t="X" i="1400" b="8" n="2">  else</line>
        <line t="X" i="1401" b="8" n="1">  endif</line>
        <line t="X" i="1402" b="8" n="1"></line>
        <line t="ES" i="1403" b="8" n="1">end subroutine vector_resize</line>
        <line t="ES" i="1404" b="1" n="1"></line>
        <line t="ES" i="1405" b="1" n="1"></line>
        <line t="C" i="1406" b="1" n="1">! Clear content</line>
        <line t="C" i="1407" b="1" n="1">! Removes all elements from the vector container (which are destroyed)</line>
        <line t="C" i="1408" b="1" n="1">! and leaving the container with a size of 0</line>
        <line k="vector_clear" t="S" i="1409" b="1" n="1">subroutine vector_clear( this )</line>
        <line t="S" i="1410" b="1" n="1"></line>
        <line t="C" i="1411" b="1" n="1">! The vector</line>
        <line t="X" i="1412" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1413" b="1" n="1"></line>
        <line t="C" i="1414" b="1" n="1">! Local variables</line>
        <line t="X" i="1415" b="1" n="1">  integer :: i</line>
        <line t="X" i="1416" b="1" n="1"></line>
        <line t="C" i="1417" b="1" n="1">! Verify vector status</line>
        <line t="X" i="1418" b="2" n="2">  if( allocated( this%data ) ) then</line>
        <line t="X" i="1419" b="2" n="2"></line>
        <line t="C" i="1420" b="2" n="2">!   Deallocate all elements</line>
        <line t="X" i="1421" b="3" n="3">    do i = 1, this%count</line>
        <line t="X" i="1422" b="3" n="3">      deallocate( this%data(i)%element )</line>
        <line t="X" i="1423" b="3" n="2">    end do</line>
        <line t="X" i="1424" b="3" n="2"></line>
        <line t="C" i="1425" b="3" n="2">!   Deallocate the vector internal array</line>
        <line t="X" i="1426" b="3" n="2">    deallocate( this%data )</line>
        <line t="X" i="1427" b="3" n="2"></line>
        <line t="X" i="1428" b="3" n="1">  end if</line>
        <line t="X" i="1429" b="3" n="1"></line>
        <line t="C" i="1430" b="3" n="1">! Reset counter</line>
        <line t="X" i="1431" b="3" n="1">  this%count = 0</line>
        <line t="X" i="1432" b="3" n="1"></line>
        <line t="ES" i="1433" b="3" n="1">end subroutine vector_clear</line>
        <line t="ES" i="1434" b="1" n="1"></line>
        <line t="ES" i="1435" b="1" n="1"></line>
        <line t="C" i="1436" b="1" n="1">! Get reference to element at given position</line>
        <line k="vector_at_get" t="F" i="1437" b="1" n="1">function vector_at_get( this, index ) result(res)</line>
        <line t="F" i="1438" b="1" n="1"></line>
        <line t="C" i="1439" b="1" n="1">! The vector</line>
        <line t="X" i="1440" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="1441" b="1" n="1"></line>
        <line t="C" i="1442" b="1" n="1">! The position in the vector</line>
        <line t="X" i="1443" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1444" b="1" n="1"></line>
        <line t="C" i="1445" b="1" n="1">! The object to replace</line>
        <line t="X" i="1446" b="1" n="1">  class(xxtypebase__), pointer :: res</line>
        <line t="X" i="1447" b="1" n="1"></line>
        <line t="C" i="1448" b="1" n="1">! Check that indexes are within bounds; else do nothing</line>
        <line t="X" i="1449" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1450" b="2" n="2">    res =&gt; this%data(index)%element</line>
        <line t="X" i="1451" b="3" n="2">  else</line>
        <line t="X" i="1452" b="3" n="2">    res =&gt; null()</line>
        <line t="X" i="1453" b="3" n="1">  end if</line>
        <line t="X" i="1454" b="3" n="1"></line>
        <line t="EF" i="1455" b="3" n="1">end function vector_at_get</line>
        <line t="EF" i="1456" b="1" n="1"></line>
        <line t="EF" i="1457" b="1" n="1"></line>
        <line t="C" i="1458" b="1" n="1">! Get the value pointed by the index</line>
        <line k="vector_element_from_index" t="F" i="1459" b="1" n="1">pure function vector_element_from_index( this, index ) result(res)</line>
        <line t="F" i="1460" b="1" n="1"></line>
        <line t="C" i="1461" b="1" n="1">! The vector</line>
        <line t="X" i="1462" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="1463" b="1" n="1"></line>
        <line t="C" i="1464" b="1" n="1">! The index</line>
        <line t="X" i="1465" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1466" b="1" n="1"></line>
        <line t="C" i="1467" b="1" n="1">! The returned element</line>
        <line t="X" i="1468" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="1469" b="1" n="1"></line>
        <line t="C" i="1470" b="1" n="1">! Check that index is within bounds</line>
        <line t="X" i="1471" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1472" b="2" n="2"></line>
        <line t="C" i="1473" b="2" n="2">!   Get the element</line>
        <line t="X" i="1474" b="2" n="2">    allocate( res, source=this%data(index)%element )</line>
        <line t="X" i="1475" b="2" n="2"></line>
        <line t="X" i="1476" b="2" n="1">  end if</line>
        <line t="X" i="1477" b="2" n="1"></line>
        <line t="EF" i="1478" b="2" n="1">end function vector_element_from_index</line>
        <line t="EF" i="1479" b="1" n="1"></line>
        <line t="EF" i="1480" b="1" n="1"></line>
        <line t="C" i="1481" b="1" n="1">! Get the value pointed by the index</line>
        <line k="vector_element_ptr_from_index" t="F" i="1482" b="1" n="1">function vector_element_ptr_from_index( this, index ) result(res)</line>
        <line t="F" i="1483" b="1" n="1"></line>
        <line t="C" i="1484" b="1" n="1">! The vector</line>
        <line t="X" i="1485" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(in) :: this</line>
        <line t="X" i="1486" b="1" n="1"></line>
        <line t="C" i="1487" b="1" n="1">! The index</line>
        <line t="X" i="1488" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1489" b="1" n="1"></line>
        <line t="C" i="1490" b="1" n="1">! The returned element</line>
        <line t="X" i="1491" b="1" n="1">  class(xxtypebase__), pointer :: res</line>
        <line t="X" i="1492" b="1" n="1"></line>
        <line t="C" i="1493" b="1" n="1">! Check that index is within bounds</line>
        <line t="X" i="1494" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1495" b="2" n="2"></line>
        <line t="C" i="1496" b="2" n="2">!   Get the element pointer</line>
        <line t="X" i="1497" b="2" n="2">    res =&gt; this%data(index)%element</line>
        <line t="X" i="1498" b="2" n="2"></line>
        <line t="X" i="1499" b="2" n="1">  end if</line>
        <line t="X" i="1500" b="2" n="1"></line>
        <line t="EF" i="1501" b="2" n="1">end function vector_element_ptr_from_index</line>
        <line t="EF" i="1502" b="1" n="1"></line>
        <line t="EF" i="1503" b="1" n="1"></line>
        <line t="C" i="1504" b="1" n="1">! Set the value pointed by the index</line>
        <line t="C" i="1505" b="1" n="1">! Provide destructor is the replaced element has complex memory components</line>
        <line k="vector_element_to_index" t="S" i="1506" b="1" n="1">subroutine vector_element_to_index( this, index, element )</line>
        <line t="S" i="1507" b="1" n="1"></line>
        <line t="C" i="1508" b="1" n="1">! The vector</line>
        <line t="X" i="1509" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1510" b="1" n="1"></line>
        <line t="C" i="1511" b="1" n="1">! The index</line>
        <line t="X" i="1512" b="1" n="1">  integer, intent(in) :: index</line>
        <line t="X" i="1513" b="1" n="1"></line>
        <line t="C" i="1514" b="1" n="1">! The element</line>
        <line t="X" i="1515" b="1" n="1">  class(xxtypebase__), intent(in) :: element</line>
        <line t="X" i="1516" b="1" n="1"></line>
        <line t="C" i="1517" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="1518" b="2" n="2">  if( index &gt;= 1 .and. index &lt;= this%count ) then</line>
        <line t="X" i="1519" b="2" n="2"></line>
        <line t="C" i="1520" b="2" n="2">!   Set the element</line>
        <line t="X" i="1521" b="3" n="3">    if( associated(this%data(index)%element) ) deallocate(this%data(index)%element)</line>
        <line t="X" i="1522" b="3" n="3">    allocate( this%data(index)%element, source=element )</line>
        <line t="X" i="1523" b="3" n="3"></line>
        <line t="X" i="1524" b="3" n="2">  end if</line>
        <line t="X" i="1525" b="3" n="2"></line>
        <line t="ES" i="1526" b="3" n="2">end subroutine vector_element_to_index</line>
        <line t="ES" i="1527" b="1" n="2"></line>
        <line t="ES" i="1528" b="1" n="2"></line>
        <line t="C" i="1529" b="1" n="2">! Transfer elements from vector to vector</line>
        <line t="C" i="1530" b="1" n="2">! Transfers elements from source into the container, inserting them at position.</line>
        <line t="C" i="1531" b="1" n="2">! This effectively inserts those elements into the container and removes them from source,</line>
        <line t="C" i="1532" b="1" n="2">! altering the sizes of both containers.</line>
        <line t="C" i="1533" b="1" n="2">! The operation does not involve the construction or destruction of any element.</line>
        <line t="C" i="1534" b="1" n="2">! (1) transfers all the elements of source into the container.</line>
        <line t="C" i="1535" b="1" n="2">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1536" b="1" n="2">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1537" b="1" n="2">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_splice_vector" t="S" i="1538" b="1" n="1">subroutine vector_splice_vector( this, position, source )</line>
        <line t="S" i="1539" b="1" n="1"></line>
        <line t="C" i="1540" b="1" n="1">! The vector</line>
        <line t="X" i="1541" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1542" b="1" n="1"></line>
        <line t="C" i="1543" b="1" n="1">! The position in vector to insert the elements</line>
        <line t="X" i="1544" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: position</line>
        <line t="X" i="1545" b="1" n="1"></line>
        <line t="C" i="1546" b="1" n="1">! The source vector</line>
        <line t="X" i="1547" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: source</line>
        <line t="X" i="1548" b="1" n="1"></line>
        <line t="C" i="1549" b="1" n="1">! Call the generic splice function</line>
        <line t="X" i="1550" b="1" n="1">  call this%vector_splice_nodes( position, source, 1, source%count )</line>
        <line t="X" i="1551" b="1" n="1"></line>
        <line t="C" i="1552" b="1" n="1">! Deallocate memory in source</line>
        <line t="X" i="1553" b="1" n="1">  deallocate(source%data)</line>
        <line t="X" i="1554" b="1" n="1"></line>
        <line t="ES" i="1555" b="1" n="1">end subroutine vector_splice_vector</line>
        <line t="ES" i="1556" b="1" n="1"></line>
        <line t="ES" i="1557" b="1" n="1"></line>
        <line t="C" i="1558" b="1" n="1">! Transfer elements from vector to vector</line>
        <line t="C" i="1559" b="1" n="1">! Transfers elements from source into the container, inserting them at position.</line>
        <line t="C" i="1560" b="1" n="1">! This effectively inserts those elements into the container and removes them from source,</line>
        <line t="C" i="1561" b="1" n="1">! altering the sizes of both containers.</line>
        <line t="C" i="1562" b="1" n="1">! The operation does not involve the construction or destruction of any element.</line>
        <line t="C" i="1563" b="1" n="1">! (2) transfers only the element pointed by iterator from x into the container.</line>
        <line t="C" i="1564" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1565" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1566" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_splice_single" t="S" i="1567" b="1" n="1">subroutine vector_splice_single( this, position, source, it )</line>
        <line t="S" i="1568" b="1" n="1"></line>
        <line t="C" i="1569" b="1" n="1">! The vector</line>
        <line t="X" i="1570" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1571" b="1" n="1"></line>
        <line t="C" i="1572" b="1" n="1">! The position in vector to insert the elements</line>
        <line t="X" i="1573" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: position</line>
        <line t="X" i="1574" b="1" n="1"></line>
        <line t="C" i="1575" b="1" n="1">! The source vector</line>
        <line t="X" i="1576" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: source</line>
        <line t="X" i="1577" b="1" n="1"></line>
        <line t="C" i="1578" b="1" n="1">! The element position in source</line>
        <line t="X" i="1579" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: it</line>
        <line t="X" i="1580" b="1" n="1"></line>
        <line t="C" i="1581" b="1" n="1">! Call the generic splice function</line>
        <line t="X" i="1582" b="1" n="1">  call this%vector_splice_nodes( position, source, it%idx, it%idx )</line>
        <line t="X" i="1583" b="1" n="1"></line>
        <line t="C" i="1584" b="1" n="1">! Deallocate memory in source if source array is empty</line>
        <line t="X" i="1585" b="2" n="2">  if( source%count == 0 ) deallocate(source%data)</line>
        <line t="X" i="1586" b="2" n="2"></line>
        <line t="ES" i="1587" b="2" n="2">end subroutine vector_splice_single</line>
        <line t="ES" i="1588" b="1" n="2"></line>
        <line t="ES" i="1589" b="1" n="2"></line>
        <line t="C" i="1590" b="1" n="2">! Transfer elements from vector to vector</line>
        <line t="C" i="1591" b="1" n="2">! Transfers elements from source into the container, inserting them at position.</line>
        <line t="C" i="1592" b="1" n="2">! This effectively inserts those elements into the container and removes them from source,</line>
        <line t="C" i="1593" b="1" n="2">! altering the sizes of both containers.</line>
        <line t="C" i="1594" b="1" n="2">! The operation does not involve the construction or destruction of any element.</line>
        <line t="C" i="1595" b="1" n="2">! (3) transfers the range (first,last) from source into the container.</line>
        <line t="C" i="1596" b="1" n="2">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="1597" b="1" n="2">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="1598" b="1" n="2">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_splice_range" t="S" i="1599" b="1" n="1">subroutine vector_splice_range( this, position, source, first, last )</line>
        <line t="S" i="1600" b="1" n="1"></line>
        <line t="C" i="1601" b="1" n="1">! The vector</line>
        <line t="X" i="1602" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1603" b="1" n="1"></line>
        <line t="C" i="1604" b="1" n="1">! The position in vector to insert the elements</line>
        <line t="X" i="1605" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: position</line>
        <line t="X" i="1606" b="1" n="1"></line>
        <line t="C" i="1607" b="1" n="1">! The source vector</line>
        <line t="X" i="1608" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: source</line>
        <line t="X" i="1609" b="1" n="1"></line>
        <line t="C" i="1610" b="1" n="1">! The first position in source to retrieve elements</line>
        <line t="X" i="1611" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: first</line>
        <line t="X" i="1612" b="1" n="1"></line>
        <line t="C" i="1613" b="1" n="1">! The last position in source to retrieve elements</line>
        <line t="X" i="1614" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: last</line>
        <line t="X" i="1615" b="1" n="1"></line>
        <line t="C" i="1616" b="1" n="1">! Call the generic splice function</line>
        <line t="X" i="1617" b="1" n="1">  call this%vector_splice_nodes( position, source, first%idx, last%idx )</line>
        <line t="X" i="1618" b="1" n="1"></line>
        <line t="C" i="1619" b="1" n="1">! Deallocate memory in source if source array is empty</line>
        <line t="X" i="1620" b="2" n="2">  if( source%count == 0 ) deallocate(source%data)</line>
        <line t="X" i="1621" b="2" n="2"></line>
        <line t="ES" i="1622" b="2" n="2">end subroutine vector_splice_range</line>
        <line t="ES" i="1623" b="1" n="2"></line>
        <line t="ES" i="1624" b="1" n="2"></line>
        <line t="C" i="1625" b="1" n="2">! Transfer elements from vector to vector</line>
        <line t="C" i="1626" b="1" n="2">! Actual implementation of splcie at node level</line>
        <line k="vector_splice_nodes" t="S" i="1627" b="1" n="1">subroutine vector_splice_nodes( this, position, source, ifirst, ilast )</line>
        <line t="S" i="1628" b="1" n="1"></line>
        <line t="C" i="1629" b="1" n="1">! The vector</line>
        <line t="X" i="1630" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1631" b="1" n="1"></line>
        <line t="C" i="1632" b="1" n="1">! The position in vector to insert the elements</line>
        <line t="X" i="1633" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: position</line>
        <line t="X" i="1634" b="1" n="1"></line>
        <line t="C" i="1635" b="1" n="1">! The source vector</line>
        <line t="X" i="1636" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: source</line>
        <line t="X" i="1637" b="1" n="1"></line>
        <line t="C" i="1638" b="1" n="1">! The first position in source to retrieve elements</line>
        <line t="X" i="1639" b="1" n="1">  integer, intent(in) :: ifirst</line>
        <line t="X" i="1640" b="1" n="1"></line>
        <line t="C" i="1641" b="1" n="1">! The last position in source to retrieve elements</line>
        <line t="X" i="1642" b="1" n="1">  integer, intent(in) :: ilast</line>
        <line t="X" i="1643" b="1" n="1"></line>
        <line t="C" i="1644" b="1" n="1">! Local variables</line>
        <line t="X" i="1645" b="1" n="1">  integer :: i, j, n</line>
        <line t="X" i="1646" b="1" n="1">  integer :: iposition</line>
        <line t="X" i="1647" b="1" n="1"></line>
        <line t="C" i="1648" b="1" n="1">! Check the input iterator</line>
        <line t="X" i="1649" b="2" n="2">  if( position%associated() ) then</line>
        <line t="X" i="1650" b="2" n="2"></line>
        <line t="C" i="1651" b="2" n="2">!   Normal insertion</line>
        <line t="X" i="1652" b="2" n="2">    iposition = position%idx</line>
        <line t="X" i="1653" b="2" n="2"></line>
        <line t="X" i="1654" b="3" n="2">  else</line>
        <line t="X" i="1655" b="3" n="2"></line>
        <line t="C" i="1656" b="3" n="2">!   Append at end of this</line>
        <line t="X" i="1657" b="3" n="2">    iposition = this%count + 1</line>
        <line t="X" i="1658" b="3" n="2"></line>
        <line t="X" i="1659" b="3" n="1">  end if</line>
        <line t="X" i="1660" b="3" n="1"></line>
        <line t="C" i="1661" b="3" n="1">! Check source contents</line>
        <line t="X" i="1662" b="4" n="2">  if( ifirst &gt;= 1 .and. ifirst &lt;= source%count ) then</line>
        <line t="X" i="1663" b="5" n="3">    if( ilast &gt;= 1 .and. ilast &lt;= source%count ) then</line>
        <line t="X" i="1664" b="5" n="3"></line>
        <line t="C" i="1665" b="5" n="3">!     Count the number of nodes in range</line>
        <line t="X" i="1666" b="5" n="3">      n = ilast - ifirst + 1</line>
        <line t="X" i="1667" b="5" n="3"></line>
        <line t="C" i="1668" b="5" n="3">!     Raallocate memory in container</line>
        <line t="X" i="1669" b="5" n="3">      call this%reserve( this%count + n )</line>
        <line t="X" i="1670" b="5" n="3"></line>
        <line t="C" i="1671" b="5" n="3">!     Make room for the inserted elements. Move pointers, not memory</line>
        <line t="X" i="1672" b="6" n="4">      do i = this%count, iposition, -1</line>
        <line t="X" i="1673" b="6" n="4">        this%data(i+n)%element =&gt; this%data(i)%element</line>
        <line t="X" i="1674" b="6" n="3">      end do</line>
        <line t="X" i="1675" b="6" n="3"></line>
        <line t="C" i="1676" b="6" n="3">!     Transfer elements from source</line>
        <line t="X" i="1677" b="7" n="4">      do i = 1, n</line>
        <line t="X" i="1678" b="7" n="4">        this%data(iposition+i-1)%element =&gt; source%data(ifirst+i-1)%element</line>
        <line t="X" i="1679" b="7" n="3">      end do</line>
        <line t="X" i="1680" b="7" n="3"></line>
        <line t="C" i="1681" b="7" n="3">!     Recompute number of elements in this</line>
        <line t="X" i="1682" b="7" n="3">      this%count = this%count + n</line>
        <line t="X" i="1683" b="7" n="3"></line>
        <line t="C" i="1684" b="7" n="3">!     Remove the nodes from source</line>
        <line t="X" i="1685" b="8" n="4">      do i = ifirst, source%count</line>
        <line t="X" i="1686" b="8" n="4">        j = i + n</line>
        <line t="X" i="1687" b="9" n="5">        if( j &lt;= size(source%data)) then</line>
        <line t="X" i="1688" b="9" n="5">          source%data(i)%element =&gt; source%data(j)%element</line>
        <line t="X" i="1689" b="10" n="5">        else</line>
        <line t="X" i="1690" b="10" n="5">          source%data(i)%element =&gt; null()</line>
        <line t="X" i="1691" b="10" n="4">        end if</line>
        <line t="X" i="1692" b="10" n="3">      end do</line>
        <line t="X" i="1693" b="10" n="3"></line>
        <line t="C" i="1694" b="10" n="3">!     Nullify tralining elements in source</line>
        <line t="X" i="1695" b="11" n="4">      do i = source%count, source%count - n + 1, -1</line>
        <line t="X" i="1696" b="11" n="4">        source%data(i)%element =&gt; null()</line>
        <line t="X" i="1697" b="11" n="3">      end do</line>
        <line t="X" i="1698" b="11" n="3"></line>
        <line t="C" i="1699" b="11" n="3">!     Recompute number of elements in source</line>
        <line t="X" i="1700" b="11" n="3">      source%count = source%count - n</line>
        <line t="X" i="1701" b="11" n="3"></line>
        <line t="X" i="1702" b="11" n="2">    end if</line>
        <line t="X" i="1703" b="11" n="1">  end if</line>
        <line t="X" i="1704" b="11" n="1"></line>
        <line t="ES" i="1705" b="11" n="1">end subroutine vector_splice_nodes</line>
        <line t="ES" i="1706" b="1" n="1"></line>
        <line t="ES" i="1707" b="1" n="1"></line>
        <line t="C" i="1708" b="1" n="1">! Remove elements with specific value</line>
        <line t="C" i="1709" b="1" n="1">! Removes from the container all the elements that compare equal to val.</line>
        <line t="C" i="1710" b="1" n="1">! This calls the destructor of these objects and reduces the container</line>
        <line t="C" i="1711" b="1" n="1">! size by the number of elements removed.</line>
        <line k="vector_remove" t="S" i="1712" b="1" n="1">subroutine vector_remove( this, val )</line>
        <line t="S" i="1713" b="1" n="1"></line>
        <line t="C" i="1714" b="1" n="1">! The vector</line>
        <line t="X" i="1715" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1716" b="1" n="1"></line>
        <line t="C" i="1717" b="1" n="1">! The value to use as comparison for the removal</line>
        <line t="X" i="1718" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="1719" b="1" n="1"></line>
        <line t="C" i="1720" b="1" n="1">! Local variables</line>
        <line t="X" i="1721" b="1" n="1">  integer :: i</line>
        <line t="X" i="1722" b="1" n="1"></line>
        <line t="C" i="1723" b="1" n="1">! Check that there are elements in the vector</line>
        <line t="X" i="1724" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="1725" b="2" n="2"></line>
        <line t="C" i="1726" b="2" n="2">!   Loop on the nodes</line>
        <line t="X" i="1727" b="2" n="2">    i = 1</line>
        <line t="X" i="1728" b="3" n="3">    do</line>
        <line t="X" i="1729" b="3" n="3"></line>
        <line t="C" i="1730" b="3" n="3">!     Check removal</line>
        <line t="X" i="1731" b="4" n="4">      if( this%data(i)%element == val ) then</line>
        <line t="X" i="1732" b="4" n="4"></line>
        <line t="C" i="1733" b="4" n="4">!       Remove</line>
        <line t="X" i="1734" b="4" n="4">        call this%erase(i)</line>
        <line t="X" i="1735" b="5" n="4">      else</line>
        <line t="X" i="1736" b="5" n="4"></line>
        <line t="C" i="1737" b="5" n="4">!       Iterate if not removal only</line>
        <line t="X" i="1738" b="5" n="4">        i = i + 1</line>
        <line t="X" i="1739" b="5" n="4"></line>
        <line t="X" i="1740" b="5" n="3">      end if</line>
        <line t="X" i="1741" b="5" n="3"></line>
        <line t="C" i="1742" b="5" n="3">!     Checkt exit condition</line>
        <line t="X" i="1743" b="6" n="4">      if( i &gt; this%count ) exit</line>
        <line t="X" i="1744" b="6" n="4"></line>
        <line t="X" i="1745" b="6" n="3">    end do</line>
        <line t="X" i="1746" b="6" n="3"></line>
        <line t="X" i="1747" b="6" n="2">  end if</line>
        <line t="X" i="1748" b="6" n="2"></line>
        <line t="ES" i="1749" b="6" n="2">end subroutine vector_remove</line>
        <line t="ES" i="1750" b="1" n="2"></line>
        <line t="ES" i="1751" b="1" n="2"></line>
        <line t="C" i="1752" b="1" n="2">! Remove elements fulfilling condition</line>
        <line t="C" i="1753" b="1" n="2">! Removes from the container all the elements for which Predicate pred returns true.</line>
        <line t="C" i="1754" b="1" n="2">! This calls the destructor of these objects and reduces the container size by the</line>
        <line t="C" i="1755" b="1" n="2">! number of elements removed.</line>
        <line t="C" i="1756" b="1" n="2">! The function calls pred(i%get_element()) for each element (where i is an iterator</line>
        <line t="C" i="1757" b="1" n="2">! to that element). Any of the elements in the vector for which this returns true,</line>
        <line t="C" i="1758" b="1" n="2">! are removed from the container.</line>
        <line k="vector_remove_if" t="S" i="1759" b="1" n="1">subroutine vector_remove_if( this, pred )</line>
        <line t="S" i="1760" b="1" n="1"></line>
        <line t="C" i="1761" b="1" n="1">! The vector</line>
        <line t="X" i="1762" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1763" b="1" n="1"></line>
        <line t="C" i="1764" b="1" n="1">! THe predicate to use for removal selection</line>
        <line t="X" i="1765" b="1" n="1">  procedure(predicate) :: pred</line>
        <line t="X" i="1766" b="1" n="1"></line>
        <line t="C" i="1767" b="1" n="1">! Local variables</line>
        <line t="X" i="1768" b="1" n="1">  integer :: i</line>
        <line t="X" i="1769" b="1" n="1"></line>
        <line t="C" i="1770" b="1" n="1">! Check that there are elements in the vector</line>
        <line t="X" i="1771" b="2" n="2">  if( this%count &gt; 0 ) then</line>
        <line t="X" i="1772" b="2" n="2"></line>
        <line t="C" i="1773" b="2" n="2">!   Loop on the nodes</line>
        <line t="X" i="1774" b="2" n="2">    i = 1</line>
        <line t="X" i="1775" b="3" n="3">    do</line>
        <line t="X" i="1776" b="3" n="3"></line>
        <line t="C" i="1777" b="3" n="3">!     Check removal</line>
        <line t="X" i="1778" b="4" n="4">      if( pred( this%data(i)%element ) ) then</line>
        <line t="X" i="1779" b="4" n="4"></line>
        <line t="C" i="1780" b="4" n="4">!       Remove</line>
        <line t="X" i="1781" b="4" n="4">        call this%erase(i)</line>
        <line t="X" i="1782" b="5" n="4">      else</line>
        <line t="X" i="1783" b="5" n="4"></line>
        <line t="C" i="1784" b="5" n="4">!       Iterate if not removal only</line>
        <line t="X" i="1785" b="5" n="4">        i = i + 1</line>
        <line t="X" i="1786" b="5" n="4"></line>
        <line t="X" i="1787" b="5" n="3">      end if</line>
        <line t="X" i="1788" b="5" n="3"></line>
        <line t="C" i="1789" b="5" n="3">!     Checkt exit condition</line>
        <line t="X" i="1790" b="6" n="4">      if( i &gt; this%count ) exit</line>
        <line t="X" i="1791" b="6" n="4"></line>
        <line t="X" i="1792" b="6" n="3">    end do</line>
        <line t="X" i="1793" b="6" n="3"></line>
        <line t="X" i="1794" b="6" n="2">  end if</line>
        <line t="X" i="1795" b="6" n="2"></line>
        <line t="ES" i="1796" b="6" n="2">end subroutine vector_remove_if</line>
        <line t="ES" i="1797" b="1" n="2"></line>
        <line t="ES" i="1798" b="1" n="2"></line>
        <line t="C" i="1799" b="1" n="2">! Remove duplicate values</line>
        <line t="C" i="1800" b="1" n="2">! (1) removes all but the first element from every consecutive group of equal</line>
        <line t="C" i="1801" b="1" n="2">!     elements in the container.</line>
        <line t="C" i="1802" b="1" n="2">! (2) takes as argument a specific comparison function that determine the "uniqueness"</line>
        <line t="C" i="1803" b="1" n="2">!     of an element. In fact, any behavior can be implemented (and not only an equality</line>
        <line t="C" i="1804" b="1" n="2">!     comparison), but notice that the function will call binary_pred(*i,*j)) for all</line>
        <line t="C" i="1805" b="1" n="2">!     pairs of elements (where i and j are iterators to the elements) and remove j from</line>
        <line t="C" i="1806" b="1" n="2">!     the vector if the predicate returns true.</line>
        <line k="vector_unique" t="S" i="1807" b="1" n="1">subroutine vector_unique( this, bpred )</line>
        <line t="S" i="1808" b="1" n="1"></line>
        <line t="C" i="1809" b="1" n="1">! The vector to sort</line>
        <line t="X" i="1810" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1811" b="1" n="1"></line>
        <line t="C" i="1812" b="1" n="1">! The interface for the binary predicate (optional)</line>
        <line t="C" i="1813" b="1" n="1">! If the operator is not provided, then operator(==) is assumed</line>
        <line t="X" i="1814" b="1" n="1">  procedure(binary_predicate), optional :: bpred</line>
        <line t="X" i="1815" b="1" n="1"></line>
        <line t="C" i="1816" b="1" n="1">! Local variables</line>
        <line t="X" i="1817" b="1" n="1">  integer :: iout, iin</line>
        <line t="X" i="1818" b="1" n="1">  logical :: check</line>
        <line t="X" i="1819" b="1" n="1"></line>
        <line t="C" i="1820" b="1" n="1">! Outer-loop on the nodes</line>
        <line t="X" i="1821" b="1" n="1">  iout = 1</line>
        <line t="X" i="1822" b="2" n="2">  do while( iout &lt;= this%count )</line>
        <line t="X" i="1823" b="2" n="2"></line>
        <line t="C" i="1824" b="2" n="2">!   Inner-loop on the nodes</line>
        <line t="X" i="1825" b="2" n="2">    iin = iout + 1</line>
        <line t="X" i="1826" b="3" n="3">    do while( iin &lt;= this%count )</line>
        <line t="X" i="1827" b="3" n="3"></line>
        <line t="C" i="1828" b="3" n="3">!     Compare the inner and the outer elements</line>
        <line t="X" i="1829" b="4" n="4">      if( present( bpred ) ) then</line>
        <line t="X" i="1830" b="4" n="4">        check = bpred( this%data(iout)%element, this%data(iin)%element )</line>
        <line t="X" i="1831" b="5" n="4">      else</line>
        <line t="X" i="1832" b="5" n="4">        check = ( this%data(iout)%element == this%data(iin)%element )</line>
        <line t="X" i="1833" b="5" n="3">      end if</line>
        <line t="X" i="1834" b="5" n="3"></line>
        <line t="C" i="1835" b="5" n="3">!     Remove inner element if equal to outer</line>
        <line t="X" i="1836" b="6" n="4">      if( check ) then</line>
        <line t="X" i="1837" b="6" n="4">        call this%erase( iin )</line>
        <line t="X" i="1838" b="6" n="3">      end if</line>
        <line t="X" i="1839" b="6" n="3"></line>
        <line t="C" i="1840" b="6" n="3">!     Iterate inner loop</line>
        <line t="X" i="1841" b="6" n="3">      iin = iin + 1</line>
        <line t="X" i="1842" b="6" n="3"></line>
        <line t="X" i="1843" b="6" n="2">    end do</line>
        <line t="X" i="1844" b="6" n="2"></line>
        <line t="C" i="1845" b="6" n="2">!   Iterate outer loop</line>
        <line t="X" i="1846" b="6" n="2">    iout = iout + 1</line>
        <line t="X" i="1847" b="6" n="2"></line>
        <line t="X" i="1848" b="6" n="1">  end do</line>
        <line t="X" i="1849" b="6" n="1"></line>
        <line t="ES" i="1850" b="6" n="1">end subroutine vector_unique</line>
        <line t="ES" i="1851" b="1" n="1"></line>
        <line t="ES" i="1852" b="1" n="1"></line>
        <line t="C" i="1853" b="1" n="1">! Merge sorted vectors</line>
        <line t="C" i="1854" b="1" n="1">! Merges other into the vector by transferring all of its elements at their respective</line>
        <line t="C" i="1855" b="1" n="1">! ordered positions into the container (both containers shall already be ordered).</line>
        <line t="C" i="1856" b="1" n="1">! This effectively removes all the elements in other (which becomes empty), and inserts</line>
        <line t="C" i="1857" b="1" n="1">! them into their ordered position within container (which expands in size by the</line>
        <line t="C" i="1858" b="1" n="1">! number of elements transferred).</line>
        <line t="C" i="1859" b="1" n="1">! The operation is performed without constructing nor destroying any element:</line>
        <line t="C" i="1860" b="1" n="1">! they are transferred, no matter whether other is an lvalue or an rvalue, or whether</line>
        <line t="C" i="1861" b="1" n="1">! the value_type supports move-construction or not.</line>
        <line t="C" i="1862" b="1" n="1">! (1) Each element of other is inserted at the position that corresponds to its value according</line>
        <line t="C" i="1863" b="1" n="1">!     to the strict weak ordering defined by operator &lt; or comp. The resulting order of</line>
        <line t="C" i="1864" b="1" n="1">!     equivalent elements is stable (i.e., equivalent elements preserve the relative order</line>
        <line t="C" i="1865" b="1" n="1">!     they had before the call, and existing elements precede those equivalent inserted from other).</line>
        <line t="C" i="1866" b="1" n="1">! (2) Take a specific predicate (comp) to perform the comparison operation between elements.</line>
        <line t="C" i="1867" b="1" n="1">!     This comparison shall produce a strict weak ordering of the elements (i.e., a consistent</line>
        <line t="C" i="1868" b="1" n="1">!     transitive comparison, without considering its reflexiveness).</line>
        <line t="C" i="1869" b="1" n="1">! This function requires that the vector containers have their elements already ordered by</line>
        <line t="C" i="1870" b="1" n="1">! value (or by comp) before the call.</line>
        <line t="C" i="1871" b="1" n="1">! The function does nothing if (other == this).</line>
        <line k="vector_merge" t="S" i="1872" b="1" n="1">subroutine vector_merge( this, other, comp )</line>
        <line t="S" i="1873" b="1" n="1"></line>
        <line t="C" i="1874" b="1" n="1">! The vector</line>
        <line t="X" i="1875" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(inout) :: this</line>
        <line t="X" i="1876" b="1" n="1"></line>
        <line t="C" i="1877" b="1" n="1">! the vector to swap</line>
        <line t="X" i="1878" b="1" n="1">  type(xxtypebase___vector_ftl), target, intent(inout) :: other</line>
        <line t="X" i="1879" b="1" n="1"></line>
        <line t="C" i="1880" b="1" n="1">! Comparison function (optional)</line>
        <line t="X" i="1881" b="1" n="1">  procedure(comparison), optional :: comp</line>
        <line t="X" i="1882" b="1" n="1"></line>
        <line t="C" i="1883" b="1" n="1">! Local variables</line>
        <line t="X" i="1884" b="1" n="1">  integer :: iin, iout</line>
        <line t="X" i="1885" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="1886" b="1" n="1">  logical :: insert</line>
        <line t="X" i="1887" b="1" n="1"></line>
        <line t="C" i="1888" b="1" n="1">! Check if the same vector is input</line>
        <line t="C" i="1889" b="1" n="1">! Use addresses of first element to decide on same vector</line>
        <line t="X" i="1890" b="2" n="2">  if( .not. associated( this%data(1)%element, other%data(1)%element ) ) then</line>
        <line t="X" i="1891" b="2" n="2"></line>
        <line t="C" i="1892" b="2" n="2">!   Reserve size for the merge</line>
        <line t="X" i="1893" b="2" n="2">    call this%reserve( this%count + other%count )</line>
        <line t="X" i="1894" b="2" n="2">  </line>
        <line t="C" i="1895" b="2" n="2">!   Initialise the nodes in other (this is the outer loop)</line>
        <line t="X" i="1896" b="3" n="3">    outer : do iout = 1, other%count</line>
        <line t="X" i="1897" b="3" n="3"></line>
        <line t="C" i="1898" b="3" n="3">!     Initialise navigation in this vector (this is the inner loop)</line>
        <line t="C" i="1899" b="3" n="3">!     Each step of the outer loop shall start the inner loop in the last postions</line>
        <line t="C" i="1900" b="3" n="3">!     in the vector (assuming tha both vectors are ordered) not to iterate over the</line>
        <line t="C" i="1901" b="3" n="3">!     whole vector from the beginning in each iteration of the outer loop.</line>
        <line t="X" i="1902" b="4" n="4">      inner : do iin = 1, this%count</line>
        <line t="X" i="1903" b="4" n="4"></line>
        <line t="C" i="1904" b="4" n="4">!       Check if this node is the insertion point</line>
        <line t="X" i="1905" b="5" n="5">        if( present(comp) ) then</line>
        <line t="X" i="1906" b="5" n="5">          insert = comp( other%data(iout)%element, this%data(iin)%element )</line>
        <line t="X" i="1907" b="6" n="5">        else</line>
        <line t="X" i="1908" b="6" n="5">          insert = ( other%data(iout)%element &lt; this%data(iin)%element )</line>
        <line t="X" i="1909" b="6" n="4">        end if</line>
        <line t="X" i="1910" b="6" n="4"></line>
        <line t="C" i="1911" b="6" n="4">!       Check if this element must be inserted</line>
        <line t="X" i="1912" b="7" n="5">        if( insert ) then</line>
        <line t="X" i="1913" b="7" n="5"></line>
        <line t="C" i="1914" b="7" n="5">!         Insert the node</line>
        <line t="X" i="1915" b="8" n="6">          do i = this%count, iin, -1</line>
        <line t="X" i="1916" b="8" n="6">            j = i + 1</line>
        <line t="X" i="1917" b="9" n="7">            if( j &lt;= size(this%data) ) then</line>
        <line t="X" i="1918" b="9" n="7">              this%data(j)%element =&gt; this%data(i)%element</line>
        <line t="X" i="1919" b="9" n="6">            end if</line>
        <line t="X" i="1920" b="9" n="5">          end do</line>
        <line t="X" i="1921" b="9" n="5">          this%data(iin)%element =&gt; other%data(iout)%element</line>
        <line t="X" i="1922" b="9" n="5"></line>
        <line t="C" i="1923" b="9" n="5">!         Update the counter</line>
        <line t="X" i="1924" b="9" n="5">          this%count = this%count + 1</line>
        <line t="X" i="1925" b="9" n="5"></line>
        <line t="C" i="1926" b="9" n="5">!         Exit the inner loop</line>
        <line t="X" i="1927" b="9" n="5">          exit</line>
        <line t="X" i="1928" b="9" n="5"></line>
        <line t="X" i="1929" b="9" n="4">        end if</line>
        <line t="X" i="1930" b="9" n="4"></line>
        <line t="X" i="1931" b="9" n="3">      end do inner</line>
        <line t="X" i="1932" b="9" n="3"></line>
        <line t="C" i="1933" b="9" n="3">!     Check past last node</line>
        <line t="C" i="1934" b="9" n="3">!     If this point is reached with node=null this means that</line>
        <line t="C" i="1935" b="9" n="3">!     the remaining elements in other are past the end of this</line>
        <line t="X" i="1936" b="10" n="4">      if( iin &gt; this%count ) then</line>
        <line t="X" i="1937" b="10" n="4"></line>
        <line t="C" i="1938" b="10" n="4">!       Append the other node at the end of this vector</line>
        <line t="X" i="1939" b="10" n="4">        this%count = this%count + 1</line>
        <line t="X" i="1940" b="10" n="4">        this%data(this%count)%element =&gt; other%data(iout)%element</line>
        <line t="X" i="1941" b="10" n="4"></line>
        <line t="X" i="1942" b="10" n="3">      end if</line>
        <line t="X" i="1943" b="10" n="3"></line>
        <line t="X" i="1944" b="10" n="2">    end do outer</line>
        <line t="X" i="1945" b="10" n="2"></line>
        <line t="C" i="1946" b="10" n="2">!   Reset other</line>
        <line t="X" i="1947" b="10" n="2">    deallocate( other%data )</line>
        <line t="X" i="1948" b="10" n="2">    other%count = 0</line>
        <line t="X" i="1949" b="10" n="2"></line>
        <line t="X" i="1950" b="10" n="1">  end if</line>
        <line t="X" i="1951" b="10" n="1"></line>
        <line t="ES" i="1952" b="10" n="1">end subroutine vector_merge</line>
        <line t="ES" i="1953" b="1" n="1"></line>
        <line t="ES" i="1954" b="1" n="1"></line>
        <line t="C" i="1955" b="1" n="1">! Sort elements in container</line>
        <line t="C" i="1956" b="1" n="1">! Sorts the elements in the vector, altering their position within the container.</line>
        <line t="C" i="1957" b="1" n="1">! (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements</line>
        <line t="C" i="1958" b="1" n="1">! (2) The sorting is performed by applying an algorithm that uses comp to compare elements.</line>
        <line t="C" i="1959" b="1" n="1">!     This comparison shall produce a strict weak ordering of the elements (i.e., a</line>
        <line t="C" i="1960" b="1" n="1">!     consistent transitive comparison, without considering its reflexiveness).</line>
        <line t="C" i="1961" b="1" n="1">! The resulting order of equivalent elements is stable: i.e., equivalent elements</line>
        <line t="C" i="1962" b="1" n="1">! preserve the relative order they had before the call.</line>
        <line t="C" i="1963" b="1" n="1">! The entire operation does not involve the construction, destruction or copy of any element</line>
        <line t="C" i="1964" b="1" n="1">! object. Elements are moved within the container.</line>
        <line k="vector_sort" t="S" i="1965" b="1" n="1">subroutine vector_sort( this, compare )</line>
        <line t="S" i="1966" b="1" n="1"></line>
        <line t="C" i="1967" b="1" n="1">! the vector to sort</line>
        <line t="X" i="1968" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1969" b="1" n="1"></line>
        <line t="C" i="1970" b="1" n="1">! The interface for the comparison operator (optional)</line>
        <line t="C" i="1971" b="1" n="1">! If the operator is not provided, then operator(&lt;) is assumed</line>
        <line t="X" i="1972" b="1" n="1">  procedure(comparison), optional :: compare</line>
        <line t="X" i="1973" b="1" n="1"></line>
        <line t="C" i="1974" b="1" n="1">! Call the sorting routine</line>
        <line t="X" i="1975" b="1" n="1">  call this%quick_sort( 1, this%count, compare )</line>
        <line t="X" i="1976" b="1" n="1"></line>
        <line t="ES" i="1977" b="1" n="1">end subroutine vector_sort</line>
        <line t="ES" i="1978" b="1" n="1"></line>
        <line t="ES" i="1979" b="1" n="1"></line>
        <line t="C" i="1980" b="1" n="1">! Sorting subroutine (Quick-sort method) algorithm kernel</line>
        <line k="quick_sort" t="S" i="1981" b="1" n="1">recursive subroutine quick_sort( this, left, right, compare )</line>
        <line t="S" i="1982" b="1" n="1"></line>
        <line t="C" i="1983" b="1" n="1">! Array of indices</line>
        <line t="X" i="1984" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="1985" b="1" n="1"></line>
        <line t="C" i="1986" b="1" n="1">! Quick-sort partition left index</line>
        <line t="X" i="1987" b="1" n="1">  integer, intent(in) :: left</line>
        <line t="X" i="1988" b="1" n="1"></line>
        <line t="C" i="1989" b="1" n="1">! Quick-sort partition right index</line>
        <line t="X" i="1990" b="1" n="1">  integer, intent(in) :: right</line>
        <line t="X" i="1991" b="1" n="1"></line>
        <line t="C" i="1992" b="1" n="1">! The interface for the comparison operator (optional)</line>
        <line t="C" i="1993" b="1" n="1">! If the operator is not provided, then operator(&lt;) is assumed</line>
        <line t="X" i="1994" b="1" n="1">  procedure(comparison), optional :: compare</line>
        <line t="X" i="1995" b="1" n="1"></line>
        <line t="C" i="1996" b="1" n="1">! Counters</line>
        <line t="X" i="1997" b="1" n="1">  integer :: i, last</line>
        <line t="X" i="1998" b="1" n="1"></line>
        <line t="C" i="1999" b="1" n="1">! The result of the element comparison</line>
        <line t="X" i="2000" b="1" n="1">  logical :: sortby</line>
        <line t="X" i="2001" b="1" n="1"></line>
        <line t="C" i="2002" b="1" n="1">! Return if array contains fewer than 2 elements</line>
        <line t="X" i="2003" b="2" n="2">  if( left &lt; right ) then</line>
        <line t="X" i="2004" b="2" n="2"></line>
        <line t="C" i="2005" b="2" n="2">!   Move partition element to the beginning of the array</line>
        <line t="X" i="2006" b="2" n="2">    call this%swap( left, ( left + right ) / 2 )</line>
        <line t="X" i="2007" b="2" n="2">    last = left</line>
        <line t="X" i="2008" b="2" n="2"></line>
        <line t="C" i="2009" b="2" n="2">!   Partition</line>
        <line t="X" i="2010" b="3" n="3">    do i = left + 1, right</line>
        <line t="X" i="2011" b="3" n="3"></line>
        <line t="C" i="2012" b="3" n="3">!     Check element</line>
        <line t="X" i="2013" b="4" n="4">      if( present( compare ) ) then</line>
        <line t="X" i="2014" b="4" n="4">        sortby = compare( this%data(left)%element, &amp;</line>
        <line t="X" i="2015" b="4" n="4">                          this%data(i)%element )</line>
        <line t="X" i="2016" b="5" n="4">      else</line>
        <line t="X" i="2017" b="5" n="4">        sortby = ( this%data(left)%element &lt; this%data(i)%element )</line>
        <line t="X" i="2018" b="5" n="3">      end if</line>
        <line t="X" i="2019" b="5" n="3"></line>
        <line t="C" i="2020" b="5" n="3">!     Swap elements</line>
        <line t="X" i="2021" b="6" n="4">      if( .not. sortby ) then</line>
        <line t="X" i="2022" b="6" n="4">        last = last + 1</line>
        <line t="X" i="2023" b="6" n="4">        call  this%swap( last, i )</line>
        <line t="X" i="2024" b="6" n="3">      end if</line>
        <line t="X" i="2025" b="6" n="3"></line>
        <line t="X" i="2026" b="6" n="2">    end do</line>
        <line t="X" i="2027" b="6" n="2"></line>
        <line t="C" i="2028" b="6" n="2">!   Restore partition element</line>
        <line t="X" i="2029" b="6" n="2">    call this%swap( left, last )</line>
        <line t="X" i="2030" b="6" n="2">    call this%quick_sort( left, last - 1, compare )</line>
        <line t="X" i="2031" b="6" n="2">    call this%quick_sort( last + 1, right, compare )</line>
        <line t="X" i="2032" b="6" n="2"></line>
        <line t="X" i="2033" b="6" n="1">  end if</line>
        <line t="X" i="2034" b="6" n="1"></line>
        <line t="ES" i="2035" b="6" n="1">end subroutine quick_sort</line>
        <line t="ES" i="2036" b="1" n="1"></line>
        <line t="ES" i="2037" b="1" n="1"></line>
        <line t="C" i="2038" b="1" n="1">! Swap two elements in a vector  from their indexes</line>
        <line k="vector_swap_index" t="S" i="2039" b="1" n="1">pure subroutine vector_swap_index( this, index1, index2 )</line>
        <line t="S" i="2040" b="1" n="1"></line>
        <line t="C" i="2041" b="1" n="1">! The vector to have the elementes swapped</line>
        <line t="X" i="2042" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="2043" b="1" n="1"></line>
        <line t="C" i="2044" b="1" n="1">! Index to first element</line>
        <line t="X" i="2045" b="1" n="1">  integer, intent(in) :: index1</line>
        <line t="X" i="2046" b="1" n="1"></line>
        <line t="C" i="2047" b="1" n="1">! Index to second element</line>
        <line t="X" i="2048" b="1" n="1">  integer, intent(in) :: index2</line>
        <line t="X" i="2049" b="1" n="1"></line>
        <line t="C" i="2050" b="1" n="1">! Local pointer</line>
        <line t="X" i="2051" b="1" n="1">  class(xxtypebase__), pointer :: tmp_ptr</line>
        <line t="X" i="2052" b="1" n="1"></line>
        <line t="C" i="2053" b="1" n="1">! Swap elements; swap pointers, not memory</line>
        <line t="X" i="2054" b="1" n="1">  tmp_ptr =&gt; this%data(index1)%element</line>
        <line t="X" i="2055" b="1" n="1">  this%data(index1)%element =&gt; this%data(index2)%element</line>
        <line t="X" i="2056" b="1" n="1">  this%data(index2)%element =&gt; tmp_ptr</line>
        <line t="X" i="2057" b="1" n="1"></line>
        <line t="ES" i="2058" b="1" n="1">end subroutine vector_swap_index</line>
        <line t="ES" i="2059" b="1" n="1"></line>
        <line t="ES" i="2060" b="1" n="1"></line>
        <line t="C" i="2061" b="1" n="1">! Swap two nodes in a vector pointed by iterators</line>
        <line k="vector_iterator_swap_iterators" t="S" i="2062" b="1" n="1">pure subroutine vector_iterator_swap_iterators( iter1, iter2 )</line>
        <line t="S" i="2063" b="1" n="1"></line>
        <line t="C" i="2064" b="1" n="1">! Iterator to first element</line>
        <line t="X" i="2065" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(inout) :: iter1</line>
        <line t="X" i="2066" b="1" n="1"></line>
        <line t="C" i="2067" b="1" n="1">! Iterator to second element</line>
        <line t="X" i="2068" b="1" n="1">  type(xxtypebase___vector_ftl_iterator), intent(inout) :: iter2</line>
        <line t="X" i="2069" b="1" n="1"></line>
        <line t="X" i="2070" b="1" n="1"></line>
        <line t="C" i="2071" b="1" n="1">! Swap the element by their indexes</line>
        <line t="X" i="2072" b="1" n="1">  call iter1%parent%swap( iter1%idx, iter2%idx )</line>
        <line t="X" i="2073" b="1" n="1"></line>
        <line t="ES" i="2074" b="1" n="1">end subroutine vector_iterator_swap_iterators</line>
        <line t="ES" i="2075" b="1" n="1"></line>
        <line t="ES" i="2076" b="1" n="1"></line>
        <line t="C" i="2077" b="1" n="1">! Reverse the order of elements in a vector</line>
        <line k="vector_reverse" t="S" i="2078" b="1" n="1">pure subroutine vector_reverse( this )</line>
        <line t="S" i="2079" b="1" n="1"></line>
        <line t="C" i="2080" b="1" n="1">! The vector to reverse</line>
        <line t="X" i="2081" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="2082" b="1" n="1"></line>
        <line t="C" i="2083" b="1" n="1">! Intermediate indexes</line>
        <line t="X" i="2084" b="1" n="1">  integer :: lidx, ridx</line>
        <line t="X" i="2085" b="1" n="1"></line>
        <line t="C" i="2086" b="1" n="1">! Loop simultaneously from left to right and from right to left</line>
        <line t="X" i="2087" b="1" n="1">  lidx = 1</line>
        <line t="X" i="2088" b="1" n="1">  ridx = this%count</line>
        <line t="X" i="2089" b="1" n="1"></line>
        <line t="C" i="2090" b="1" n="1">! Loop until both indexes are identical (odd number of elements)</line>
        <line t="C" i="2091" b="1" n="1">! or until the two indexes cross (even number of elements)</line>
        <line t="X" i="2092" b="2" n="2">  do</line>
        <line t="X" i="2093" b="2" n="2"></line>
        <line t="C" i="2094" b="2" n="2">!   Check indexes</line>
        <line t="X" i="2095" b="3" n="3">    if( ridx &lt;= lidx ) exit</line>
        <line t="X" i="2096" b="3" n="3"></line>
        <line t="C" i="2097" b="3" n="3">!   Swapt elements</line>
        <line t="X" i="2098" b="3" n="3">    call this%swap( lidx, ridx )</line>
        <line t="X" i="2099" b="3" n="3"></line>
        <line t="C" i="2100" b="3" n="3">!   Iterate</line>
        <line t="X" i="2101" b="3" n="3">    ridx = ridx - 1</line>
        <line t="X" i="2102" b="3" n="3">    lidx = lidx + 1</line>
        <line t="X" i="2103" b="3" n="3"></line>
        <line t="X" i="2104" b="3" n="2">  end do</line>
        <line t="X" i="2105" b="3" n="2"></line>
        <line t="ES" i="2106" b="3" n="2">end subroutine vector_reverse</line>
        <line t="ES" i="2107" b="1" n="2"></line>
        <line t="ES" i="2108" b="1" n="2"></line>
        <line t="C" i="2109" b="1" n="2">! Binary search subroutine (assumes ascending sorted  vector) front-end</line>
        <line k="vector_binary_search" t="F" i="2110" b="1" n="1">function vector_binary_search( this, item, isless, isgreater ) result(res)</line>
        <line t="F" i="2111" b="1" n="1"></line>
        <line t="C" i="2112" b="1" n="1">! The vector to search</line>
        <line t="X" i="2113" b="1" n="1">  class(xxtypebase___vector_ftl), target, intent(in) :: this</line>
        <line t="X" i="2114" b="1" n="1"></line>
        <line t="C" i="2115" b="1" n="1">! The element to look for</line>
        <line t="X" i="2116" b="1" n="1">  class(xxtypebase__), intent(in) :: item</line>
        <line t="X" i="2117" b="1" n="1"></line>
        <line t="C" i="2118" b="1" n="1">! The iterator to the vector element (not associated if not found)</line>
        <line t="X" i="2119" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="2120" b="1" n="1"></line>
        <line t="C" i="2121" b="1" n="1">! If the operator is not provided, then operator(&lt;) is assumed</line>
        <line t="X" i="2122" b="1" n="1">  procedure(comparison), optional :: isless</line>
        <line t="X" i="2123" b="1" n="1"></line>
        <line t="C" i="2124" b="1" n="1">! If the operator is not provided, then operator(&gt;) is assumed</line>
        <line t="X" i="2125" b="1" n="1">  procedure(comparison), optional :: isgreater</line>
        <line t="X" i="2126" b="1" n="1"></line>
        <line t="C" i="2127" b="1" n="1">! Call the sorting routine</line>
        <line t="X" i="2128" b="1" n="1">  res%idx = recursive_binary_search( this, 1, this%count, item, isless, isgreater )</line>
        <line t="X" i="2129" b="1" n="1"></line>
        <line t="C" i="2130" b="1" n="1">! Set pointer to parent container</line>
        <line t="X" i="2131" b="1" n="1">  res%parent =&gt; this</line>
        <line t="X" i="2132" b="1" n="1"></line>
        <line t="EF" i="2133" b="1" n="1">end function vector_binary_search</line>
        <line t="EF" i="2134" b="1" n="1"></line>
        <line t="EF" i="2135" b="1" n="1"></line>
        <line t="C" i="2136" b="1" n="1">! Binary search subroutine (assumes ascending sorted vector) algorithm kernel</line>
        <line k="recursive_binary_search" t="F" i="2137" b="1" n="1">recursive function recursive_binary_search( this, left, right, item, isless, isgreater ) result(res)</line>
        <line t="F" i="2138" b="1" n="1"></line>
        <line t="C" i="2139" b="1" n="1">! The vector to search</line>
        <line t="X" i="2140" b="1" n="1">  type(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="2141" b="1" n="1"></line>
        <line t="C" i="2142" b="1" n="1">! Quick-sort partition left position</line>
        <line t="X" i="2143" b="1" n="1">  integer, intent(in) :: left</line>
        <line t="X" i="2144" b="1" n="1"></line>
        <line t="C" i="2145" b="1" n="1">! Quick-sort partition right position</line>
        <line t="X" i="2146" b="1" n="1">  integer, intent(in) :: right</line>
        <line t="X" i="2147" b="1" n="1"></line>
        <line t="C" i="2148" b="1" n="1">! The element to look for</line>
        <line t="X" i="2149" b="1" n="1">  class(xxtypebase__), intent(in) :: item</line>
        <line t="X" i="2150" b="1" n="1"></line>
        <line t="C" i="2151" b="1" n="1">! If the operator is not provided, then operator(&lt;) is assumed</line>
        <line t="X" i="2152" b="1" n="1">  procedure(comparison), optional :: isless</line>
        <line t="X" i="2153" b="1" n="1"></line>
        <line t="C" i="2154" b="1" n="1">! If the operator is not provided, then operator(&gt;) is assumed</line>
        <line t="X" i="2155" b="1" n="1">  procedure(comparison), optional :: isgreater</line>
        <line t="X" i="2156" b="1" n="1"></line>
        <line t="C" i="2157" b="1" n="1">! The index to the vector element (0 if not found)</line>
        <line t="X" i="2158" b="1" n="1">  integer :: res</line>
        <line t="X" i="2159" b="1" n="1"></line>
        <line t="C" i="2160" b="1" n="1">! The result of the element comparison</line>
        <line t="X" i="2161" b="1" n="1">  logical :: check</line>
        <line t="X" i="2162" b="1" n="1"></line>
        <line t="C" i="2163" b="1" n="1">! Local pointers</line>
        <line t="X" i="2164" b="1" n="1">  integer :: mid</line>
        <line t="X" i="2165" b="1" n="1">  class(xxtypebase__), pointer :: ref</line>
        <line t="X" i="2166" b="1" n="1"></line>
        <line t="C" i="2167" b="1" n="1">! Check if still elements to search</line>
        <line t="X" i="2168" b="2" n="2">  if( right &lt; left ) then</line>
        <line t="X" i="2169" b="2" n="2"></line>
        <line t="C" i="2170" b="2" n="2">!   Not found</line>
        <line t="X" i="2171" b="2" n="2">    res = 0</line>
        <line t="X" i="2172" b="2" n="2"></line>
        <line t="X" i="2173" b="3" n="2">  else</line>
        <line t="X" i="2174" b="3" n="2"></line>
        <line t="C" i="2175" b="3" n="2">!   Compute next partition point</line>
        <line t="X" i="2176" b="3" n="2">    mid = ( left + right ) / 2</line>
        <line t="X" i="2177" b="3" n="2">    ref =&gt; this%data(mid)%element</line>
        <line t="X" i="2178" b="3" n="2"></line>
        <line t="C" i="2179" b="3" n="2">!   Check element</line>
        <line t="X" i="2180" b="4" n="3">    if( present( isless ) ) then</line>
        <line t="X" i="2181" b="4" n="3">      check = isless( item, ref )</line>
        <line t="X" i="2182" b="5" n="3">    else</line>
        <line t="X" i="2183" b="5" n="3">      check = ( item &lt; ref )</line>
        <line t="X" i="2184" b="5" n="2">    end if</line>
        <line t="X" i="2185" b="6" n="3">    if( check ) then</line>
        <line t="X" i="2186" b="6" n="3"></line>
        <line t="C" i="2187" b="6" n="3">!     Invoke search for lower partition</line>
        <line t="X" i="2188" b="6" n="3">      res = recursive_binary_search( this, left, mid-1, item, isless, isgreater )</line>
        <line t="X" i="2189" b="6" n="3"></line>
        <line t="X" i="2190" b="7" n="3">    else</line>
        <line t="X" i="2191" b="7" n="3"></line>
        <line t="C" i="2192" b="7" n="3">!     Check element</line>
        <line t="X" i="2193" b="8" n="4">      if( present( isgreater ) ) then</line>
        <line t="X" i="2194" b="8" n="4">        check = isgreater( item, ref )</line>
        <line t="X" i="2195" b="9" n="4">      else</line>
        <line t="X" i="2196" b="9" n="4">        check = ( item &gt; ref )</line>
        <line t="X" i="2197" b="9" n="3">      end if</line>
        <line t="X" i="2198" b="10" n="4">      if( check ) then</line>
        <line t="X" i="2199" b="10" n="4"></line>
        <line t="C" i="2200" b="10" n="4">!       Invoke search for upper partition</line>
        <line t="X" i="2201" b="10" n="4">        res = recursive_binary_search( this, mid+1, right, item, isless, isgreater )</line>
        <line t="X" i="2202" b="10" n="4"></line>
        <line t="X" i="2203" b="11" n="4">      else</line>
        <line t="X" i="2204" b="11" n="4"></line>
        <line t="C" i="2205" b="11" n="4">!       Element found</line>
        <line t="X" i="2206" b="11" n="4">        res = mid</line>
        <line t="X" i="2207" b="11" n="4"></line>
        <line t="X" i="2208" b="11" n="3">      end if</line>
        <line t="X" i="2209" b="11" n="3"></line>
        <line t="X" i="2210" b="11" n="2">    end if</line>
        <line t="X" i="2211" b="11" n="2"></line>
        <line t="X" i="2212" b="11" n="1">  end if</line>
        <line t="X" i="2213" b="11" n="1"></line>
        <line t="EF" i="2214" b="11" n="1">end function recursive_binary_search</line>
        <line t="EF" i="2215" b="1" n="1"></line>
        <line t="EF" i="2216" b="1" n="1"></line>
        <line t="C" i="2217" b="1" n="1">! Search a vector following certain criteria</line>
        <line k="vector_select" t="F" i="2218" b="1" n="1">function vector_select( this, reference, bpred ) result(res)</line>
        <line t="F" i="2219" b="1" n="1"></line>
        <line t="C" i="2220" b="1" n="1">! The vector to search selecting items</line>
        <line t="X" i="2221" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="2222" b="1" n="1"></line>
        <line t="C" i="2223" b="1" n="1">! The reference element to use as selecting pattern</line>
        <line t="X" i="2224" b="1" n="1">  class(xxtypebase__), intent(in) :: reference</line>
        <line t="X" i="2225" b="1" n="1"></line>
        <line t="C" i="2226" b="1" n="1">! The interface for the comparison operator</line>
        <line t="X" i="2227" b="1" n="1">  procedure(binary_predicate), optional :: bpred</line>
        <line t="X" i="2228" b="1" n="1"></line>
        <line t="C" i="2229" b="1" n="1">! The output vector contatining the selectec elements</line>
        <line t="X" i="2230" b="1" n="1">  type(xxtypebase___vector_ftl) :: res</line>
        <line t="X" i="2231" b="1" n="1"></line>
        <line t="C" i="2232" b="1" n="1">! Counter</line>
        <line t="X" i="2233" b="1" n="1">  integer :: i</line>
        <line t="X" i="2234" b="1" n="1"></line>
        <line t="C" i="2235" b="1" n="1">! Local variables</line>
        <line t="X" i="2236" b="1" n="1">  logical :: flag</line>
        <line t="X" i="2237" b="1" n="1"></line>
        <line t="X" i="2238" b="1" n="1"></line>
        <line t="C" i="2239" b="1" n="1">! Loop on the vector elements</line>
        <line t="X" i="2240" b="2" n="2">  do i = 1, this%count</line>
        <line t="X" i="2241" b="2" n="2"></line>
        <line t="C" i="2242" b="2" n="2">!   Decide whether element matches the criterion</line>
        <line t="X" i="2243" b="3" n="3">    if( present(bpred) ) then</line>
        <line t="X" i="2244" b="3" n="3">      flag = bpred( this%data(i)%element, reference )</line>
        <line t="X" i="2245" b="4" n="3">    else</line>
        <line t="X" i="2246" b="4" n="3">      flag = ( this%data(i)%element == reference )</line>
        <line t="X" i="2247" b="4" n="2">    end if</line>
        <line t="X" i="2248" b="5" n="3">    if( flag ) then</line>
        <line t="X" i="2249" b="5" n="3">      call res%push_back( this%data(i)%element )</line>
        <line t="X" i="2250" b="5" n="2">    end if</line>
        <line t="X" i="2251" b="5" n="2"></line>
        <line t="X" i="2252" b="5" n="1">  end do</line>
        <line t="X" i="2253" b="5" n="1"></line>
        <line t="EF" i="2254" b="5" n="1">end function vector_select</line>
        <line t="EF" i="2255" b="1" n="1"></line>
        <line t="EF" i="2256" b="1" n="1"></line>
        <line t="C" i="2257" b="1" n="1">! Create an array (allocatabe) of elements from a vector</line>
        <line k="vector_array" t="F" i="2258" b="1" n="1">function vector_array( this ) result(res)</line>
        <line t="F" i="2259" b="1" n="1"></line>
        <line t="C" i="2260" b="1" n="1">! The input vector</line>
        <line t="X" i="2261" b="1" n="1">  class(xxtypebase___vector_ftl), intent(in) :: this</line>
        <line t="X" i="2262" b="1" n="1"></line>
        <line t="C" i="2263" b="1" n="1">! The returned array of elements (unallocated if memory failure)</line>
        <line t="X" i="2264" b="1" n="1">  class(xxtypebase__), allocatable, dimension(:) :: res</line>
        <line t="X" i="2265" b="1" n="1"></line>
        <line t="C" i="2266" b="1" n="1">! Memory allocation status</line>
        <line t="X" i="2267" b="1" n="1">  integer :: status</line>
        <line t="X" i="2268" b="1" n="1"></line>
        <line t="C" i="2269" b="1" n="1">! Local counter</line>
        <line t="X" i="2270" b="1" n="1">  integer :: i</line>
        <line t="X" i="2271" b="1" n="1"></line>
        <line t="C" i="2272" b="1" n="1">! Allocate memory for returned array</line>
        <line t="X" i="2273" b="1" n="1">  allocate( res( this%count ), mold=this%data(1)%element, stat=status )</line>
        <line t="X" i="2274" b="2" n="2">  if( status == 0 ) then</line>
        <line t="X" i="2275" b="2" n="2"></line>
        <line t="C" i="2276" b="2" n="2">!   Copy vector elements</line>
        <line t="X" i="2277" b="3" n="3">    do i = 1, this%count</line>
        <line t="X" i="2278" b="3" n="3">      res(i) = this%data(i)%element</line>
        <line t="X" i="2279" b="3" n="2">    end do</line>
        <line t="X" i="2280" b="3" n="2"></line>
        <line t="X" i="2281" b="3" n="1">  end if</line>
        <line t="X" i="2282" b="3" n="1"></line>
        <line t="EF" i="2283" b="3" n="1">end function vector_array</line>
        <line t="EF" i="2284" b="1" n="1"></line>
        <line t="EF" i="2285" b="1" n="1"></line>
        <line t="C" i="2286" b="1" n="1">! Implement the assignment between two elements (contained in the container node)</line>
        <line t="C" i="2287" b="1" n="1">! Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess)</line>
        <line t="C" i="2288" b="1" n="1">! at the time thta allows the invocation of assignment operators in the cases when the element implements it</line>
        <line k="element_assign_pointer" t="S" i="2289" b="1" n="1">pure subroutine element_assign_pointer( left, right )</line>
        <line t="S" i="2290" b="1" n="1"></line>
        <line t="C" i="2291" b="1" n="1">! Element to be allocated and assigned (pointer interface)</line>
        <line t="X" i="2292" b="1" n="1">  class(xxtypebase__), pointer, intent(inout) :: left</line>
        <line t="X" i="2293" b="1" n="1"></line>
        <line t="C" i="2294" b="1" n="1">! Source element</line>
        <line t="X" i="2295" b="1" n="1">  class(xxtypebase__), intent(in) :: right</line>
        <line t="X" i="2296" b="1" n="1"></line>
        <line t="C" i="2297" b="1" n="1">! Allocate first. Use mold to allow polymorphic object storage through parent class</line>
        <line t="X" i="2298" b="1" n="1">  allocate( left, mold=right )</line>
        <line t="X" i="2299" b="1" n="1"></line>
        <line t="C" i="2300" b="1" n="1">! Assign explicitly to allow invoking the assignment operator if implemented in the element</line>
        <line t="X" i="2301" b="1" n="1">  left = right</line>
        <line t="X" i="2302" b="1" n="1"></line>
        <line t="ES" i="2303" b="1" n="1">end subroutine element_assign_pointer</line>
        <line t="ES" i="2304" b="1" n="1"></line>
        <line t="ES" i="2305" b="1" n="1"></line>
        <line t="C" i="2306" b="1" n="1">! Implement the assignment between two elements (contained in the container node)</line>
        <line t="C" i="2307" b="1" n="1">! Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess)</line>
        <line t="C" i="2308" b="1" n="1">! at the time thta allows the invocation of assignment operators in the cases when the element implements it</line>
        <line k="element_assign_allocatable" t="S" i="2309" b="1" n="1">pure subroutine element_assign_allocatable( left, right )</line>
        <line t="S" i="2310" b="1" n="1"></line>
        <line t="C" i="2311" b="1" n="1">! Element to be allocated and assigned (allocatable interface)</line>
        <line t="X" i="2312" b="1" n="1">  class(xxtypebase__), allocatable, intent(inout) :: left</line>
        <line t="X" i="2313" b="1" n="1"></line>
        <line t="C" i="2314" b="1" n="1">! Source element</line>
        <line t="X" i="2315" b="1" n="1">  class(xxtypebase__), intent(in) :: right</line>
        <line t="X" i="2316" b="1" n="1"></line>
        <line t="C" i="2317" b="1" n="1">! Allocate first. Use mold to allow polymorphic object storage through parent class</line>
        <line t="X" i="2318" b="1" n="1">  allocate( left, mold=right )</line>
        <line t="X" i="2319" b="1" n="1"></line>
        <line t="C" i="2320" b="1" n="1">! Assign explicitly to allow invoking the assignment operator if implemented in the element</line>
        <line t="X" i="2321" b="1" n="1">  left = right</line>
        <line t="X" i="2322" b="1" n="1"></line>
        <line t="ES" i="2323" b="1" n="1">end subroutine element_assign_allocatable</line>
        <line t="ES" i="2324" b="1" n="1"></line>
        <line t="ES" i="2325" b="1" n="1"></line>
        <line t="ES" i="2326" b="1" n="1"></line>
        <line t="ES" i="2327" b="1" n="1"></line>
        <line t="ES" i="2328" b="1" n="1"></line>
        <line t="ES" i="2329" b="1" n="1"></line>
        <line t="ES" i="2330" b="1" n="1"></line>
        <line t="ES" i="2331" b="1" n="1"></line>
        <line t="ES" i="2332" b="1" n="1"></line>
        <line t="ES" i="2333" b="1" n="1"></line>
        <line t="ES" i="2334" b="1" n="1"></line>
        <line t="C" i="2335" b="1" n="1">! Return iterator to next node in the vector</line>
        <line k="vector_iterator_next" t="F" i="2336" b="1" n="1">function vector_iterator_next( this ) result(res)</line>
        <line t="F" i="2337" b="1" n="1"></line>
        <line t="C" i="2338" b="1" n="1">! the vector iterator</line>
        <line t="X" i="2339" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="2340" b="1" n="1"></line>
        <line t="C" i="2341" b="1" n="1">! Pointer to next node in the vector</line>
        <line t="X" i="2342" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="2343" b="1" n="1"></line>
        <line t="C" i="2344" b="1" n="1">! Assign index</line>
        <line t="X" i="2345" b="2" n="2">  if( this%idx &gt;= this%parent%count ) then</line>
        <line t="X" i="2346" b="2" n="2">    res%idx = 0</line>
        <line t="X" i="2347" b="3" n="2">  else</line>
        <line t="X" i="2348" b="3" n="2">    res%idx = this%idx + 1</line>
        <line t="X" i="2349" b="3" n="1">  end if</line>
        <line t="X" i="2350" b="3" n="1"></line>
        <line t="C" i="2351" b="3" n="1">! Assign container vector pointer</line>
        <line t="X" i="2352" b="3" n="1">  res%parent =&gt; this%parent</line>
        <line t="X" i="2353" b="3" n="1"></line>
        <line t="EF" i="2354" b="3" n="1">end function vector_iterator_next</line>
        <line t="EF" i="2355" b="1" n="1"></line>
        <line t="EF" i="2356" b="1" n="1"></line>
        <line t="C" i="2357" b="1" n="1">! Return iterator to previous node in the vector</line>
        <line k="vector_iterator_previous" t="F" i="2358" b="1" n="1">function vector_iterator_previous( this ) result(res)</line>
        <line t="F" i="2359" b="1" n="1"></line>
        <line t="C" i="2360" b="1" n="1">! the vector iterator</line>
        <line t="X" i="2361" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="2362" b="1" n="1"></line>
        <line t="C" i="2363" b="1" n="1">! The previous node in the vector</line>
        <line t="X" i="2364" b="1" n="1">  type(xxtypebase___vector_ftl_iterator) :: res</line>
        <line t="X" i="2365" b="1" n="1"></line>
        <line t="X" i="2366" b="1" n="1"></line>
        <line t="C" i="2367" b="1" n="1">! Assign index</line>
        <line t="X" i="2368" b="2" n="2">  if( this%idx &lt;= 1 ) then</line>
        <line t="X" i="2369" b="2" n="2">    res%idx = 0</line>
        <line t="X" i="2370" b="3" n="2">  else</line>
        <line t="X" i="2371" b="3" n="2">    res%idx = this%idx - 1</line>
        <line t="X" i="2372" b="3" n="1">  end if</line>
        <line t="X" i="2373" b="3" n="1"></line>
        <line t="C" i="2374" b="3" n="1">! Assign container vector pointer</line>
        <line t="X" i="2375" b="3" n="1">  res%parent =&gt; this%parent</line>
        <line t="X" i="2376" b="3" n="1"></line>
        <line t="EF" i="2377" b="3" n="1">end function vector_iterator_previous</line>
        <line t="EF" i="2378" b="1" n="1"></line>
        <line t="EF" i="2379" b="1" n="1"></line>
        <line t="C" i="2380" b="1" n="1">! Return the vector index in an iterator</line>
        <line k="vector_iterator_index" t="F" i="2381" b="1" n="1">pure function vector_iterator_index( iterator ) result(res)</line>
        <line t="F" i="2382" b="1" n="1"></line>
        <line t="C" i="2383" b="1" n="1">! The vector iterator</line>
        <line t="X" i="2384" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="2385" b="1" n="1"></line>
        <line t="C" i="2386" b="1" n="1">! The vector index</line>
        <line t="X" i="2387" b="1" n="1">  integer :: res</line>
        <line t="X" i="2388" b="1" n="1"></line>
        <line t="C" i="2389" b="1" n="1">! Return the vector index</line>
        <line t="X" i="2390" b="1" n="1">  res = iterator%idx</line>
        <line t="X" i="2391" b="1" n="1"></line>
        <line t="EF" i="2392" b="1" n="1">end function vector_iterator_index</line>
        <line t="EF" i="2393" b="1" n="1"></line>
        <line t="EF" i="2394" b="1" n="1"></line>
        <line t="C" i="2395" b="1" n="1">! Return the distance (number of elements) between two nodes (by iterator)</line>
        <line k="vector_iterator_distance" t="F" i="2396" b="1" n="1">function vector_iterator_distance( origin, target ) result(res)</line>
        <line t="F" i="2397" b="1" n="1"></line>
        <line t="C" i="2398" b="1" n="1">! The first node</line>
        <line t="X" i="2399" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: origin</line>
        <line t="X" i="2400" b="1" n="1"></line>
        <line t="C" i="2401" b="1" n="1">! The final node</line>
        <line t="X" i="2402" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: target</line>
        <line t="X" i="2403" b="1" n="1"></line>
        <line t="C" i="2404" b="1" n="1">! The number of elements between the iterators</line>
        <line t="X" i="2405" b="1" n="1">  integer :: res</line>
        <line t="X" i="2406" b="1" n="1"></line>
        <line t="C" i="2407" b="1" n="1">! Check end node asscoiation</line>
        <line t="C" i="2408" b="1" n="1">! Return -1 if target lees that origin</line>
        <line t="X" i="2409" b="2" n="2">  if( origin%idx &gt; target%idx ) then</line>
        <line t="X" i="2410" b="2" n="2">    res = -1</line>
        <line t="X" i="2411" b="3" n="2">  else</line>
        <line t="X" i="2412" b="3" n="2">    res = target%idx - origin%idx</line>
        <line t="X" i="2413" b="3" n="1">  end if</line>
        <line t="X" i="2414" b="3" n="1"></line>
        <line t="EF" i="2415" b="3" n="1">end function vector_iterator_distance</line>
        <line t="EF" i="2416" b="1" n="1"></line>
        <line t="EF" i="2417" b="1" n="1"></line>
        <line t="C" i="2418" b="1" n="1">! Return the association status of an iterator</line>
        <line k="vector_iterator_associated" t="F" i="2419" b="1" n="1">pure function vector_iterator_associated( this ) result(res)</line>
        <line t="F" i="2420" b="1" n="1"></line>
        <line t="C" i="2421" b="1" n="1">! The vector iterator</line>
        <line t="X" i="2422" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="2423" b="1" n="1"></line>
        <line t="C" i="2424" b="1" n="1">! The association status</line>
        <line t="X" i="2425" b="1" n="1">  logical :: res</line>
        <line t="X" i="2426" b="1" n="1"></line>
        <line t="C" i="2427" b="1" n="1">! Return the association status</line>
        <line t="X" i="2428" b="1" n="1">  res = ( this%idx &gt; 0 )</line>
        <line t="X" i="2429" b="1" n="1"></line>
        <line t="EF" i="2430" b="1" n="1">end function vector_iterator_associated</line>
        <line t="EF" i="2431" b="1" n="1"></line>
        <line t="EF" i="2432" b="1" n="1"></line>
        <line t="C" i="2433" b="1" n="1">! Nullify an iterator</line>
        <line k="vector_iterator_nullify" t="S" i="2434" b="1" n="1">pure subroutine vector_iterator_nullify( this )</line>
        <line t="S" i="2435" b="1" n="1"></line>
        <line t="C" i="2436" b="1" n="1">! The vector iterator</line>
        <line t="X" i="2437" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(inout) :: this</line>
        <line t="X" i="2438" b="1" n="1"></line>
        <line t="C" i="2439" b="1" n="1">! Nullify pointer</line>
        <line t="X" i="2440" b="1" n="1">  this%idx = 0</line>
        <line t="X" i="2441" b="1" n="1"></line>
        <line t="ES" i="2442" b="1" n="1">end subroutine vector_iterator_nullify</line>
        <line t="ES" i="2443" b="1" n="1"></line>
        <line t="ES" i="2444" b="1" n="1"></line>
        <line t="C" i="2445" b="1" n="1">! Get an elememnt in the node pointed by the iterator</line>
        <line k="vector_iterator_get_element" t="F" i="2446" b="1" n="1">pure function vector_iterator_get_element( this ) result(res)</line>
        <line t="F" i="2447" b="1" n="1"></line>
        <line t="C" i="2448" b="1" n="1">! The iterator</line>
        <line t="X" i="2449" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="2450" b="1" n="1"></line>
        <line t="C" i="2451" b="1" n="1">! The returned pointer to element</line>
        <line t="X" i="2452" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="2453" b="1" n="1"></line>
        <line t="X" i="2454" b="1" n="1"></line>
        <line t="C" i="2455" b="1" n="1">! Check that index is within bounds</line>
        <line t="X" i="2456" b="2" n="2">  if( this%idx &gt;= 1 .and. this%idx &lt;= this%parent%count ) then</line>
        <line t="X" i="2457" b="2" n="2"></line>
        <line t="C" i="2458" b="2" n="2">!   Return the data element pointed by the iterator</line>
        <line t="X" i="2459" b="2" n="2">    call element_assign_allocatable( res, this%parent%data(this%idx)%element )</line>
        <line t="X" i="2460" b="2" n="2"></line>
        <line t="X" i="2461" b="2" n="1">  end if</line>
        <line t="X" i="2462" b="2" n="1"></line>
        <line t="EF" i="2463" b="2" n="1">end function vector_iterator_get_element</line>
        <line t="EF" i="2464" b="1" n="1"></line>
        <line t="EF" i="2465" b="1" n="1"></line>
        <line t="C" i="2466" b="1" n="1">! Get a pointer to the data elememnt in the node pointed by the iterator</line>
        <line k="vector_iterator_get_element_ptr" t="F" i="2467" b="1" n="1">function vector_iterator_get_element_ptr( this ) result(res)</line>
        <line t="F" i="2468" b="1" n="1"></line>
        <line t="C" i="2469" b="1" n="1">! The iterator</line>
        <line t="X" i="2470" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="2471" b="1" n="1"></line>
        <line t="C" i="2472" b="1" n="1">! The returned element</line>
        <line t="X" i="2473" b="1" n="1">  class(xxtypebase__), pointer :: res</line>
        <line t="X" i="2474" b="1" n="1"></line>
        <line t="X" i="2475" b="1" n="1"></line>
        <line t="C" i="2476" b="1" n="1">! Check that index is within bounds</line>
        <line t="X" i="2477" b="2" n="2">  if( this%idx &gt;= 1 .and. this%idx &lt;= this%parent%count ) then</line>
        <line t="X" i="2478" b="2" n="2"></line>
        <line t="C" i="2479" b="2" n="2">!   Return the data element pointed by the iterator</line>
        <line t="X" i="2480" b="2" n="2">    res =&gt; this%parent%data(this%idx)%element</line>
        <line t="X" i="2481" b="2" n="2"></line>
        <line t="X" i="2482" b="2" n="1">  end if</line>
        <line t="X" i="2483" b="2" n="1"></line>
        <line t="EF" i="2484" b="2" n="1">end function vector_iterator_get_element_ptr</line>
        <line t="EF" i="2485" b="1" n="1"></line>
        <line t="EF" i="2486" b="1" n="1"></line>
        <line t="EF" i="2487" b="1" n="1"></line>
        <line t="C" i="2488" b="1" n="1">! Set the element in the node pointed by the iterator</line>
        <line k="vector_iterator_set_element" t="S" i="2489" b="1" n="1">pure subroutine vector_iterator_set_element( this, val )</line>
        <line t="S" i="2490" b="1" n="1"></line>
        <line t="C" i="2491" b="1" n="1">! The iterator</line>
        <line t="X" i="2492" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(inout) :: this</line>
        <line t="X" i="2493" b="1" n="1"></line>
        <line t="C" i="2494" b="1" n="1">! The element to be assigned</line>
        <line t="X" i="2495" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="2496" b="1" n="1"></line>
        <line t="C" i="2497" b="1" n="1">! Check that index is within bounds; else do nothing</line>
        <line t="X" i="2498" b="2" n="2">  if( this%idx &gt;= 1 .and. this%idx &lt;= this%parent%count ) then</line>
        <line t="X" i="2499" b="2" n="2"></line>
        <line t="C" i="2500" b="2" n="2">!   Set the element</line>
        <line t="X" i="2501" b="2" n="2">    call element_assign_pointer( this%parent%data(this%idx)%element, val )</line>
        <line t="X" i="2502" b="2" n="2"></line>
        <line t="X" i="2503" b="2" n="1">  end if</line>
        <line t="X" i="2504" b="2" n="1"></line>
        <line t="ES" i="2505" b="2" n="1">end subroutine vector_iterator_set_element</line>
        <line t="ES" i="2506" b="1" n="1"></line>
        <line t="ES" i="2507" b="1" n="1"></line>
        <line t="C" i="2508" b="1" n="1">! Create an interator from an existing iterator (assignment operator)</line>
        <line t="C" i="2509" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="2510" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="2511" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_iterator_assign" t="S" i="2512" b="1" n="1">subroutine vector_iterator_assign( left, right )</line>
        <line t="S" i="2513" b="1" n="1"></line>
        <line t="C" i="2514" b="1" n="1">! The output iterator</line>
        <line t="X" i="2515" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(out) :: left</line>
        <line t="X" i="2516" b="1" n="1"></line>
        <line t="C" i="2517" b="1" n="1">! The input iterator</line>
        <line t="X" i="2518" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: right</line>
        <line t="X" i="2519" b="1" n="1"></line>
        <line t="C" i="2520" b="1" n="1">! Associate iterator</line>
        <line t="X" i="2521" b="1" n="1">  left%idx = right%idx</line>
        <line t="X" i="2522" b="1" n="1"></line>
        <line t="C" i="2523" b="1" n="1">! Associate parent</line>
        <line t="X" i="2524" b="1" n="1">  left%parent =&gt; right%parent</line>
        <line t="X" i="2525" b="1" n="1"></line>
        <line t="ES" i="2526" b="1" n="1">end subroutine vector_iterator_assign</line>
        <line t="ES" i="2527" b="1" n="1"></line>
        <line t="ES" i="2528" b="1" n="1"></line>
        <line t="C" i="2529" b="1" n="1">! Compare two iterators (equality)</line>
        <line t="C" i="2530" b="1" n="1">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="2531" b="1" n="1">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="2532" b="1" n="1">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_iterator_equal" t="F" i="2533" b="1" n="1">pure function vector_iterator_equal( left, right ) result(res)</line>
        <line t="F" i="2534" b="1" n="1"></line>
        <line t="C" i="2535" b="1" n="1">! The first iterator</line>
        <line t="X" i="2536" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: left</line>
        <line t="X" i="2537" b="1" n="1"></line>
        <line t="C" i="2538" b="1" n="1">! The second iterator</line>
        <line t="X" i="2539" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: right</line>
        <line t="X" i="2540" b="1" n="1"></line>
        <line t="C" i="2541" b="1" n="1">! The comparison result</line>
        <line t="X" i="2542" b="1" n="1">  logical :: res</line>
        <line t="X" i="2543" b="1" n="1"></line>
        <line t="C" i="2544" b="1" n="1">! Compute result by pointer association check</line>
        <line t="X" i="2545" b="1" n="1">  res = associated( left%parent, right%parent )</line>
        <line t="X" i="2546" b="2" n="2">  if( res ) res = ( left%idx == right%idx )</line>
        <line t="X" i="2547" b="2" n="2"></line>
        <line t="X" i="2548" b="2" n="2"></line>
        <line t="EF" i="2549" b="2" n="2">end function vector_iterator_equal</line>
        <line t="EF" i="2550" b="1" n="2"></line>
        <line t="EF" i="2551" b="1" n="2"></line>
        <line t="C" i="2552" b="1" n="2">! Compare two iterator (inequality)</line>
        <line t="C" i="2553" b="1" n="2">! This interface is also designed to allow inheritance of the list type</line>
        <line t="C" i="2554" b="1" n="2">! and then to extend also the list_iterator type such that the derived list type</line>
        <line t="C" i="2555" b="1" n="2">! can invoke this method with the derivied list_iterator type</line>
        <line k="vector_iterator_not_equal" t="F" i="2556" b="1" n="1">pure function vector_iterator_not_equal( left, right ) result(res)</line>
        <line t="F" i="2557" b="1" n="1"></line>
        <line t="C" i="2558" b="1" n="1">! The first iterator</line>
        <line t="X" i="2559" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: left</line>
        <line t="X" i="2560" b="1" n="1"></line>
        <line t="C" i="2561" b="1" n="1">! The second iterator</line>
        <line t="X" i="2562" b="1" n="1">  class(xxtypebase___vector_ftl_iterator), intent(in) :: right</line>
        <line t="X" i="2563" b="1" n="1"></line>
        <line t="C" i="2564" b="1" n="1">! The comparison result</line>
        <line t="X" i="2565" b="1" n="1">  logical :: res</line>
        <line t="X" i="2566" b="1" n="1"></line>
        <line t="C" i="2567" b="1" n="1">! Compute result by pointer association check</line>
        <line t="X" i="2568" b="1" n="1">  res = .not. ( left == right )</line>
        <line t="X" i="2569" b="1" n="1"></line>
        <line t="EF" i="2570" b="1" n="1">end function vector_iterator_not_equal</line>
        <line t="EF" i="2571" b="1" n="1"></line>
        <line t="EF" i="2572" b="1" n="1"></line>
        <line t="C" i="2573" b="1" n="1">! Request a change in capacity</line>
        <line t="C" i="2574" b="1" n="1">! Requests that the vector capacity be at least enough to contain n elements.</line>
        <line t="C" i="2575" b="1" n="1">! If n is greater than the current vector capacity, the function causes the container </line>
        <line t="C" i="2576" b="1" n="1">! to reallocate its storage increasing its capacity to n (or greater).</line>
        <line t="C" i="2577" b="1" n="1">! In all other cases, the function call does not cause a reallocation and the vector capacity </line>
        <line t="C" i="2578" b="1" n="1">! is not affected.</line>
        <line t="C" i="2579" b="1" n="1">! This function has no effect on the vector size and cannot alter its elements.</line>
        <line k="vector_reserve" t="S" i="2580" b="1" n="1">pure subroutine vector_reserve( this, capacity )</line>
        <line t="S" i="2581" b="1" n="1"></line>
        <line t="C" i="2582" b="1" n="1">! The vector</line>
        <line t="X" i="2583" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="2584" b="1" n="1"></line>
        <line t="C" i="2585" b="1" n="1">! The user reqested capacity</line>
        <line t="X" i="2586" b="1" n="1">  integer, intent(in) :: capacity</line>
        <line t="X" i="2587" b="1" n="1"></line>
        <line t="C" i="2588" b="1" n="1">! Local intermediate storage</line>
        <line t="C" i="2589" b="1" n="1">! Do not use the vector_ftl type to avoid calling impure final subroutine</line>
        <line t="X" i="2590" b="1" n="1">  type(t_node), allocatable, dimension(:) :: local</line>
        <line t="X" i="2591" b="1" n="1"></line>
        <line t="C" i="2592" b="1" n="1">! Local variables</line>
        <line t="X" i="2593" b="1" n="1">  integer :: i, m</line>
        <line t="X" i="2594" b="1" n="1"></line>
        <line t="C" i="2595" b="1" n="1">! Compute the size to allocate</line>
        <line t="C" i="2596" b="1" n="1">! The default behaviour never removes used storage</line>
        <line t="X" i="2597" b="1" n="1">  m = maxval( [ capacity, this%count ] )</line>
        <line t="X" i="2598" b="1" n="1"></line>
        <line t="C" i="2599" b="1" n="1">! Check array status</line>
        <line t="X" i="2600" b="2" n="2">  if( .not. allocated(this%data) ) then</line>
        <line t="X" i="2601" b="2" n="2"></line>
        <line t="C" i="2602" b="2" n="2">!   Initialise capacity to requested size</line>
        <line t="X" i="2603" b="2" n="2">    allocate( this%data(m) )</line>
        <line t="X" i="2604" b="2" n="2">    this%count = 0</line>
        <line t="X" i="2605" b="2" n="2">  </line>
        <line t="X" i="2606" b="3" n="2">  else </line>
        <line t="X" i="2607" b="3" n="2">  </line>
        <line t="C" i="2608" b="3" n="2">!   Check if reallocation is necessary</line>
        <line t="X" i="2609" b="4" n="3">    if( m &gt; size(this%data) ) then</line>
        <line t="X" i="2610" b="4" n="3"></line>
        <line t="C" i="2611" b="4" n="3">!     Preserve pointer to current elements in local buffer</line>
        <line t="X" i="2612" b="4" n="3">      allocate( local( m ) )</line>
        <line t="X" i="2613" b="5" n="4">      do i = 1, this%count</line>
        <line t="X" i="2614" b="5" n="4">        local(i)%element =&gt; this%data(i)%element</line>
        <line t="X" i="2615" b="5" n="3">      end do</line>
        <line t="X" i="2616" b="5" n="3"></line>
        <line t="C" i="2617" b="5" n="3">!     Reallocate vector to new capacity</line>
        <line t="X" i="2618" b="5" n="3">      deallocate( this%data )</line>
        <line t="X" i="2619" b="5" n="3">      allocate( this%data(m) )</line>
        <line t="X" i="2620" b="5" n="3"></line>
        <line t="C" i="2621" b="5" n="3">!     Restore pointers to vector vector elements</line>
        <line t="X" i="2622" b="6" n="4">      do i = 1, this%count</line>
        <line t="X" i="2623" b="6" n="4">        this%data(i)%element =&gt; local(i)%element</line>
        <line t="X" i="2624" b="6" n="3">      end do</line>
        <line t="X" i="2625" b="6" n="3"></line>
        <line t="C" i="2626" b="6" n="3">!     Deallocate local buffer</line>
        <line t="X" i="2627" b="6" n="3">      deallocate( local )</line>
        <line t="X" i="2628" b="6" n="3"></line>
        <line t="X" i="2629" b="6" n="2">    end if</line>
        <line t="X" i="2630" b="6" n="2"></line>
        <line t="X" i="2631" b="6" n="1">  end if</line>
        <line t="X" i="2632" b="6" n="1"></line>
        <line t="ES" i="2633" b="6" n="1">end subroutine vector_reserve</line>
        <line t="ES" i="2634" b="1" n="1"></line>
        <line t="ES" i="2635" b="1" n="1"></line>
        <line t="C" i="2636" b="1" n="1">! Internal array memory handling (realloc)</line>
        <line k="vector_realloc" t="S" i="2637" b="1" n="1">pure subroutine vector_realloc( this )</line>
        <line t="S" i="2638" b="1" n="1"></line>
        <line t="C" i="2639" b="1" n="1">! The vector</line>
        <line t="X" i="2640" b="1" n="1">  class(xxtypebase___vector_ftl), intent(inout) :: this</line>
        <line t="X" i="2641" b="1" n="1"></line>
        <line t="C" i="2642" b="1" n="1">! Check array status</line>
        <line t="X" i="2643" b="2" n="2">  if( .not. allocated(this%data) ) then</line>
        <line t="X" i="2644" b="2" n="2"></line>
        <line t="C" i="2645" b="2" n="2">!   Simply reserve the necessary memory</line>
        <line t="X" i="2646" b="2" n="2">    call this%reserve( vector_base_capacity )</line>
        <line t="X" i="2647" b="2" n="2"></line>
        <line t="C" i="2648" b="2" n="2">! Check if the array capacitz has been exhausted</line>
        <line t="X" i="2649" b="3" n="2">  else if( this%count == size(this%data) ) then</line>
        <line t="X" i="2650" b="3" n="2"></line>
        <line t="C" i="2651" b="3" n="2">!   Request array reallocation</line>
        <line t="X" i="2652" b="3" n="2">    call this%reserve( int( this%count * vector_base_capacity_increase ) )</line>
        <line t="X" i="2653" b="3" n="2">  </line>
        <line t="X" i="2654" b="3" n="1">  end if</line>
        <line t="X" i="2655" b="3" n="1"></line>
        <line t="ES" i="2656" b="3" n="1">end subroutine vector_realloc</line>
        <line t="ES" i="2657" b="1" n="1"></line>
        <line t="M" i="2658" b="1" n="1">end module xxmodulebase___vector_ftl</line>
        <line t="M" i="2659" b="1" n="1"></line>
    </code>
</fmx>