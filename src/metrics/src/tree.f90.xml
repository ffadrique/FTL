<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../fmx.xsl"?>
<fmx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="tree.f90">
    <context>
        <time>2025-03-09T11:42:15</time>
        <version>1.0.0.1</version>
        <path>src</path>
        <path_to_root>../</path_to_root>
        <project>FTL</project>
        <name>tree.f90</name>
        <copyright>Copyright © 2020, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</copyright>
    </context>
    <units>
        <unit name="xxmodulebase___tree_ftl" type="module">
            <main>
                <lines>
                    <source percent="47.81">109</source>
                    <comments percent="27.63">63</comments>
                    <empty percent="24.56">56</empty>
                    <total>228</total>
                </lines>
                <complexity>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </complexity>
                <nesting>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </nesting>
                <methods>0</methods>
            </main>
            <methods>
                <method name="element_assign_allocatable" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="element_assign_pointer" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="30.00">6</source>
                            <comments percent="35.00">7</comments>
                            <empty percent="35.00">7</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="25.00">3</comments>
                            <empty percent="41.67">5</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_add_children_from_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.84">21</source>
                            <comments percent="26.32">15</comments>
                            <empty percent="36.84">21</empty>
                            <total>57</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_assign_from_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="39.13">9</source>
                            <comments percent="26.09">6</comments>
                            <empty percent="34.78">8</empty>
                            <total>23</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_associated" type="function">
                    <statistics>
                        <lines>
                            <source percent="40.00">10</source>
                            <comments percent="32.00">8</comments>
                            <empty percent="28.00">7</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_back" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.84">7</source>
                            <comments percent="26.32">5</comments>
                            <empty percent="36.84">7</empty>
                            <total>19</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_begin_iterator" type="function">
                    <statistics>
                        <lines>
                            <source percent="31.82">7</source>
                            <comments percent="36.36">8</comments>
                            <empty percent="31.82">7</empty>
                            <total>22</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_begin_sibling" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.84">14</source>
                            <comments percent="31.58">12</comments>
                            <empty percent="31.58">12</empty>
                            <total>38</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_begin_tree" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.50">6</source>
                            <comments percent="25.00">4</comments>
                            <empty percent="37.50">6</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_children" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_clear_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="36.11">26</source>
                            <comments percent="29.17">21</comments>
                            <empty percent="34.72">25</empty>
                            <total>72</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>8</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_clear_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="45.65">21</source>
                            <comments percent="21.74">10</comments>
                            <empty percent="32.61">15</empty>
                            <total>46</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_clear_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_container_ptr" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_copy" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_default" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">3</source>
                            <comments percent="22.22">2</comments>
                            <empty percent="44.44">4</empty>
                            <total>9</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_depth" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.00">11</source>
                            <comments percent="24.00">6</comments>
                            <empty percent="32.00">8</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_element_to_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_empty_iterator" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_empty_node" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_empty_tree" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_end_iterator" type="function">
                    <statistics>
                        <lines>
                            <source percent="31.82">7</source>
                            <comments percent="36.36">8</comments>
                            <empty percent="31.82">7</empty>
                            <total>22</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_end_sibling" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.84">14</source>
                            <comments percent="32.43">12</comments>
                            <empty percent="29.73">11</empty>
                            <total>37</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_end_tree" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.00">11</source>
                            <comments percent="24.00">6</comments>
                            <empty percent="32.00">8</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_erase" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="44.44">20</source>
                            <comments percent="28.89">13</comments>
                            <empty percent="26.67">12</empty>
                            <total>45</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_front" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_has_children" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_has_data" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_has_siblings" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.00">9</source>
                            <comments percent="24.00">6</comments>
                            <empty percent="40.00">10</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_insert_sibling" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="39.53">17</source>
                            <comments percent="32.56">14</comments>
                            <empty percent="27.91">12</empty>
                            <total>43</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_iterator_assign_from_tree_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="37.50">6</source>
                            <comments percent="25.00">4</comments>
                            <empty percent="37.50">6</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_iterator_get_element" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_iterator_get_element_ptr" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_next_sibling" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.50">6</source>
                            <comments percent="25.00">4</comments>
                            <empty percent="37.50">6</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_next_tree_node" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.36">16</source>
                            <comments percent="25.00">11</comments>
                            <empty percent="38.64">17</empty>
                            <total>44</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_next_tree_node_up" type="function">
                    <statistics>
                        <lines>
                            <source percent="38.78">19</source>
                            <comments percent="26.53">13</comments>
                            <empty percent="34.69">17</empty>
                            <total>49</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_nullify" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="25.00">3</comments>
                            <empty percent="41.67">5</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_parent" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.44">8</source>
                            <comments percent="22.22">4</comments>
                            <empty percent="33.33">6</empty>
                            <total>18</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_back_child_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="26.67">4</source>
                            <comments percent="40.00">6</comments>
                            <empty percent="33.33">5</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_back_child_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="41.03">16</source>
                            <comments percent="23.08">9</comments>
                            <empty percent="35.90">14</empty>
                            <total>39</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_back_child_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="25.00">3</comments>
                            <empty percent="41.67">5</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_back_sibling" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="26.67">4</source>
                            <comments percent="40.00">6</comments>
                            <empty percent="33.33">5</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_front_child_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="26.67">4</source>
                            <comments percent="40.00">6</comments>
                            <empty percent="33.33">5</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_front_child_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="38.24">13</source>
                            <comments percent="23.53">8</comments>
                            <empty percent="38.24">13</empty>
                            <total>34</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_front_child_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">4</source>
                            <comments percent="25.00">3</comments>
                            <empty percent="41.67">5</empty>
                            <total>12</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_pop_front_sibling" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="26.67">4</source>
                            <comments percent="40.00">6</comments>
                            <empty percent="33.33">5</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_previous_node" type="function">
                    <statistics>
                        <lines>
                            <source percent="39.58">19</source>
                            <comments percent="25.00">12</comments>
                            <empty percent="35.42">17</empty>
                            <total>48</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_previous_sibling" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.50">6</source>
                            <comments percent="25.00">4</comments>
                            <empty percent="37.50">6</empty>
                            <total>16</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_back_child_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="27.78">5</source>
                            <comments percent="38.89">7</comments>
                            <empty percent="33.33">6</empty>
                            <total>18</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_back_child_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="40.91">18</source>
                            <comments percent="25.00">11</comments>
                            <empty percent="34.09">15</empty>
                            <total>44</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_back_child_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_back_sibling" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="27.78">5</source>
                            <comments percent="38.89">7</comments>
                            <empty percent="33.33">6</empty>
                            <total>18</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_front_child_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="27.78">5</source>
                            <comments percent="38.89">7</comments>
                            <empty percent="33.33">6</empty>
                            <total>18</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_front_child_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="40.91">18</source>
                            <comments percent="25.00">11</comments>
                            <empty percent="34.09">15</empty>
                            <total>44</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_front_child_tree" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_push_front_sibling" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="27.78">5</source>
                            <comments percent="38.89">7</comments>
                            <empty percent="33.33">6</empty>
                            <total>18</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_sibling_position" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.00">11</source>
                            <comments percent="24.00">6</comments>
                            <empty percent="32.00">8</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_siblings" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_swap_iterator" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="tree_swap_node" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="44.12">60</source>
                            <comments percent="22.79">31</comments>
                            <empty percent="33.09">45</empty>
                            <total>136</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>15</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
            </methods>
            <statistics>
                <lines>
                    <source percent="38.57">687</source>
                    <comments percent="27.68">493</comments>
                    <empty percent="33.75">601</empty>
                    <total>1781</total>
                </lines>
                <complexity>
                    <minimum>1</minimum>
                    <maximum>15</maximum>
                    <average>2.25</average>
                </complexity>
                <nesting>
                    <minimum>1</minimum>
                    <maximum>4</maximum>
                    <average>1.56</average>
                </nesting>
                <methods>61</methods>
            </statistics>
        </unit>
    </units>
    <statistics>
        <lines>
            <source percent="38.57">687</source>
            <comments percent="27.68">493</comments>
            <empty percent="33.75">601</empty>
            <total>1781</total>
        </lines>
        <complexity>
            <minimum>1</minimum>
            <maximum>15</maximum>
            <average>2.25</average>
        </complexity>
        <nesting>
            <minimum>1</minimum>
            <maximum>4</maximum>
            <average>1.56</average>
        </nesting>
        <methods>61</methods>
    </statistics>
    <code>
        <line t="M" i="1" b="0" n="0">module xxmodulebase___tree_ftl</line>
        <line t="M" i="2" b="0" n="0"></line>
        <line t="C" i="3" b="0" n="0">!------------------------------------------------------------------------------</line>
        <line t="C" i="4" b="0" n="0">! Copyright : 2022, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</line>
        <line t="C" i="5" b="0" n="0">! Project   : Atlantis</line>
        <line t="C" i="6" b="0" n="0">! Author    : Fran Martinez Fadrique</line>
        <line t="C" i="7" b="0" n="0">! Language  : Object Oriented Fortran 2018</line>
        <line t="C" i="8" b="0" n="0">! Synopsis  : Tree container template</line>
        <line t="C" i="9" b="0" n="0">!</line>
        <line t="C" i="10" b="0" n="0">! License   : This file is part of the Fortran Template Library (FTL).</line>
        <line t="C" i="11" b="0" n="0">!</line>
        <line t="C" i="12" b="0" n="0">!             FTL is free software: you can redistribute it and/or modify</line>
        <line t="C" i="13" b="0" n="0">!             it under the terms of the GNU Lesser General Public License as</line>
        <line t="C" i="14" b="0" n="0">!             published by the Free Software Foundation, either version 3 of</line>
        <line t="C" i="15" b="0" n="0">!             the License, or (at your option) any later version.</line>
        <line t="C" i="16" b="0" n="0">!</line>
        <line t="C" i="17" b="0" n="0">!             FTL is distributed in the hope that it will be useful,</line>
        <line t="C" i="18" b="0" n="0">!             but WITHOUT ANY WARRANTY; without even the implied warranty of</line>
        <line t="C" i="19" b="0" n="0">!             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</line>
        <line t="C" i="20" b="0" n="0">!             See the GNU Lesser General Public License for more details.</line>
        <line t="C" i="21" b="0" n="0">!</line>
        <line t="C" i="22" b="0" n="0">!             You should have received a copy of the GNU Lesser General Public</line>
        <line t="C" i="23" b="0" n="0">!             License along with FTL.  </line>
        <line t="C" i="24" b="0" n="0">!             If not, see &lt;http://www.gnu.org/licenses/&gt;.</line>
        <line t="C" i="25" b="0" n="0">!------------------------------------------------------------------------------</line>
        <line t="C" i="26" b="0" n="0"></line>
        <line t="C" i="27" b="0" n="0">!- Start of use statements ----------------------------------------------------</line>
        <line t="C" i="28" b="0" n="0"></line>
        <line t="X" i="29" b="0" n="0">  use m_object</line>
        <line t="X" i="30" b="0" n="0">  use xxuse__</line>
        <line t="X" i="31" b="0" n="0"></line>
        <line t="C" i="32" b="0" n="0">!- End of use statements ------------------------------------------------------</line>
        <line t="C" i="33" b="0" n="0"></line>
        <line t="X" i="34" b="0" n="0">  implicit none</line>
        <line t="X" i="35" b="0" n="0"></line>
        <line t="C" i="36" b="0" n="0">!- Start of Public/Private declarations ---------------------------------------</line>
        <line t="C" i="37" b="0" n="0"></line>
        <line t="X" i="38" b="0" n="0">  private</line>
        <line t="X" i="39" b="0" n="0"></line>
        <line t="X" i="40" b="0" n="0">  public xxtypebase___tree_ftl, xxconstructor___tree_ftl</line>
        <line t="X" i="41" b="0" n="0">  public xxtypebase___tree_ftl_iterator</line>
        <line t="X" i="42" b="0" n="0"></line>
        <line t="C" i="43" b="0" n="0">!- End of Public/Private declarations -----------------------------------------</line>
        <line t="C" i="44" b="0" n="0"></line>
        <line t="C" i="45" b="0" n="0">!- Start of module variable declarations --------------------------------------</line>
        <line t="C" i="46" b="0" n="0"></line>
        <line t="C" i="47" b="0" n="0">! Tree node type</line>
        <line t="T" i="48" b="0" n="0">  type t_tree_node</line>
        <line t="X" i="49" b="0" n="0">    private</line>
        <line t="X" i="50" b="0" n="0"></line>
        <line t="C" i="51" b="0" n="0">!     Pointer to parent (null at root)</line>
        <line t="X" i="52" b="0" n="0">      type(t_tree_node), pointer :: parent =&gt; null()</line>
        <line t="X" i="53" b="0" n="0"></line>
        <line t="C" i="54" b="0" n="0">!     Pointer to the previous sibling</line>
        <line t="X" i="55" b="0" n="0">      type(t_tree_node), pointer :: previous_sibling =&gt; null()</line>
        <line t="X" i="56" b="0" n="0"></line>
        <line t="C" i="57" b="0" n="0">!     Pointer to the next sibling</line>
        <line t="X" i="58" b="0" n="0">      type(t_tree_node), pointer :: next_sibling =&gt; null()</line>
        <line t="X" i="59" b="0" n="0"></line>
        <line t="C" i="60" b="0" n="0">!     Total number of children</line>
        <line t="X" i="61" b="0" n="0">      integer :: children = 0</line>
        <line t="X" i="62" b="0" n="0"></line>
        <line t="C" i="63" b="0" n="0">!     Pointer to the first child</line>
        <line t="X" i="64" b="0" n="0">      type(t_tree_node), pointer :: first_child =&gt; null()</line>
        <line t="X" i="65" b="0" n="0"></line>
        <line t="C" i="66" b="0" n="0">!     Pointer to the last child</line>
        <line t="X" i="67" b="0" n="0">      type(t_tree_node), pointer :: last_child =&gt; null()</line>
        <line t="X" i="68" b="0" n="0"></line>
        <line t="C" i="69" b="0" n="0">!     The element type</line>
        <line t="X" i="70" b="0" n="0">      class(xxtypebase__), pointer :: element =&gt; null()</line>
        <line t="X" i="71" b="0" n="0"></line>
        <line t="X" i="72" b="0" n="0">    contains</line>
        <line t="X" i="73" b="0" n="0"></line>
        <line t="C" i="74" b="0" n="0">!     Generic interfaces for data insertion/deletion at boundaries</line>
        <line t="X" i="75" b="0" n="0">      procedure :: push_front_child =&gt; tree_push_front_child_node</line>
        <line t="X" i="76" b="0" n="0">      procedure :: push_back_child =&gt; tree_push_back_child_node</line>
        <line t="X" i="77" b="0" n="0">      procedure :: pop_front_child =&gt; tree_pop_front_child_node</line>
        <line t="X" i="78" b="0" n="0">      procedure :: pop_back_child =&gt; tree_pop_back_child_node</line>
        <line t="X" i="79" b="0" n="0"></line>
        <line t="C" i="80" b="0" n="0">!     Generic interfaces for navigation</line>
        <line t="X" i="81" b="0" n="0">      procedure :: next_tree_node_up =&gt; tree_next_tree_node_up</line>
        <line t="X" i="82" b="0" n="0">      procedure :: empty_node =&gt; tree_empty_node</line>
        <line t="X" i="83" b="0" n="0"></line>
        <line t="C" i="84" b="0" n="0">!     Generic interface for tree/node clean-up</line>
        <line t="X" i="85" b="0" n="0">      procedure :: clear =&gt; tree_clear_node</line>
        <line t="X" i="86" b="0" n="0"></line>
        <line t="C" i="87" b="0" n="0">!     Generic interfaces for seach and sort</line>
        <line t="X" i="88" b="0" n="0">      procedure :: swap =&gt; tree_swap_node</line>
        <line t="X" i="89" b="0" n="0"></line>
        <line t="T" i="90" b="0" n="0">  end type t_tree_node</line>
        <line t="T" i="91" b="0" n="0"></line>
        <line t="T" i="92" b="0" n="0"></line>
        <line t="C" i="93" b="0" n="0">! Tree management type (tree root)</line>
        <line t="T" i="94" b="0" n="0">  type, extends(t_object) :: xxtypebase___tree_ftl</line>
        <line t="X" i="95" b="0" n="0">    private</line>
        <line t="X" i="96" b="0" n="0"></line>
        <line t="C" i="97" b="0" n="0">!     The root node</line>
        <line t="X" i="98" b="0" n="0">      type(t_tree_node) :: root</line>
        <line t="X" i="99" b="0" n="0"></line>
        <line t="X" i="100" b="0" n="0">    contains</line>
        <line t="X" i="101" b="0" n="0"></line>
        <line t="C" i="102" b="0" n="0">!     Assign procedure</line>
        <line t="X" i="103" b="0" n="0">      procedure :: assign =&gt; tree_assign_from_tree</line>
        <line t="X" i="104" b="0" n="0"></line>
        <line t="C" i="105" b="0" n="0">!     Generic interfaces for data insertion/deletion at boundaries</line>
        <line t="X" i="106" b="0" n="0">      generic :: push_front_child =&gt;  tree_push_front_child_tree, &amp;</line>
        <line t="X" i="107" b="0" n="0">                                      tree_push_front_child_iterator</line>
        <line t="X" i="108" b="0" n="0">      procedure, private :: tree_push_front_child_tree</line>
        <line t="X" i="109" b="0" n="0">      procedure, nopass, private :: tree_push_front_child_iterator</line>
        <line t="X" i="110" b="0" n="0">      generic :: push_back_child =&gt; tree_push_back_child_tree, &amp;</line>
        <line t="X" i="111" b="0" n="0">                                    tree_push_back_child_iterator</line>
        <line t="X" i="112" b="0" n="0">      procedure, private :: tree_push_back_child_tree</line>
        <line t="X" i="113" b="0" n="0">      procedure, nopass, private :: tree_push_back_child_iterator</line>
        <line t="X" i="114" b="0" n="0">      generic :: pop_front_child =&gt; tree_pop_front_child_tree, &amp;</line>
        <line t="X" i="115" b="0" n="0">                                    tree_pop_front_child_iterator</line>
        <line t="X" i="116" b="0" n="0">      procedure, private :: tree_pop_front_child_tree</line>
        <line t="X" i="117" b="0" n="0">      procedure, nopass, private :: tree_pop_front_child_iterator</line>
        <line t="X" i="118" b="0" n="0">      generic :: pop_back_child =&gt; tree_pop_back_child_tree, &amp;</line>
        <line t="X" i="119" b="0" n="0">                                   tree_pop_back_child_iterator</line>
        <line t="X" i="120" b="0" n="0">      procedure, private :: tree_pop_back_child_tree</line>
        <line t="X" i="121" b="0" n="0">      procedure, nopass, private :: tree_pop_back_child_iterator</line>
        <line t="X" i="122" b="0" n="0"></line>
        <line t="C" i="123" b="0" n="0">!     Generic interfaces for data insertion/deletion</line>
        <line t="X" i="124" b="0" n="0">      procedure, nopass :: push_front_sibling =&gt; tree_push_front_sibling</line>
        <line t="X" i="125" b="0" n="0">      procedure, nopass :: push_back_sibling =&gt; tree_push_back_sibling</line>
        <line t="X" i="126" b="0" n="0">      procedure, nopass :: pop_front_sibling =&gt; tree_pop_front_sibling</line>
        <line t="X" i="127" b="0" n="0">      procedure, nopass :: pop_back_sibling =&gt; tree_pop_back_sibling</line>
        <line t="X" i="128" b="0" n="0">      procedure, nopass :: insert =&gt; tree_insert_sibling</line>
        <line t="X" i="129" b="0" n="0">      procedure, nopass :: erase =&gt; tree_erase</line>
        <line t="X" i="130" b="0" n="0"></line>
        <line t="C" i="131" b="0" n="0">!     Generic interfaces for tree status query</line>
        <line t="X" i="132" b="0" n="0">      procedure :: empty =&gt; tree_empty_tree</line>
        <line t="X" i="133" b="0" n="0"></line>
        <line t="C" i="134" b="0" n="0">!     Generic interface for tree/node clean-up</line>
        <line t="X" i="135" b="0" n="0">      generic :: clear =&gt; tree_clear_tree, &amp;</line>
        <line t="X" i="136" b="0" n="0">                          tree_clear_iterator</line>
        <line t="X" i="137" b="0" n="0">      procedure :: tree_clear_tree</line>
        <line t="X" i="138" b="0" n="0">      procedure, nopass :: tree_clear_iterator</line>
        <line t="X" i="139" b="0" n="0"></line>
        <line t="C" i="140" b="0" n="0">!     Generic interfaces for navigation</line>
        <line t="X" i="141" b="0" n="0">      generic :: begin =&gt; tree_begin_tree, &amp;</line>
        <line t="X" i="142" b="0" n="0">                          tree_begin_iterator</line>
        <line t="X" i="143" b="0" n="0">      procedure, private :: tree_begin_tree</line>
        <line t="X" i="144" b="0" n="0">      procedure, private :: tree_begin_iterator</line>
        <line t="X" i="145" b="0" n="0">      generic :: end =&gt; tree_end_tree, &amp;</line>
        <line t="X" i="146" b="0" n="0">                        tree_end_iterator</line>
        <line t="X" i="147" b="0" n="0">      procedure, private :: tree_end_tree</line>
        <line t="X" i="148" b="0" n="0">      procedure, private :: tree_end_iterator</line>
        <line t="X" i="149" b="0" n="0">      procedure :: begin_sibling =&gt; tree_begin_sibling</line>
        <line t="X" i="150" b="0" n="0">      procedure :: end_sibling =&gt; tree_end_sibling</line>
        <line t="X" i="151" b="0" n="0"></line>
        <line t="C" i="152" b="0" n="0">!     Generic interfaces for data element access</line>
        <line t="X" i="153" b="0" n="0">      procedure :: front =&gt; tree_front</line>
        <line t="X" i="154" b="0" n="0">      procedure :: back =&gt; tree_back</line>
        <line t="X" i="155" b="0" n="0"></line>
        <line t="C" i="156" b="0" n="0">!     Assignment operator</line>
        <line t="X" i="157" b="0" n="0">      generic :: assignment(=) =&gt; tree_assign_from_tree</line>
        <line t="X" i="158" b="0" n="0">      procedure :: tree_assign_from_tree</line>
        <line t="X" i="159" b="0" n="0"></line>
        <line t="C" i="160" b="0" n="0">!     Destructor</line>
        <line t="X" i="161" b="0" n="0">      final :: tree_</line>
        <line t="X" i="162" b="0" n="0"></line>
        <line t="T" i="163" b="0" n="0">  end type xxtypebase___tree_ftl</line>
        <line t="T" i="164" b="0" n="0"></line>
        <line t="T" i="165" b="0" n="0"></line>
        <line t="C" i="166" b="0" n="0">! Tree iterator type</line>
        <line t="T" i="167" b="0" n="0">  type, extends(t_object) :: xxtypebase___tree_ftl_iterator</line>
        <line t="X" i="168" b="0" n="0">    private</line>
        <line t="X" i="169" b="0" n="0"></line>
        <line t="C" i="170" b="0" n="0">!     Pointer to the referenced node</line>
        <line t="X" i="171" b="0" n="0">      type(t_tree_node), pointer :: node =&gt; null()</line>
        <line t="X" i="172" b="0" n="0"></line>
        <line t="C" i="173" b="0" n="0">!     Pointer to the container tree</line>
        <line t="X" i="174" b="0" n="0">      type(xxtypebase___tree_ftl), pointer :: tree =&gt; null()</line>
        <line t="X" i="175" b="0" n="0"></line>
        <line t="X" i="176" b="0" n="0">    contains</line>
        <line t="X" i="177" b="0" n="0"></line>
        <line t="C" i="178" b="0" n="0">!     Assign procedure</line>
        <line t="X" i="179" b="0" n="0">      procedure :: assign =&gt; tree_iterator_assign_from_tree_iterator</line>
        <line t="X" i="180" b="0" n="0"></line>
        <line t="C" i="181" b="0" n="0">!     Generic interfaces for data insertion/deletion at generic positions</line>
        <line t="X" i="182" b="0" n="0">      procedure :: swap =&gt; tree_swap_iterator</line>
        <line t="X" i="183" b="0" n="0"></line>
        <line t="C" i="184" b="0" n="0">!     Generic interfaces for list status query</line>
        <line t="X" i="185" b="0" n="0">      procedure :: empty =&gt; tree_empty_iterator</line>
        <line t="X" i="186" b="0" n="0">      procedure :: has_children =&gt; tree_has_children</line>
        <line t="X" i="187" b="0" n="0">      procedure :: children =&gt; tree_children</line>
        <line t="X" i="188" b="0" n="0">      procedure :: has_siblings =&gt; tree_has_siblings</line>
        <line t="X" i="189" b="0" n="0">      procedure :: siblings =&gt; tree_Siblings</line>
        <line t="X" i="190" b="0" n="0">      procedure :: parent =&gt; tree_Parent</line>
        <line t="X" i="191" b="0" n="0">      procedure :: depth =&gt; tree_Depth</line>
        <line t="X" i="192" b="0" n="0">      procedure :: sibling_position =&gt; tree_sibling_position</line>
        <line t="X" i="193" b="0" n="0"></line>
        <line t="C" i="194" b="0" n="0">!     Generic interfaces for navigation</line>
        <line t="X" i="195" b="0" n="0">      procedure :: next =&gt; tree_next_tree_node</line>
        <line t="X" i="196" b="0" n="0">      procedure :: previous =&gt; tree_previous_node</line>
        <line t="X" i="197" b="0" n="0">      procedure :: associated =&gt; tree_Associated</line>
        <line t="X" i="198" b="0" n="0">      procedure :: nullify =&gt; tree_nullify</line>
        <line t="X" i="199" b="0" n="0">      procedure :: next_sibling =&gt; tree_next_sibling</line>
        <line t="X" i="200" b="0" n="0">      procedure :: previous_sibling =&gt; tree_previous_sibling</line>
        <line t="X" i="201" b="0" n="0"></line>
        <line t="C" i="202" b="0" n="0">!     Generic interfaces for data element access</line>
        <line t="X" i="203" b="0" n="0">      procedure :: has_data =&gt; tree_has_data</line>
        <line t="X" i="204" b="0" n="0">      procedure :: get_element =&gt; tree_iterator_get_element</line>
        <line t="X" i="205" b="0" n="0">      procedure :: get_element_ptr =&gt; tree_iterator_get_element_ptr</line>
        <line t="X" i="206" b="0" n="0">      procedure :: set_element =&gt; tree_element_to_iterator</line>
        <line t="X" i="207" b="0" n="0"></line>
        <line t="C" i="208" b="0" n="0">!     Access pointer to iterator container instance</line>
        <line t="X" i="209" b="0" n="0">      procedure :: container =&gt; tree_container_ptr</line>
        <line t="X" i="210" b="0" n="0"></line>
        <line t="C" i="211" b="0" n="0">!     Assignment operator</line>
        <line t="X" i="212" b="0" n="0">      generic :: assignment(=) =&gt; tree_iterator_assign_from_tree_iterator</line>
        <line t="X" i="213" b="0" n="0">      procedure, private :: tree_iterator_assign_from_tree_iterator</line>
        <line t="X" i="214" b="0" n="0"></line>
        <line t="T" i="215" b="0" n="0">  end type xxtypebase___tree_ftl_iterator</line>
        <line t="T" i="216" b="0" n="0"></line>
        <line t="T" i="217" b="0" n="0"></line>
        <line t="C" i="218" b="0" n="0">! Constructor interface</line>
        <line t="X" i="219" b="0" n="0">  interface xxconstructor___tree_ftl</line>
        <line t="X" i="220" b="0" n="0">    module procedure tree_default</line>
        <line t="X" i="221" b="0" n="0">    module procedure tree_copy</line>
        <line t="X" i="222" b="0" n="0">  end interface xxconstructor___tree_ftl</line>
        <line t="X" i="223" b="0" n="0"></line>
        <line t="C" i="224" b="0" n="0">!- End of module variable declarations ----------------------------------------</line>
        <line t="C" i="225" b="0" n="0"></line>
        <line t="X" i="226" b="0" n="0">contains</line>
        <line t="X" i="227" b="0" n="0"></line>
        <line t="C" i="228" b="0" n="0">! Default constructor</line>
        <line k="tree_default" t="F" i="229" b="1" n="1">function tree_default() result(res)</line>
        <line t="F" i="230" b="1" n="1"></line>
        <line t="C" i="231" b="1" n="1">! The result tree</line>
        <line t="X" i="232" b="1" n="1">  type(xxtypebase___tree_ftl) :: res</line>
        <line t="X" i="233" b="1" n="1"></line>
        <line t="X" i="234" b="1" n="1"></line>
        <line t="EF" i="235" b="1" n="1">end function tree_default</line>
        <line t="EF" i="236" b="1" n="1"></line>
        <line t="EF" i="237" b="1" n="1"></line>
        <line t="C" i="238" b="1" n="1">! Copy constructor</line>
        <line k="tree_copy" t="F" i="239" b="1" n="1">function tree_copy( other ) result(res)</line>
        <line t="F" i="240" b="1" n="1"></line>
        <line t="C" i="241" b="1" n="1">! The input tree</line>
        <line t="X" i="242" b="1" n="1">  type(xxtypebase___tree_ftl), intent(in) :: other</line>
        <line t="X" i="243" b="1" n="1"></line>
        <line t="C" i="244" b="1" n="1">! The result tree</line>
        <line t="X" i="245" b="1" n="1">  type(xxtypebase___tree_ftl) :: res</line>
        <line t="X" i="246" b="1" n="1"></line>
        <line t="C" i="247" b="1" n="1">! Copy the tree</line>
        <line t="X" i="248" b="1" n="1">  call res%assign(other)</line>
        <line t="X" i="249" b="1" n="1"></line>
        <line t="EF" i="250" b="1" n="1">end function tree_copy</line>
        <line t="EF" i="251" b="1" n="1"></line>
        <line t="EF" i="252" b="1" n="1"></line>
        <line t="C" i="253" b="1" n="1">! Destructor</line>
        <line k="tree_" t="S" i="254" b="1" n="1">subroutine tree_( this )</line>
        <line t="S" i="255" b="1" n="1"></line>
        <line t="C" i="256" b="1" n="1">! The list</line>
        <line t="X" i="257" b="1" n="1">  type(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="258" b="1" n="1"></line>
        <line t="C" i="259" b="1" n="1">! Clear the tree</line>
        <line t="X" i="260" b="1" n="1">  call this%clear()</line>
        <line t="X" i="261" b="1" n="1"></line>
        <line t="ES" i="262" b="1" n="1">end subroutine tree_</line>
        <line t="ES" i="263" b="1" n="1"></line>
        <line t="ES" i="264" b="1" n="1"></line>
        <line t="C" i="265" b="1" n="1">! Add child node at the beginning of the tree root children list; include element if present</line>
        <line k="tree_push_front_child_tree" t="S" i="266" b="1" n="1">subroutine tree_push_front_child_tree( this, val )</line>
        <line t="S" i="267" b="1" n="1"></line>
        <line t="C" i="268" b="1" n="1">! The tree</line>
        <line t="X" i="269" b="1" n="1">  class(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="270" b="1" n="1"></line>
        <line t="C" i="271" b="1" n="1">! The element</line>
        <line t="X" i="272" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="273" b="1" n="1"></line>
        <line t="C" i="274" b="1" n="1">! Invoke the node insertion for the root iterator</line>
        <line t="X" i="275" b="1" n="1">  call this%root%push_front_child( val )</line>
        <line t="X" i="276" b="1" n="1"></line>
        <line t="ES" i="277" b="1" n="1">end subroutine tree_push_front_child_tree</line>
        <line t="ES" i="278" b="1" n="1"></line>
        <line t="ES" i="279" b="1" n="1"></line>
        <line t="C" i="280" b="1" n="1">! Add child node to the beginning of the children list; include element if present</line>
        <line t="C" i="281" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="282" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="283" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_push_front_child_iterator" t="S" i="284" b="1" n="1">subroutine tree_push_front_child_iterator( iterator, val )</line>
        <line t="S" i="285" b="1" n="1"></line>
        <line t="C" i="286" b="1" n="1">! The node iterator</line>
        <line t="X" i="287" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="288" b="1" n="1"></line>
        <line t="C" i="289" b="1" n="1">! The element</line>
        <line t="X" i="290" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="291" b="1" n="1"></line>
        <line t="C" i="292" b="1" n="1">! Invoke the node insertion for the node pointed by the iterator</line>
        <line t="X" i="293" b="1" n="1">  call iterator%node%push_front_child( val )</line>
        <line t="X" i="294" b="1" n="1"></line>
        <line t="ES" i="295" b="1" n="1">end subroutine tree_push_front_child_iterator</line>
        <line t="ES" i="296" b="1" n="1"></line>
        <line t="ES" i="297" b="1" n="1"></line>
        <line t="C" i="298" b="1" n="1">! Add child node to the beginning of the children list; include element if present</line>
        <line k="tree_push_front_child_node" t="S" i="299" b="1" n="1">subroutine tree_push_front_child_node( this, val )</line>
        <line t="S" i="300" b="1" n="1"></line>
        <line t="C" i="301" b="1" n="1">! The node</line>
        <line t="X" i="302" b="1" n="1">  class(t_tree_node),  target, intent(inout) :: this</line>
        <line t="X" i="303" b="1" n="1"></line>
        <line t="C" i="304" b="1" n="1">! The element</line>
        <line t="X" i="305" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="306" b="1" n="1"></line>
        <line t="C" i="307" b="1" n="1">! Chek if node already contains children</line>
        <line t="X" i="308" b="2" n="2">  if( associated(this%last_child) ) then</line>
        <line t="X" i="309" b="2" n="2"></line>
        <line t="C" i="310" b="2" n="2">!   Allocate child node</line>
        <line t="X" i="311" b="2" n="2">    allocate( this%first_child%previous_sibling )</line>
        <line t="X" i="312" b="2" n="2"></line>
        <line t="C" i="313" b="2" n="2">!   Allocate pointers in new node</line>
        <line t="X" i="314" b="2" n="2">    this%first_child%previous_sibling%next_sibling =&gt; this%first_child</line>
        <line t="X" i="315" b="2" n="2">    this%first_child%previous_sibling%parent =&gt; this</line>
        <line t="X" i="316" b="2" n="2"></line>
        <line t="C" i="317" b="2" n="2">!   Reassign pointer to first element</line>
        <line t="X" i="318" b="2" n="2">    this%first_child =&gt; this%first_child%previous_sibling</line>
        <line t="X" i="319" b="2" n="2"></line>
        <line t="X" i="320" b="3" n="2">  else</line>
        <line t="X" i="321" b="3" n="2"></line>
        <line t="C" i="322" b="3" n="2">!   Allocate child node</line>
        <line t="X" i="323" b="3" n="2">    allocate( this%first_child )</line>
        <line t="X" i="324" b="3" n="2"></line>
        <line t="C" i="325" b="3" n="2">!   Assign pointers</line>
        <line t="X" i="326" b="3" n="2">    this%last_child =&gt; this%first_child</line>
        <line t="X" i="327" b="3" n="2">    this%first_child%parent =&gt; this</line>
        <line t="X" i="328" b="3" n="2"></line>
        <line t="X" i="329" b="3" n="1">  end if</line>
        <line t="X" i="330" b="3" n="1"></line>
        <line t="C" i="331" b="3" n="1">! Copy the element into its node position</line>
        <line t="X" i="332" b="4" n="2">  if( present(val) ) then</line>
        <line t="X" i="333" b="4" n="2">    call element_assign_pointer( this%first_child%element, val )</line>
        <line t="X" i="334" b="4" n="1">  end if</line>
        <line t="X" i="335" b="4" n="1"></line>
        <line t="C" i="336" b="4" n="1">! Increase counter</line>
        <line t="X" i="337" b="4" n="1">  this%children = this%children + 1</line>
        <line t="X" i="338" b="4" n="1"></line>
        <line t="ES" i="339" b="4" n="1">end subroutine tree_push_front_child_node</line>
        <line t="ES" i="340" b="1" n="1"></line>
        <line t="ES" i="341" b="1" n="1"></line>
        <line t="C" i="342" b="1" n="1">! Add child node at the end of the tree root children list; include element if present</line>
        <line k="tree_push_back_child_tree" t="S" i="343" b="1" n="1">subroutine tree_push_back_child_tree( this, val )</line>
        <line t="S" i="344" b="1" n="1"></line>
        <line t="C" i="345" b="1" n="1">! The tree</line>
        <line t="X" i="346" b="1" n="1">  class(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="347" b="1" n="1"></line>
        <line t="C" i="348" b="1" n="1">! The element</line>
        <line t="X" i="349" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="350" b="1" n="1"></line>
        <line t="C" i="351" b="1" n="1">! Invoke the node insertion for the root iterator</line>
        <line t="X" i="352" b="1" n="1">  call this%root%push_back_child( val )</line>
        <line t="X" i="353" b="1" n="1"></line>
        <line t="ES" i="354" b="1" n="1">end subroutine tree_push_back_child_tree</line>
        <line t="ES" i="355" b="1" n="1"></line>
        <line t="ES" i="356" b="1" n="1"></line>
        <line t="C" i="357" b="1" n="1">! Add child node to the end of the children list; include element if present</line>
        <line t="C" i="358" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="359" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="360" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_push_back_child_iterator" t="S" i="361" b="1" n="1">subroutine tree_push_back_child_iterator( iterator, val )</line>
        <line t="S" i="362" b="1" n="1"></line>
        <line t="C" i="363" b="1" n="1">! The node iterator</line>
        <line t="X" i="364" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="365" b="1" n="1"></line>
        <line t="C" i="366" b="1" n="1">! The element</line>
        <line t="X" i="367" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="368" b="1" n="1"></line>
        <line t="C" i="369" b="1" n="1">! Invoke the node insertion for the node pointed by the iterator</line>
        <line t="X" i="370" b="1" n="1">  call iterator%node%push_back_child( val )</line>
        <line t="X" i="371" b="1" n="1"></line>
        <line t="ES" i="372" b="1" n="1">end subroutine tree_push_back_child_iterator</line>
        <line t="ES" i="373" b="1" n="1"></line>
        <line t="ES" i="374" b="1" n="1"></line>
        <line t="C" i="375" b="1" n="1">! Add child node to the end of the children list; include element if present</line>
        <line k="tree_push_back_child_node" t="S" i="376" b="1" n="1">subroutine tree_push_back_child_node( this, val )</line>
        <line t="S" i="377" b="1" n="1"></line>
        <line t="C" i="378" b="1" n="1">! The node</line>
        <line t="X" i="379" b="1" n="1">  class(t_tree_node), target, intent(inout) :: this</line>
        <line t="X" i="380" b="1" n="1"></line>
        <line t="C" i="381" b="1" n="1">! The element</line>
        <line t="X" i="382" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="383" b="1" n="1"></line>
        <line t="C" i="384" b="1" n="1">! Chek if node already contains children</line>
        <line t="X" i="385" b="2" n="2">  if( associated(this%last_child) ) then</line>
        <line t="X" i="386" b="2" n="2"></line>
        <line t="C" i="387" b="2" n="2">!   Allocate child node</line>
        <line t="X" i="388" b="2" n="2">    allocate( this%last_child%next_sibling )</line>
        <line t="X" i="389" b="2" n="2"></line>
        <line t="C" i="390" b="2" n="2">!   Allocate pointers in new node</line>
        <line t="X" i="391" b="2" n="2">    this%last_child%next_sibling%previous_sibling =&gt; this%last_child</line>
        <line t="X" i="392" b="2" n="2">    this%last_child%next_sibling%parent =&gt; this</line>
        <line t="X" i="393" b="2" n="2"></line>
        <line t="C" i="394" b="2" n="2">!   Reassign pointer to last element</line>
        <line t="X" i="395" b="2" n="2">    this%last_child =&gt; this%last_child%next_sibling</line>
        <line t="X" i="396" b="2" n="2"></line>
        <line t="X" i="397" b="3" n="2">  else</line>
        <line t="X" i="398" b="3" n="2"></line>
        <line t="C" i="399" b="3" n="2">!   Allocate child node</line>
        <line t="X" i="400" b="3" n="2">    allocate( this%last_child )</line>
        <line t="X" i="401" b="3" n="2"></line>
        <line t="C" i="402" b="3" n="2">!   Assign pointers</line>
        <line t="X" i="403" b="3" n="2">    this%first_child =&gt; this%last_child</line>
        <line t="X" i="404" b="3" n="2">    this%last_child%parent =&gt; this</line>
        <line t="X" i="405" b="3" n="2"></line>
        <line t="X" i="406" b="3" n="1">  end if</line>
        <line t="X" i="407" b="3" n="1"></line>
        <line t="C" i="408" b="3" n="1">! Copy the element into its node position</line>
        <line t="X" i="409" b="4" n="2">  if( present(val) ) then</line>
        <line t="X" i="410" b="4" n="2">    call element_assign_pointer( this%last_child%element, val )</line>
        <line t="X" i="411" b="4" n="1">  end if</line>
        <line t="X" i="412" b="4" n="1"></line>
        <line t="C" i="413" b="4" n="1">! Increase counter</line>
        <line t="X" i="414" b="4" n="1">  this%children = this%children + 1</line>
        <line t="X" i="415" b="4" n="1"></line>
        <line t="ES" i="416" b="4" n="1">end subroutine tree_push_back_child_node</line>
        <line t="ES" i="417" b="1" n="1"></line>
        <line t="ES" i="418" b="1" n="1"></line>
        <line t="C" i="419" b="1" n="1">! Remove child node at the beginning of the tree root children list</line>
        <line k="tree_pop_front_child_tree" t="S" i="420" b="1" n="1">subroutine tree_pop_front_child_tree( this )</line>
        <line t="S" i="421" b="1" n="1"></line>
        <line t="C" i="422" b="1" n="1">! The tree</line>
        <line t="X" i="423" b="1" n="1">  class(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="424" b="1" n="1"></line>
        <line t="C" i="425" b="1" n="1">! Invoke the removal for the root iterator</line>
        <line t="X" i="426" b="1" n="1">  call this%root%pop_front_child()</line>
        <line t="X" i="427" b="1" n="1"></line>
        <line t="ES" i="428" b="1" n="1">end subroutine tree_pop_front_child_tree</line>
        <line t="ES" i="429" b="1" n="1"></line>
        <line t="ES" i="430" b="1" n="1"></line>
        <line t="C" i="431" b="1" n="1">! Remove child node at the beginning of the children list</line>
        <line t="C" i="432" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="433" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="434" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_pop_front_child_iterator" t="S" i="435" b="1" n="1">subroutine tree_pop_front_child_iterator( iterator )</line>
        <line t="S" i="436" b="1" n="1"></line>
        <line t="C" i="437" b="1" n="1">! The tree iterator</line>
        <line t="X" i="438" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="439" b="1" n="1"></line>
        <line t="C" i="440" b="1" n="1">! Invoke the removal for the root iterator</line>
        <line t="X" i="441" b="1" n="1">  call iterator%node%pop_front_child()</line>
        <line t="X" i="442" b="1" n="1"></line>
        <line t="ES" i="443" b="1" n="1">end subroutine tree_pop_front_child_iterator</line>
        <line t="ES" i="444" b="1" n="1"></line>
        <line t="ES" i="445" b="1" n="1"></line>
        <line t="C" i="446" b="1" n="1">! Remove child node to the beginning of the children list</line>
        <line k="tree_pop_front_child_node" t="S" i="447" b="1" n="1">subroutine tree_pop_front_child_node( this )</line>
        <line t="S" i="448" b="1" n="1"></line>
        <line t="C" i="449" b="1" n="1">! The node</line>
        <line t="X" i="450" b="1" n="1">  class(t_tree_node), intent(inout) :: this</line>
        <line t="X" i="451" b="1" n="1"></line>
        <line t="C" i="452" b="1" n="1">! Check if the node is empty</line>
        <line t="X" i="453" b="2" n="2">  if( associated(this%first_child) ) then</line>
        <line t="X" i="454" b="2" n="2"></line>
        <line t="C" i="455" b="2" n="2">!   Check if there is more than one child node</line>
        <line t="X" i="456" b="3" n="3">    if( associated(this%first_child%next_sibling) ) then</line>
        <line t="X" i="457" b="3" n="3"></line>
        <line t="C" i="458" b="3" n="3">!     Reassign first child pointer</line>
        <line t="X" i="459" b="3" n="3">      this%first_child =&gt; this%first_child%next_sibling</line>
        <line t="X" i="460" b="3" n="3"></line>
        <line t="C" i="461" b="3" n="3">!     Remove the first child node</line>
        <line t="X" i="462" b="3" n="3">      call this%first_child%previous_sibling%clear()</line>
        <line t="X" i="463" b="3" n="3">      this%first_child%previous_sibling =&gt; null()</line>
        <line t="X" i="464" b="3" n="3"></line>
        <line t="X" i="465" b="4" n="3">    else</line>
        <line t="X" i="466" b="4" n="3"></line>
        <line t="C" i="467" b="4" n="3">!     Only one child node; remove it</line>
        <line t="X" i="468" b="4" n="3">      call this%first_child%clear()</line>
        <line t="X" i="469" b="4" n="3"></line>
        <line t="X" i="470" b="4" n="2">    end if</line>
        <line t="X" i="471" b="4" n="2"></line>
        <line t="C" i="472" b="4" n="2">!   Decrease counter</line>
        <line t="X" i="473" b="4" n="2">    this%children = this%children - 1</line>
        <line t="X" i="474" b="4" n="2"></line>
        <line t="X" i="475" b="4" n="1">  end if</line>
        <line t="X" i="476" b="4" n="1"></line>
        <line t="ES" i="477" b="4" n="1">end subroutine tree_pop_front_child_node</line>
        <line t="ES" i="478" b="1" n="1"></line>
        <line t="ES" i="479" b="1" n="1"></line>
        <line t="C" i="480" b="1" n="1">! Remove child node at the beginning of the tree root children list</line>
        <line k="tree_pop_back_child_tree" t="S" i="481" b="1" n="1">subroutine tree_pop_back_child_tree( this )</line>
        <line t="S" i="482" b="1" n="1"></line>
        <line t="C" i="483" b="1" n="1">! The tree</line>
        <line t="X" i="484" b="1" n="1">  class(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="485" b="1" n="1"></line>
        <line t="C" i="486" b="1" n="1">! Invoke the removal for the root iterator</line>
        <line t="X" i="487" b="1" n="1">  call this%root%pop_back_child()</line>
        <line t="X" i="488" b="1" n="1"></line>
        <line t="ES" i="489" b="1" n="1">end subroutine tree_pop_back_child_tree</line>
        <line t="ES" i="490" b="1" n="1"></line>
        <line t="ES" i="491" b="1" n="1"></line>
        <line t="C" i="492" b="1" n="1">! Remove child node at the beginning of the children list</line>
        <line t="C" i="493" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="494" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="495" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_pop_back_child_iterator" t="S" i="496" b="1" n="1">subroutine tree_pop_back_child_iterator( iterator )</line>
        <line t="S" i="497" b="1" n="1"></line>
        <line t="C" i="498" b="1" n="1">! The node iterator</line>
        <line t="X" i="499" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="500" b="1" n="1"></line>
        <line t="C" i="501" b="1" n="1">! Invoke the removal for the root iterator</line>
        <line t="X" i="502" b="1" n="1">  call iterator%node%pop_back_child()</line>
        <line t="X" i="503" b="1" n="1"></line>
        <line t="ES" i="504" b="1" n="1">end subroutine tree_pop_back_child_iterator</line>
        <line t="ES" i="505" b="1" n="1"></line>
        <line t="ES" i="506" b="1" n="1"></line>
        <line t="C" i="507" b="1" n="1">! Remove child node to the end of the children list</line>
        <line k="tree_pop_back_child_node" t="S" i="508" b="1" n="1">subroutine tree_pop_back_child_node( this )</line>
        <line t="S" i="509" b="1" n="1"></line>
        <line t="C" i="510" b="1" n="1">! The node</line>
        <line t="X" i="511" b="1" n="1">  class(t_tree_node), intent(inout) :: this</line>
        <line t="X" i="512" b="1" n="1"></line>
        <line t="C" i="513" b="1" n="1">! Check if the node is empty</line>
        <line t="X" i="514" b="2" n="2">  if( associated(this%last_child) ) then</line>
        <line t="X" i="515" b="2" n="2"></line>
        <line t="C" i="516" b="2" n="2">!   Destroy data element in the last child node</line>
        <line t="X" i="517" b="3" n="3">    if( associated(this%last_child%element) ) then</line>
        <line t="X" i="518" b="3" n="3">      deallocate( this%last_child%element )</line>
        <line t="X" i="519" b="3" n="2">    end if</line>
        <line t="X" i="520" b="3" n="2"></line>
        <line t="C" i="521" b="3" n="2">!   Check if there is more than one child node</line>
        <line t="X" i="522" b="4" n="3">    if( associated(this%last_child%previous_sibling) ) then</line>
        <line t="X" i="523" b="4" n="3"></line>
        <line t="C" i="524" b="4" n="3">!     Reassign last child pointer</line>
        <line t="X" i="525" b="4" n="3">      this%last_child =&gt; this%last_child%previous_sibling</line>
        <line t="X" i="526" b="4" n="3"></line>
        <line t="C" i="527" b="4" n="3">!     Remove the last child node</line>
        <line t="X" i="528" b="4" n="3">      deallocate( this%last_child%next_sibling )</line>
        <line t="X" i="529" b="4" n="3"></line>
        <line t="X" i="530" b="5" n="3">    else</line>
        <line t="X" i="531" b="5" n="3"></line>
        <line t="C" i="532" b="5" n="3">!     Only one child node; remove it</line>
        <line t="X" i="533" b="5" n="3">      deallocate( this%last_child )</line>
        <line t="X" i="534" b="5" n="3">      this%first_child =&gt; null()</line>
        <line t="X" i="535" b="5" n="3"></line>
        <line t="X" i="536" b="5" n="2">    end if</line>
        <line t="X" i="537" b="5" n="2"></line>
        <line t="C" i="538" b="5" n="2">!   Decrease counter</line>
        <line t="X" i="539" b="5" n="2">    this%children = this%children - 1</line>
        <line t="X" i="540" b="5" n="2"></line>
        <line t="X" i="541" b="5" n="1">  end if</line>
        <line t="X" i="542" b="5" n="1"></line>
        <line t="ES" i="543" b="5" n="1">end subroutine tree_pop_back_child_node</line>
        <line t="ES" i="544" b="1" n="1"></line>
        <line t="ES" i="545" b="1" n="1"></line>
        <line t="C" i="546" b="1" n="1">! Add child node to the beginning of the sibling list</line>
        <line t="C" i="547" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="548" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="549" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_push_front_sibling" t="S" i="550" b="1" n="1">subroutine tree_push_front_sibling( iterator, val )</line>
        <line t="S" i="551" b="1" n="1"></line>
        <line t="C" i="552" b="1" n="1">! The node iterator</line>
        <line t="X" i="553" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="554" b="1" n="1"></line>
        <line t="C" i="555" b="1" n="1">! The element</line>
        <line t="X" i="556" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="557" b="1" n="1"></line>
        <line t="C" i="558" b="1" n="1">! Invoke insertion through the parent node</line>
        <line t="X" i="559" b="1" n="1">  call iterator%node%parent%push_front_child( val )</line>
        <line t="X" i="560" b="1" n="1"></line>
        <line t="ES" i="561" b="1" n="1">end subroutine tree_push_front_sibling</line>
        <line t="ES" i="562" b="1" n="1"></line>
        <line t="ES" i="563" b="1" n="1"></line>
        <line t="C" i="564" b="1" n="1">! Add child node to the end of the sibling list</line>
        <line t="C" i="565" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="566" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="567" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_push_back_sibling" t="S" i="568" b="1" n="1">subroutine tree_push_back_sibling( iterator, val )</line>
        <line t="S" i="569" b="1" n="1"></line>
        <line t="C" i="570" b="1" n="1">! The node iterator</line>
        <line t="X" i="571" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="572" b="1" n="1"></line>
        <line t="C" i="573" b="1" n="1">! The element</line>
        <line t="X" i="574" b="1" n="1">  class(xxtypebase__), optional, intent(in) :: val</line>
        <line t="X" i="575" b="1" n="1"></line>
        <line t="C" i="576" b="1" n="1">! Invoke insertion through the node parent</line>
        <line t="X" i="577" b="1" n="1">  call iterator%node%parent%push_back_child( val )</line>
        <line t="X" i="578" b="1" n="1"></line>
        <line t="ES" i="579" b="1" n="1">end subroutine tree_push_back_sibling</line>
        <line t="ES" i="580" b="1" n="1"></line>
        <line t="ES" i="581" b="1" n="1"></line>
        <line t="C" i="582" b="1" n="1">! Remove child node from the beginning of the sibling list</line>
        <line t="C" i="583" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="584" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="585" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_pop_front_sibling" t="S" i="586" b="1" n="1">subroutine tree_pop_front_sibling( iterator )</line>
        <line t="S" i="587" b="1" n="1"></line>
        <line t="C" i="588" b="1" n="1">! The node iterator</line>
        <line t="X" i="589" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="590" b="1" n="1"></line>
        <line t="C" i="591" b="1" n="1">! Invoke deletion through the parent node</line>
        <line t="X" i="592" b="1" n="1">  call iterator%node%parent%pop_front_child()</line>
        <line t="X" i="593" b="1" n="1"></line>
        <line t="ES" i="594" b="1" n="1">end subroutine tree_pop_front_sibling</line>
        <line t="ES" i="595" b="1" n="1"></line>
        <line t="ES" i="596" b="1" n="1"></line>
        <line t="C" i="597" b="1" n="1">! Remove child node from the end of the sibling list</line>
        <line t="C" i="598" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="599" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="600" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_pop_back_sibling" t="S" i="601" b="1" n="1">subroutine tree_pop_back_sibling( iterator )</line>
        <line t="S" i="602" b="1" n="1"></line>
        <line t="C" i="603" b="1" n="1">! The node iterator</line>
        <line t="X" i="604" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="605" b="1" n="1"></line>
        <line t="C" i="606" b="1" n="1">! Invoke insertion through the node parent</line>
        <line t="X" i="607" b="1" n="1">  call iterator%node%parent%pop_back_child()</line>
        <line t="X" i="608" b="1" n="1"></line>
        <line t="ES" i="609" b="1" n="1">end subroutine tree_pop_back_sibling</line>
        <line t="ES" i="610" b="1" n="1"></line>
        <line t="ES" i="611" b="1" n="1"></line>
        <line t="C" i="612" b="1" n="1">! Insert node before node pointed by the iterator</line>
        <line t="C" i="613" b="1" n="1">! Iterator remains associated to input iterator</line>
        <line t="C" i="614" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="615" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="616" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_insert_sibling" t="S" i="617" b="1" n="1">subroutine tree_insert_sibling( iterator, val )</line>
        <line t="S" i="618" b="1" n="1"></line>
        <line t="C" i="619" b="1" n="1">! Iterator to element used as reference for insertion</line>
        <line t="X" i="620" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="621" b="1" n="1"></line>
        <line t="C" i="622" b="1" n="1">! The element</line>
        <line t="X" i="623" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="624" b="1" n="1"></line>
        <line t="C" i="625" b="1" n="1">! Local iterator pointer</line>
        <line t="X" i="626" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="627" b="1" n="1"></line>
        <line t="C" i="628" b="1" n="1">! Allocate new node</line>
        <line t="X" i="629" b="1" n="1">  allocate( node )</line>
        <line t="X" i="630" b="1" n="1"></line>
        <line t="C" i="631" b="1" n="1">! Assign forwar pointers</line>
        <line t="X" i="632" b="2" n="2">  if( associated(iterator%node%previous_sibling) ) then</line>
        <line t="X" i="633" b="2" n="2">    iterator%node%previous_sibling%next_sibling =&gt; node</line>
        <line t="X" i="634" b="3" n="2">  else</line>
        <line t="X" i="635" b="3" n="2">    iterator%node%parent%first_child =&gt; node</line>
        <line t="X" i="636" b="3" n="1">  end if</line>
        <line t="X" i="637" b="3" n="1">  node%next_sibling =&gt; iterator%node</line>
        <line t="X" i="638" b="3" n="1"></line>
        <line t="C" i="639" b="3" n="1">! Assign backward pointers</line>
        <line t="X" i="640" b="3" n="1">  node%previous_sibling =&gt; iterator%node%previous_sibling</line>
        <line t="X" i="641" b="3" n="1">  iterator%node%previous_sibling =&gt; node</line>
        <line t="X" i="642" b="3" n="1"></line>
        <line t="C" i="643" b="3" n="1">! Assign parent pointer</line>
        <line t="X" i="644" b="3" n="1">  node%parent =&gt; iterator%node%parent</line>
        <line t="X" i="645" b="3" n="1"></line>
        <line t="C" i="646" b="3" n="1">! Copy the element into its list position</line>
        <line t="X" i="647" b="3" n="1">  call element_assign_pointer( node%element, val )</line>
        <line t="X" i="648" b="3" n="1"></line>
        <line t="C" i="649" b="3" n="1">! Increase counter</line>
        <line t="X" i="650" b="3" n="1">  iterator%node%parent%children = iterator%node%parent%children + 1</line>
        <line t="X" i="651" b="3" n="1"></line>
        <line t="ES" i="652" b="3" n="1">end subroutine tree_insert_sibling</line>
        <line t="ES" i="653" b="1" n="1"></line>
        <line t="ES" i="654" b="1" n="1"></line>
        <line t="C" i="655" b="1" n="1">! Remove node pointed by the iterator</line>
        <line t="C" i="656" b="1" n="1">! Input pointer returns not associated</line>
        <line t="C" i="657" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="658" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="659" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_erase" t="S" i="660" b="1" n="1"> subroutine tree_erase( iterator )</line>
        <line t="S" i="661" b="1" n="1"></line>
        <line t="C" i="662" b="1" n="1">! Iterator to element to remove</line>
        <line t="X" i="663" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="664" b="1" n="1"></line>
        <line t="C" i="665" b="1" n="1">! Local node pointer</line>
        <line t="X" i="666" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="667" b="1" n="1"></line>
        <line t="C" i="668" b="1" n="1">! Check the node</line>
        <line t="X" i="669" b="2" n="2">  if( associated(iterator%node) ) then</line>
        <line t="X" i="670" b="2" n="2"></line>
        <line t="C" i="671" b="2" n="2">!   Initialise node pointer</line>
        <line t="X" i="672" b="2" n="2">    node =&gt; iterator%node</line>
        <line t="X" i="673" b="2" n="2"></line>
        <line t="C" i="674" b="2" n="2">!   Assign forward pointers</line>
        <line t="X" i="675" b="3" n="3">    if( associated(node%previous_sibling) ) then</line>
        <line t="X" i="676" b="3" n="3">      node%previous_sibling%next_sibling =&gt; node%next_sibling</line>
        <line t="X" i="677" b="4" n="3">    else</line>
        <line t="X" i="678" b="4" n="3">      node%parent%first_child =&gt; node%next_sibling</line>
        <line t="X" i="679" b="4" n="2">    end if</line>
        <line t="X" i="680" b="4" n="2"></line>
        <line t="C" i="681" b="4" n="2">!   Assign backward pointers</line>
        <line t="X" i="682" b="5" n="3">    if( associated(node%next_sibling) ) then</line>
        <line t="X" i="683" b="5" n="3">      node%next_sibling%previous_sibling =&gt; node%previous_sibling</line>
        <line t="X" i="684" b="6" n="3">    else</line>
        <line t="X" i="685" b="6" n="3">      node%parent%last_child =&gt; node%previous_sibling</line>
        <line t="X" i="686" b="6" n="2">    end if</line>
        <line t="X" i="687" b="6" n="2"></line>
        <line t="C" i="688" b="6" n="2">!   Decrease counter</line>
        <line t="X" i="689" b="6" n="2">    node%parent%children = node%parent%children - 1</line>
        <line t="X" i="690" b="6" n="2"></line>
        <line t="C" i="691" b="6" n="2">!   Deallocate list element</line>
        <line t="X" i="692" b="6" n="2">    call node%clear()</line>
        <line t="X" i="693" b="6" n="2">    deallocate( node )</line>
        <line t="X" i="694" b="6" n="2"></line>
        <line t="X" i="695" b="6" n="1">  end if</line>
        <line t="X" i="696" b="6" n="1"></line>
        <line t="ES" i="697" b="6" n="1">end subroutine tree_erase</line>
        <line t="ES" i="698" b="1" n="1"></line>
        <line t="ES" i="699" b="1" n="1"></line>
        <line t="C" i="700" b="1" n="1">! Return iterator to first node in the tree</line>
        <line k="tree_begin_tree" t="F" i="701" b="1" n="1">function tree_begin_tree( this ) result(res)</line>
        <line t="F" i="702" b="1" n="1"></line>
        <line t="C" i="703" b="1" n="1">! The tree</line>
        <line t="X" i="704" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="705" b="1" n="1"></line>
        <line t="C" i="706" b="1" n="1">! Pointer to the root element</line>
        <line t="X" i="707" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="708" b="1" n="1"></line>
        <line t="C" i="709" b="1" n="1">! Assign the iterator pointers</line>
        <line t="X" i="710" b="1" n="1">  res%node =&gt; this%root</line>
        <line t="X" i="711" b="1" n="1">  res%tree =&gt; this</line>
        <line t="X" i="712" b="1" n="1"></line>
        <line t="EF" i="713" b="1" n="1">end function tree_begin_tree</line>
        <line t="EF" i="714" b="1" n="1"></line>
        <line t="EF" i="715" b="1" n="1"></line>
        <line t="C" i="716" b="1" n="1">! Return pointer to last node in the tree</line>
        <line k="tree_end_tree" t="F" i="717" b="1" n="1">function tree_end_tree( this ) result(res)</line>
        <line t="F" i="718" b="1" n="1"></line>
        <line t="C" i="719" b="1" n="1">! The tree</line>
        <line t="X" i="720" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="721" b="1" n="1"></line>
        <line t="C" i="722" b="1" n="1">! Pointer to the root element</line>
        <line t="X" i="723" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="724" b="1" n="1"></line>
        <line t="C" i="725" b="1" n="1">! Local iterator</line>
        <line t="X" i="726" b="1" n="1">  type(t_tree_node), pointer :: it</line>
        <line t="X" i="727" b="1" n="1"></line>
        <line t="C" i="728" b="1" n="1">! Loop in the levels looking for last level in the last list of children</line>
        <line t="X" i="729" b="1" n="1">  it =&gt; this%root</line>
        <line t="X" i="730" b="2" n="2">  do while( associated(it%last_child) )</line>
        <line t="X" i="731" b="2" n="2">    it =&gt; it%last_child</line>
        <line t="X" i="732" b="2" n="1">  end do</line>
        <line t="X" i="733" b="2" n="1"></line>
        <line t="C" i="734" b="2" n="1">! Assign the iterator pointers</line>
        <line t="X" i="735" b="2" n="1">  res%node =&gt; it</line>
        <line t="X" i="736" b="2" n="1">  res%tree =&gt; this</line>
        <line t="X" i="737" b="2" n="1"></line>
        <line t="EF" i="738" b="2" n="1">end function tree_end_tree</line>
        <line t="EF" i="739" b="1" n="1"></line>
        <line t="EF" i="740" b="1" n="1"></line>
        <line t="C" i="741" b="1" n="1">! Return pointer to first child node in the input node</line>
        <line t="C" i="742" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="743" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="744" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_begin_iterator" t="F" i="745" b="1" n="1">function tree_begin_iterator( this, iterator ) result(res)</line>
        <line t="F" i="746" b="1" n="1"></line>
        <line t="C" i="747" b="1" n="1">! The tree</line>
        <line t="X" i="748" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="749" b="1" n="1"></line>
        <line t="C" i="750" b="1" n="1">! The pointer to the node</line>
        <line t="X" i="751" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="752" b="1" n="1"></line>
        <line t="C" i="753" b="1" n="1">! Pointer to the first child in the node</line>
        <line t="X" i="754" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="755" b="1" n="1"></line>
        <line t="C" i="756" b="1" n="1">! Assign the iterator pointers</line>
        <line t="X" i="757" b="1" n="1">  res%node =&gt; iterator%node%first_child</line>
        <line t="X" i="758" b="1" n="1">  res%tree =&gt; this</line>
        <line t="X" i="759" b="1" n="1"></line>
        <line t="EF" i="760" b="1" n="1">end function tree_begin_iterator</line>
        <line t="EF" i="761" b="1" n="1"></line>
        <line t="EF" i="762" b="1" n="1"></line>
        <line t="C" i="763" b="1" n="1">! Return pointer to last child node in the input node</line>
        <line t="C" i="764" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="765" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="766" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_end_iterator" t="F" i="767" b="1" n="1">function tree_end_iterator( this, iterator ) result(res)</line>
        <line t="F" i="768" b="1" n="1"></line>
        <line t="C" i="769" b="1" n="1">! The tree</line>
        <line t="X" i="770" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="771" b="1" n="1"></line>
        <line t="C" i="772" b="1" n="1">! The pointer to the node</line>
        <line t="X" i="773" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), target, intent(in) :: iterator</line>
        <line t="X" i="774" b="1" n="1"></line>
        <line t="C" i="775" b="1" n="1">! Pointer to the first child in the node</line>
        <line t="X" i="776" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="777" b="1" n="1"></line>
        <line t="C" i="778" b="1" n="1">! Assign the iterator pointers</line>
        <line t="X" i="779" b="1" n="1">  res%node =&gt; iterator%node%last_child</line>
        <line t="X" i="780" b="1" n="1">  res%tree =&gt; this</line>
        <line t="X" i="781" b="1" n="1"></line>
        <line t="EF" i="782" b="1" n="1">end function tree_end_iterator</line>
        <line t="EF" i="783" b="1" n="1"></line>
        <line t="EF" i="784" b="1" n="1"></line>
        <line t="C" i="785" b="1" n="1">! Return pointer to next node in the tree</line>
        <line k="tree_next_tree_node" t="F" i="786" b="1" n="1">function tree_next_tree_node( this ) result(res)</line>
        <line t="F" i="787" b="1" n="1"></line>
        <line t="C" i="788" b="1" n="1">! The tree iterator</line>
        <line t="X" i="789" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="790" b="1" n="1"></line>
        <line t="C" i="791" b="1" n="1">! The output iterator</line>
        <line t="X" i="792" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="793" b="1" n="1"></line>
        <line t="C" i="794" b="1" n="1">! Local node pointer</line>
        <line t="X" i="795" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="796" b="1" n="1"></line>
        <line t="C" i="797" b="1" n="1">! Initialise node pointer</line>
        <line t="X" i="798" b="1" n="1">  node =&gt; this%node</line>
        <line t="X" i="799" b="1" n="1"></line>
        <line t="C" i="800" b="1" n="1">! Select the navigation path</line>
        <line t="X" i="801" b="2" n="2">  if( associated(node%first_child) ) then</line>
        <line t="X" i="802" b="2" n="2"></line>
        <line t="C" i="803" b="2" n="2">!   The first to node to navigate is the first child</line>
        <line t="X" i="804" b="2" n="2">    res%node =&gt; node%first_child</line>
        <line t="X" i="805" b="2" n="2"></line>
        <line t="X" i="806" b="3" n="2">  else</line>
        <line t="X" i="807" b="3" n="2"></line>
        <line t="C" i="808" b="3" n="2">!   Check if there is a next sibling</line>
        <line t="X" i="809" b="4" n="3">    if( associated( node%next_sibling ) ) then</line>
        <line t="X" i="810" b="4" n="3"></line>
        <line t="C" i="811" b="4" n="3">!     Next item is sibling</line>
        <line t="X" i="812" b="4" n="3">      res%node =&gt; node%next_sibling</line>
        <line t="X" i="813" b="4" n="3"></line>
        <line t="X" i="814" b="5" n="3">    else</line>
        <line t="X" i="815" b="5" n="3"></line>
        <line t="C" i="816" b="5" n="3">!     This level is exhausted; move up</line>
        <line t="X" i="817" b="5" n="3">      res%node =&gt; node%next_tree_node_up()</line>
        <line t="X" i="818" b="5" n="3"></line>
        <line t="X" i="819" b="5" n="2">    end if</line>
        <line t="X" i="820" b="5" n="2"></line>
        <line t="X" i="821" b="5" n="1">  end if</line>
        <line t="X" i="822" b="5" n="1"></line>
        <line t="C" i="823" b="5" n="1">! Complte the return iterator</line>
        <line t="X" i="824" b="5" n="1">  res%tree =&gt; this%tree</line>
        <line t="X" i="825" b="5" n="1"></line>
        <line t="EF" i="826" b="5" n="1">end function tree_next_tree_node</line>
        <line t="EF" i="827" b="1" n="1"></line>
        <line t="EF" i="828" b="1" n="1"></line>
        <line t="C" i="829" b="1" n="1">! Navigate the tree forward from an exhausted level upwards in the hierarchy</line>
        <line t="C" i="830" b="1" n="1">! When a level is exhausted, the next node is</line>
        <line t="C" i="831" b="1" n="1">!   - either a sibling of an already navigated node</line>
        <line t="C" i="832" b="1" n="1">!   - or the root and then the navigation is finished</line>
        <line k="tree_next_tree_node_up" t="F" i="833" b="1" n="1">function tree_next_tree_node_up( this ) result(res)</line>
        <line t="F" i="834" b="1" n="1"></line>
        <line t="C" i="835" b="1" n="1">! The tree iterator</line>
        <line t="X" i="836" b="1" n="1">  class(t_tree_node), target :: this</line>
        <line t="X" i="837" b="1" n="1"></line>
        <line t="C" i="838" b="1" n="1">! The output iterator</line>
        <line t="X" i="839" b="1" n="1">  type(t_tree_node), pointer :: res</line>
        <line t="X" i="840" b="1" n="1"></line>
        <line t="C" i="841" b="1" n="1">! Local iterator</line>
        <line t="X" i="842" b="1" n="1">  type(t_tree_node), pointer :: it</line>
        <line t="X" i="843" b="1" n="1"></line>
        <line t="C" i="844" b="1" n="1">! Look for the next node</line>
        <line t="X" i="845" b="1" n="1">  it =&gt; this</line>
        <line t="X" i="846" b="2" n="2">  do</line>
        <line t="X" i="847" b="2" n="2"></line>
        <line t="C" i="848" b="2" n="2">!   Check if already at root (null parent)</line>
        <line t="X" i="849" b="3" n="3">    if( associated(it%parent) ) then</line>
        <line t="X" i="850" b="3" n="3"></line>
        <line t="C" i="851" b="3" n="3">!     Check if parent has sibling at next</line>
        <line t="X" i="852" b="4" n="4">      if( associated(it%parent%next_sibling) ) then</line>
        <line t="X" i="853" b="4" n="4"></line>
        <line t="C" i="854" b="4" n="4">!       This is the next node</line>
        <line t="X" i="855" b="4" n="4">        res =&gt; it%parent%next_sibling</line>
        <line t="X" i="856" b="4" n="4">        exit</line>
        <line t="X" i="857" b="4" n="4"></line>
        <line t="X" i="858" b="5" n="4">      else</line>
        <line t="X" i="859" b="5" n="4"></line>
        <line t="C" i="860" b="5" n="4">!       Continue moving upwards</line>
        <line t="X" i="861" b="5" n="4">        it =&gt; it%parent</line>
        <line t="X" i="862" b="5" n="4"></line>
        <line t="X" i="863" b="5" n="3">      end if</line>
        <line t="X" i="864" b="5" n="3"></line>
        <line t="X" i="865" b="6" n="3">    else</line>
        <line t="X" i="866" b="6" n="3"></line>
        <line t="C" i="867" b="6" n="3">!     At root level; finish navigation</line>
        <line t="X" i="868" b="6" n="3">      res =&gt; null()</line>
        <line t="X" i="869" b="6" n="3">      exit</line>
        <line t="X" i="870" b="6" n="3"></line>
        <line t="X" i="871" b="6" n="2">    end if</line>
        <line t="X" i="872" b="6" n="2"></line>
        <line t="X" i="873" b="6" n="1">  end do</line>
        <line t="X" i="874" b="6" n="1"></line>
        <line t="EF" i="875" b="6" n="1">end function tree_next_tree_node_up</line>
        <line t="EF" i="876" b="1" n="1"></line>
        <line t="EF" i="877" b="1" n="1"></line>
        <line t="C" i="878" b="1" n="1">! Return pointer to previous node in the tree</line>
        <line k="tree_previous_node" t="F" i="879" b="1" n="1">function tree_previous_node( this ) result(res)</line>
        <line t="F" i="880" b="1" n="1"></line>
        <line t="C" i="881" b="1" n="1">! The tree iterator</line>
        <line t="X" i="882" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="883" b="1" n="1"></line>
        <line t="C" i="884" b="1" n="1">! The output iterator</line>
        <line t="X" i="885" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="886" b="1" n="1"></line>
        <line t="C" i="887" b="1" n="1">! Local node pointer</line>
        <line t="X" i="888" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="889" b="1" n="1"></line>
        <line t="C" i="890" b="1" n="1">! Initialise node pointer</line>
        <line t="X" i="891" b="1" n="1">  node =&gt; this%node</line>
        <line t="X" i="892" b="1" n="1"></line>
        <line t="C" i="893" b="1" n="1">! Select the navigation path</line>
        <line t="X" i="894" b="2" n="2">  if( associated( node%previous_sibling ) ) then</line>
        <line t="X" i="895" b="2" n="2"></line>
        <line t="C" i="896" b="2" n="2">!   There is a sibling at prev; try to navigate its children first</line>
        <line t="X" i="897" b="3" n="3">    if( associated(node%previous_sibling%last_child) ) then</line>
        <line t="X" i="898" b="3" n="3"></line>
        <line t="C" i="899" b="3" n="3">!     The first to node to navigate is the last child in the</line>
        <line t="C" i="900" b="3" n="3">!     deepest level hanging from the sibling at prev</line>
        <line t="X" i="901" b="3" n="3">      res%node =&gt; node%previous_sibling%last_child</line>
        <line t="X" i="902" b="4" n="4">      do while( associated(res%node%last_child) )</line>
        <line t="X" i="903" b="4" n="4">        res%node =&gt; res%node%last_child</line>
        <line t="X" i="904" b="4" n="3">      end do</line>
        <line t="X" i="905" b="4" n="3"></line>
        <line t="X" i="906" b="5" n="3">    else</line>
        <line t="X" i="907" b="5" n="3"></line>
        <line t="C" i="908" b="5" n="3">!     There are no children in sibling at prev; navigate sibling itself</line>
        <line t="X" i="909" b="5" n="3">      res%node =&gt; node%previous_sibling</line>
        <line t="X" i="910" b="5" n="3"></line>
        <line t="X" i="911" b="5" n="2">    end if</line>
        <line t="X" i="912" b="5" n="2"></line>
        <line t="X" i="913" b="6" n="2">  else</line>
        <line t="X" i="914" b="6" n="2"></line>
        <line t="C" i="915" b="6" n="2">!   This level is exhausted; move up</line>
        <line t="X" i="916" b="6" n="2">    res%node =&gt; node%parent</line>
        <line t="X" i="917" b="6" n="2"></line>
        <line t="X" i="918" b="6" n="1">  end if</line>
        <line t="X" i="919" b="6" n="1"></line>
        <line t="C" i="920" b="6" n="1">! Complte the return iterator</line>
        <line t="X" i="921" b="6" n="1">  res%tree =&gt; this%tree</line>
        <line t="X" i="922" b="6" n="1"></line>
        <line t="EF" i="923" b="6" n="1">end function tree_previous_node</line>
        <line t="EF" i="924" b="1" n="1"></line>
        <line t="EF" i="925" b="1" n="1"></line>
        <line t="C" i="926" b="1" n="1">! Return the association status of an iterator</line>
        <line t="C" i="927" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="928" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="929" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_associated" t="F" i="930" b="1" n="1">pure function tree_associated( this, other ) result(res)</line>
        <line t="F" i="931" b="1" n="1"></line>
        <line t="C" i="932" b="1" n="1">! The node iterator</line>
        <line t="X" i="933" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="934" b="1" n="1"></line>
        <line t="C" i="935" b="1" n="1">! The node iterator (optional association check)</line>
        <line t="X" i="936" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), optional, intent(in) :: other</line>
        <line t="X" i="937" b="1" n="1"></line>
        <line t="C" i="938" b="1" n="1">! The association status</line>
        <line t="X" i="939" b="1" n="1">  logical :: res</line>
        <line t="X" i="940" b="1" n="1"></line>
        <line t="C" i="941" b="1" n="1">! Return the association status</line>
        <line t="X" i="942" b="2" n="2">  if( present(other) ) then</line>
        <line t="X" i="943" b="2" n="2">    res = associated( this%node, other%node )</line>
        <line t="X" i="944" b="3" n="2">  else</line>
        <line t="X" i="945" b="3" n="2">    res = associated( this%node )</line>
        <line t="X" i="946" b="3" n="1">  end if</line>
        <line t="X" i="947" b="3" n="1"></line>
        <line t="EF" i="948" b="3" n="1">end function tree_associated</line>
        <line t="EF" i="949" b="1" n="1"></line>
        <line t="EF" i="950" b="1" n="1"></line>
        <line t="C" i="951" b="1" n="1">! Nullify an iterator</line>
        <line k="tree_nullify" t="S" i="952" b="1" n="1">subroutine tree_nullify( this )</line>
        <line t="S" i="953" b="1" n="1"></line>
        <line t="C" i="954" b="1" n="1">! The tree iterator</line>
        <line t="X" i="955" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: this</line>
        <line t="X" i="956" b="1" n="1"></line>
        <line t="C" i="957" b="1" n="1">! Nullify pointer</line>
        <line t="X" i="958" b="1" n="1">  this%node =&gt; null()</line>
        <line t="X" i="959" b="1" n="1"></line>
        <line t="ES" i="960" b="1" n="1">end subroutine tree_nullify</line>
        <line t="ES" i="961" b="1" n="1"></line>
        <line t="ES" i="962" b="1" n="1"></line>
        <line t="C" i="963" b="1" n="1">! Return pointer to first sibling node to the input node</line>
        <line t="C" i="964" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="965" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="966" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_begin_sibling" t="F" i="967" b="1" n="1">function tree_begin_sibling( this, iterator ) result(res)</line>
        <line t="F" i="968" b="1" n="1"></line>
        <line t="C" i="969" b="1" n="1">! The tree</line>
        <line t="X" i="970" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="971" b="1" n="1"></line>
        <line t="C" i="972" b="1" n="1">! The pointer to the node</line>
        <line t="X" i="973" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="974" b="1" n="1"></line>
        <line t="C" i="975" b="1" n="1">! Pointer to the first child in the node</line>
        <line t="X" i="976" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="977" b="1" n="1"></line>
        <line t="C" i="978" b="1" n="1">! Local variables</line>
        <line t="X" i="979" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: parit</line>
        <line t="X" i="980" b="1" n="1"></line>
        <line t="C" i="981" b="1" n="1">! Get the parent</line>
        <line t="X" i="982" b="1" n="1">  parit = iterator%parent()</line>
        <line t="X" i="983" b="2" n="2">  if( parit%associated() ) then</line>
        <line t="X" i="984" b="2" n="2"></line>
        <line t="C" i="985" b="2" n="2">!   Assign the iterator pointers</line>
        <line t="X" i="986" b="2" n="2">    res%node =&gt; iterator%node%parent%first_child</line>
        <line t="X" i="987" b="2" n="2">    res%tree =&gt; this</line>
        <line t="X" i="988" b="2" n="2"></line>
        <line t="X" i="989" b="3" n="2">  else</line>
        <line t="X" i="990" b="3" n="2"></line>
        <line t="C" i="991" b="3" n="2">!   Parent is null; this occurs at root element only</line>
        <line t="C" i="992" b="3" n="2">!   This is just a protection; in general code is not reachable</line>
        <line t="X" i="993" b="3" n="2">    res%node =&gt; null()</line>
        <line t="X" i="994" b="3" n="2">    res%tree =&gt; null()</line>
        <line t="X" i="995" b="3" n="2"></line>
        <line t="X" i="996" b="3" n="1">  end if</line>
        <line t="X" i="997" b="3" n="1"></line>
        <line t="EF" i="998" b="3" n="1">end function tree_begin_sibling</line>
        <line t="EF" i="999" b="1" n="1"></line>
        <line t="EF" i="1000" b="1" n="1"></line>
        <line t="C" i="1001" b="1" n="1">! Return pointer to last sibling node to the input node</line>
        <line t="C" i="1002" b="1" n="1">! This interface is also designed to allow inheritance of the tree type</line>
        <line t="C" i="1003" b="1" n="1">! and then to extend also the tree_iterator type such that the derived tree type</line>
        <line t="C" i="1004" b="1" n="1">! can invoke this method with the derivied tree_iterator type</line>
        <line k="tree_end_sibling" t="F" i="1005" b="1" n="1">function tree_end_sibling( this, iterator ) result(res)</line>
        <line t="F" i="1006" b="1" n="1"></line>
        <line t="C" i="1007" b="1" n="1">! The tree</line>
        <line t="X" i="1008" b="1" n="1">  class(xxtypebase___tree_ftl), target, intent(in) :: this</line>
        <line t="X" i="1009" b="1" n="1"></line>
        <line t="C" i="1010" b="1" n="1">! The pointer to the node</line>
        <line t="X" i="1011" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: iterator</line>
        <line t="X" i="1012" b="1" n="1"></line>
        <line t="C" i="1013" b="1" n="1">! Pointer to the first child in the node</line>
        <line t="X" i="1014" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="1015" b="1" n="1"></line>
        <line t="C" i="1016" b="1" n="1">! Local variables</line>
        <line t="X" i="1017" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: parit</line>
        <line t="X" i="1018" b="1" n="1"></line>
        <line t="C" i="1019" b="1" n="1">! Get the parent</line>
        <line t="X" i="1020" b="1" n="1">  parit = iterator%parent()</line>
        <line t="X" i="1021" b="2" n="2">  if( parit%associated() ) then</line>
        <line t="X" i="1022" b="2" n="2"></line>
        <line t="C" i="1023" b="2" n="2">!   Assign the iterator pointers</line>
        <line t="X" i="1024" b="2" n="2">    res%node =&gt; iterator%node%parent%last_child</line>
        <line t="X" i="1025" b="2" n="2">    res%tree =&gt; this</line>
        <line t="X" i="1026" b="2" n="2"></line>
        <line t="X" i="1027" b="3" n="2">  else</line>
        <line t="X" i="1028" b="3" n="2"></line>
        <line t="C" i="1029" b="3" n="2">!   Parent is null; this occurs at root element only</line>
        <line t="C" i="1030" b="3" n="2">!   This is just a protection; in general code is not reachable</line>
        <line t="X" i="1031" b="3" n="2">    res%node =&gt; null()</line>
        <line t="X" i="1032" b="3" n="2">    res%tree =&gt; null()</line>
        <line t="X" i="1033" b="3" n="1">  end if</line>
        <line t="X" i="1034" b="3" n="1"></line>
        <line t="EF" i="1035" b="3" n="1">end function tree_end_sibling</line>
        <line t="EF" i="1036" b="1" n="1"></line>
        <line t="EF" i="1037" b="1" n="1"></line>
        <line t="C" i="1038" b="1" n="1">! Return pointer to next sibling node</line>
        <line k="tree_next_sibling" t="F" i="1039" b="1" n="1">function tree_next_sibling( this ) result(res)</line>
        <line t="F" i="1040" b="1" n="1"></line>
        <line t="C" i="1041" b="1" n="1">! The tree iterator</line>
        <line t="X" i="1042" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), target, intent(in) :: this</line>
        <line t="X" i="1043" b="1" n="1"></line>
        <line t="C" i="1044" b="1" n="1">! The output iterator</line>
        <line t="X" i="1045" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="1046" b="1" n="1"></line>
        <line t="C" i="1047" b="1" n="1">! Assign iterator pointers</line>
        <line t="X" i="1048" b="1" n="1">  res%node =&gt; this%node%next_sibling</line>
        <line t="X" i="1049" b="1" n="1">  res%tree =&gt; this%tree</line>
        <line t="X" i="1050" b="1" n="1"></line>
        <line t="EF" i="1051" b="1" n="1">end function tree_next_sibling</line>
        <line t="EF" i="1052" b="1" n="1"></line>
        <line t="EF" i="1053" b="1" n="1"></line>
        <line t="C" i="1054" b="1" n="1">! Return pointer to previous sibling node</line>
        <line k="tree_previous_sibling" t="F" i="1055" b="1" n="1">function tree_previous_sibling( this ) result(res)</line>
        <line t="F" i="1056" b="1" n="1"></line>
        <line t="C" i="1057" b="1" n="1">! The tree iterator</line>
        <line t="X" i="1058" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), target, intent(in) :: this</line>
        <line t="X" i="1059" b="1" n="1"></line>
        <line t="C" i="1060" b="1" n="1">! The output iterator</line>
        <line t="X" i="1061" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="1062" b="1" n="1"></line>
        <line t="C" i="1063" b="1" n="1">! Assign iterator pointers</line>
        <line t="X" i="1064" b="1" n="1">  res%node =&gt; this%node%previous_sibling</line>
        <line t="X" i="1065" b="1" n="1">  res%tree =&gt; this%tree</line>
        <line t="X" i="1066" b="1" n="1"></line>
        <line t="EF" i="1067" b="1" n="1">end function tree_previous_sibling</line>
        <line t="EF" i="1068" b="1" n="1"></line>
        <line t="EF" i="1069" b="1" n="1"></line>
        <line t="C" i="1070" b="1" n="1">! Return whether a node has data</line>
        <line k="tree_has_data" t="F" i="1071" b="1" n="1">pure function tree_has_data( this ) result(res)</line>
        <line t="F" i="1072" b="1" n="1"></line>
        <line t="C" i="1073" b="1" n="1">! The iterator</line>
        <line t="X" i="1074" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1075" b="1" n="1"></line>
        <line t="C" i="1076" b="1" n="1">! The data contents flag (true if node contains data element)</line>
        <line t="X" i="1077" b="1" n="1">  logical :: res</line>
        <line t="X" i="1078" b="1" n="1"></line>
        <line t="C" i="1079" b="1" n="1">! Return the status</line>
        <line t="X" i="1080" b="1" n="1">  res = associated(this%node%element)</line>
        <line t="X" i="1081" b="1" n="1"></line>
        <line t="EF" i="1082" b="1" n="1">end function tree_has_data</line>
        <line t="EF" i="1083" b="1" n="1"></line>
        <line t="EF" i="1084" b="1" n="1"></line>
        <line t="C" i="1085" b="1" n="1">! Get a copy of the data elememnt pointed by the iterator</line>
        <line k="tree_iterator_get_element" t="F" i="1086" b="1" n="1">function tree_iterator_get_element( this ) result(res)</line>
        <line t="F" i="1087" b="1" n="1"></line>
        <line t="C" i="1088" b="1" n="1">! The iterator</line>
        <line t="X" i="1089" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1090" b="1" n="1"></line>
        <line t="C" i="1091" b="1" n="1">! The returned element</line>
        <line t="X" i="1092" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="1093" b="1" n="1"></line>
        <line t="C" i="1094" b="1" n="1">! Assign result</line>
        <line t="X" i="1095" b="1" n="1">  call element_assign_allocatable( res, this%node%element )</line>
        <line t="X" i="1096" b="1" n="1"></line>
        <line t="EF" i="1097" b="1" n="1">end function tree_iterator_get_element</line>
        <line t="EF" i="1098" b="1" n="1"></line>
        <line t="EF" i="1099" b="1" n="1"></line>
        <line t="C" i="1100" b="1" n="1">! Get a pointer to the data elememnt pointed by the iterator</line>
        <line k="tree_iterator_get_element_ptr" t="F" i="1101" b="1" n="1">function tree_iterator_get_element_ptr( this ) result(res)</line>
        <line t="F" i="1102" b="1" n="1"></line>
        <line t="C" i="1103" b="1" n="1">! The iterator</line>
        <line t="X" i="1104" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1105" b="1" n="1"></line>
        <line t="C" i="1106" b="1" n="1">! The returned element</line>
        <line t="X" i="1107" b="1" n="1">  class(xxtypebase__), pointer :: res</line>
        <line t="X" i="1108" b="1" n="1"></line>
        <line t="C" i="1109" b="1" n="1">! Assign result</line>
        <line t="X" i="1110" b="1" n="1">  res =&gt; this%node%element</line>
        <line t="X" i="1111" b="1" n="1"></line>
        <line t="EF" i="1112" b="1" n="1">end function tree_iterator_get_element_ptr</line>
        <line t="EF" i="1113" b="1" n="1"></line>
        <line t="EF" i="1114" b="1" n="1"></line>
        <line t="C" i="1115" b="1" n="1">! Set the value pointed by the iterator</line>
        <line k="tree_element_to_iterator" t="S" i="1116" b="1" n="1">subroutine tree_element_to_iterator( this, val )</line>
        <line t="S" i="1117" b="1" n="1"></line>
        <line t="C" i="1118" b="1" n="1">! The iterator</line>
        <line t="X" i="1119" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: this</line>
        <line t="X" i="1120" b="1" n="1"></line>
        <line t="C" i="1121" b="1" n="1">! The element to be assigned</line>
        <line t="X" i="1122" b="1" n="1">  class(xxtypebase__), intent(in) :: val</line>
        <line t="X" i="1123" b="1" n="1"></line>
        <line t="C" i="1124" b="1" n="1">! Check element allocation status</line>
        <line t="X" i="1125" b="1" n="1">  call element_assign_pointer( this%node%element, val )</line>
        <line t="X" i="1126" b="1" n="1"></line>
        <line t="ES" i="1127" b="1" n="1">end subroutine tree_element_to_iterator</line>
        <line t="ES" i="1128" b="1" n="1"></line>
        <line t="ES" i="1129" b="1" n="1"></line>
        <line t="C" i="1130" b="1" n="1">! First element in the tree</line>
        <line k="tree_front" t="F" i="1131" b="1" n="1">function tree_front( this ) result(res)</line>
        <line t="F" i="1132" b="1" n="1"></line>
        <line t="C" i="1133" b="1" n="1">! The tree</line>
        <line t="X" i="1134" b="1" n="1">  class(xxtypebase___tree_ftl), intent(in) :: this</line>
        <line t="X" i="1135" b="1" n="1"></line>
        <line t="C" i="1136" b="1" n="1">! Pointer to first element in The tree</line>
        <line t="X" i="1137" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="1138" b="1" n="1"></line>
        <line t="C" i="1139" b="1" n="1">! Assign the return value</line>
        <line t="X" i="1140" b="1" n="1">  call element_assign_allocatable( res, this%root%element )</line>
        <line t="X" i="1141" b="1" n="1"></line>
        <line t="EF" i="1142" b="1" n="1">end function tree_front</line>
        <line t="EF" i="1143" b="1" n="1"></line>
        <line t="EF" i="1144" b="1" n="1"></line>
        <line t="C" i="1145" b="1" n="1">! Last element in The tree</line>
        <line k="tree_back" t="F" i="1146" b="1" n="1">function tree_back( this ) result(res)</line>
        <line t="F" i="1147" b="1" n="1"></line>
        <line t="C" i="1148" b="1" n="1">! The tree</line>
        <line t="X" i="1149" b="1" n="1">  class(xxtypebase___tree_ftl), intent(in) :: this</line>
        <line t="X" i="1150" b="1" n="1"></line>
        <line t="C" i="1151" b="1" n="1">! Pointer to first element in the tree</line>
        <line t="X" i="1152" b="1" n="1">  class(xxtypebase__), allocatable :: res</line>
        <line t="X" i="1153" b="1" n="1"></line>
        <line t="C" i="1154" b="1" n="1">! Local iterator</line>
        <line t="X" i="1155" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: iterator</line>
        <line t="X" i="1156" b="1" n="1"></line>
        <line t="C" i="1157" b="1" n="1">! Assign the return value</line>
        <line t="X" i="1158" b="1" n="1">  iterator = this%end()</line>
        <line t="X" i="1159" b="1" n="1">  call element_assign_allocatable( res, iterator%node%element )</line>
        <line t="X" i="1160" b="1" n="1"></line>
        <line t="EF" i="1161" b="1" n="1">end function tree_back</line>
        <line t="EF" i="1162" b="1" n="1"></line>
        <line t="EF" i="1163" b="1" n="1"></line>
        <line t="C" i="1164" b="1" n="1">! Return empty status of tree</line>
        <line k="tree_empty_tree" t="F" i="1165" b="1" n="1">pure function tree_empty_tree( this ) result(res)</line>
        <line t="F" i="1166" b="1" n="1"></line>
        <line t="C" i="1167" b="1" n="1">! The tree</line>
        <line t="X" i="1168" b="1" n="1">  class(xxtypebase___tree_ftl), intent(in) :: this</line>
        <line t="X" i="1169" b="1" n="1"></line>
        <line t="C" i="1170" b="1" n="1">! The tree empty status</line>
        <line t="X" i="1171" b="1" n="1">  logical :: res</line>
        <line t="X" i="1172" b="1" n="1"></line>
        <line t="C" i="1173" b="1" n="1">! Assing the return value</line>
        <line t="X" i="1174" b="1" n="1">  res = this%root%empty_node()</line>
        <line t="X" i="1175" b="1" n="1"></line>
        <line t="EF" i="1176" b="1" n="1">end function tree_empty_tree</line>
        <line t="EF" i="1177" b="1" n="1"></line>
        <line t="EF" i="1178" b="1" n="1"></line>
        <line t="C" i="1179" b="1" n="1">! Return empty status of node</line>
        <line k="tree_empty_iterator" t="F" i="1180" b="1" n="1">pure function tree_empty_iterator( this ) result(res)</line>
        <line t="F" i="1181" b="1" n="1"></line>
        <line t="C" i="1182" b="1" n="1">! The node iterator</line>
        <line t="X" i="1183" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1184" b="1" n="1"></line>
        <line t="C" i="1185" b="1" n="1">! The node empty status</line>
        <line t="X" i="1186" b="1" n="1">  logical :: res</line>
        <line t="X" i="1187" b="1" n="1"></line>
        <line t="C" i="1188" b="1" n="1">! Assing the return value</line>
        <line t="X" i="1189" b="1" n="1">  res = this%node%empty_node()</line>
        <line t="X" i="1190" b="1" n="1"></line>
        <line t="EF" i="1191" b="1" n="1">end function tree_empty_iterator</line>
        <line t="EF" i="1192" b="1" n="1"></line>
        <line t="EF" i="1193" b="1" n="1"></line>
        <line t="C" i="1194" b="1" n="1">! Return empty status of node</line>
        <line k="tree_empty_node" t="F" i="1195" b="1" n="1">pure function tree_empty_node( this ) result(res)</line>
        <line t="F" i="1196" b="1" n="1"></line>
        <line t="C" i="1197" b="1" n="1">! The node iterator</line>
        <line t="X" i="1198" b="1" n="1">  class(t_tree_node), intent(in) :: this</line>
        <line t="X" i="1199" b="1" n="1"></line>
        <line t="C" i="1200" b="1" n="1">! The node empty status</line>
        <line t="X" i="1201" b="1" n="1">  logical :: res</line>
        <line t="X" i="1202" b="1" n="1"></line>
        <line t="C" i="1203" b="1" n="1">! Assing the return value</line>
        <line t="X" i="1204" b="1" n="1">  res = ( this%children == 0 .and. .not. associated(this%element) )</line>
        <line t="X" i="1205" b="1" n="1"></line>
        <line t="EF" i="1206" b="1" n="1">end function tree_empty_node</line>
        <line t="EF" i="1207" b="1" n="1"></line>
        <line t="EF" i="1208" b="1" n="1"></line>
        <line t="C" i="1209" b="1" n="1">! Return whether node has children</line>
        <line k="tree_has_children" t="F" i="1210" b="1" n="1">pure function tree_has_children( this ) result(res)</line>
        <line t="F" i="1211" b="1" n="1"></line>
        <line t="C" i="1212" b="1" n="1">! The node iterator</line>
        <line t="X" i="1213" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1214" b="1" n="1"></line>
        <line t="C" i="1215" b="1" n="1">! The children presence status</line>
        <line t="X" i="1216" b="1" n="1">  logical :: res</line>
        <line t="X" i="1217" b="1" n="1"></line>
        <line t="C" i="1218" b="1" n="1">! Assing the return value</line>
        <line t="X" i="1219" b="1" n="1">  res = ( this%node%children /= 0 )</line>
        <line t="X" i="1220" b="1" n="1"></line>
        <line t="EF" i="1221" b="1" n="1">end function tree_has_children</line>
        <line t="EF" i="1222" b="1" n="1"></line>
        <line t="EF" i="1223" b="1" n="1"></line>
        <line t="C" i="1224" b="1" n="1">! Return whether node has siblings</line>
        <line k="tree_has_siblings" t="F" i="1225" b="1" n="1">pure function tree_has_siblings( this ) result(res)</line>
        <line t="F" i="1226" b="1" n="1"></line>
        <line t="C" i="1227" b="1" n="1">! The node iterator</line>
        <line t="X" i="1228" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1229" b="1" n="1"></line>
        <line t="C" i="1230" b="1" n="1">! The sibling presence status</line>
        <line t="X" i="1231" b="1" n="1">  logical :: res</line>
        <line t="X" i="1232" b="1" n="1"></line>
        <line t="C" i="1233" b="1" n="1">! Check parent association</line>
        <line t="X" i="1234" b="2" n="2">  if( associated(this%node%parent) ) then</line>
        <line t="X" i="1235" b="2" n="2"></line>
        <line t="C" i="1236" b="2" n="2">!   Assign the return value (self does not count as sibling)</line>
        <line t="X" i="1237" b="2" n="2">    res = ( this%node%parent%children &gt; 1 )</line>
        <line t="X" i="1238" b="2" n="2"></line>
        <line t="X" i="1239" b="3" n="2">  else</line>
        <line t="X" i="1240" b="3" n="2"></line>
        <line t="C" i="1241" b="3" n="2">!   Parent node; no siblings</line>
        <line t="X" i="1242" b="3" n="2">    res = .false.</line>
        <line t="X" i="1243" b="3" n="2"></line>
        <line t="X" i="1244" b="3" n="1">  end if</line>
        <line t="X" i="1245" b="3" n="1"></line>
        <line t="EF" i="1246" b="3" n="1">end function tree_has_siblings</line>
        <line t="EF" i="1247" b="1" n="1"></line>
        <line t="EF" i="1248" b="1" n="1"></line>
        <line t="C" i="1249" b="1" n="1">! Return the number of children in a node</line>
        <line k="tree_children" t="F" i="1250" b="1" n="1">pure function tree_children( this ) result(res)</line>
        <line t="F" i="1251" b="1" n="1"></line>
        <line t="C" i="1252" b="1" n="1">! The node iterator</line>
        <line t="X" i="1253" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1254" b="1" n="1"></line>
        <line t="C" i="1255" b="1" n="1">! The number of children</line>
        <line t="X" i="1256" b="1" n="1">  integer :: res</line>
        <line t="X" i="1257" b="1" n="1"></line>
        <line t="C" i="1258" b="1" n="1">! Assing the return value</line>
        <line t="X" i="1259" b="1" n="1">  res = this%node%children</line>
        <line t="X" i="1260" b="1" n="1"></line>
        <line t="EF" i="1261" b="1" n="1">end function tree_children</line>
        <line t="EF" i="1262" b="1" n="1"></line>
        <line t="EF" i="1263" b="1" n="1"></line>
        <line t="C" i="1264" b="1" n="1">! Return the number of siblings of a node</line>
        <line k="tree_siblings" t="F" i="1265" b="1" n="1">pure function tree_siblings( this ) result(res)</line>
        <line t="F" i="1266" b="1" n="1"></line>
        <line t="C" i="1267" b="1" n="1">! The node iterator</line>
        <line t="X" i="1268" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1269" b="1" n="1"></line>
        <line t="C" i="1270" b="1" n="1">! The number of siblings (excluding self)</line>
        <line t="X" i="1271" b="1" n="1">  integer :: res</line>
        <line t="X" i="1272" b="1" n="1"></line>
        <line t="C" i="1273" b="1" n="1">! Assign the return value</line>
        <line t="X" i="1274" b="1" n="1">  res = this%node%parent%children - 1</line>
        <line t="X" i="1275" b="1" n="1"></line>
        <line t="EF" i="1276" b="1" n="1">end function tree_siblings</line>
        <line t="EF" i="1277" b="1" n="1"></line>
        <line t="EF" i="1278" b="1" n="1"></line>
        <line t="C" i="1279" b="1" n="1">! Return iterator to the parent</line>
        <line k="tree_parent" t="F" i="1280" b="1" n="1">function tree_parent( this ) result(res)</line>
        <line t="F" i="1281" b="1" n="1"></line>
        <line t="C" i="1282" b="1" n="1">! The node iterator</line>
        <line t="X" i="1283" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1284" b="1" n="1"></line>
        <line t="C" i="1285" b="1" n="1">! The parent node iterator</line>
        <line t="X" i="1286" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: res</line>
        <line t="X" i="1287" b="1" n="1"></line>
        <line t="C" i="1288" b="1" n="1">! Return iterator to parent</line>
        <line t="X" i="1289" b="2" n="2">  if( associated(this%node) ) then</line>
        <line t="X" i="1290" b="2" n="2">    res%node =&gt; this%node%parent</line>
        <line t="X" i="1291" b="2" n="1">  end if</line>
        <line t="X" i="1292" b="2" n="1">  res%tree =&gt; this%tree</line>
        <line t="X" i="1293" b="2" n="1"></line>
        <line t="EF" i="1294" b="2" n="1">end function tree_parent</line>
        <line t="EF" i="1295" b="1" n="1"></line>
        <line t="EF" i="1296" b="1" n="1"></line>
        <line t="C" i="1297" b="1" n="1">! Return the depth in a tree (from iterator); root is depth 0</line>
        <line k="tree_depth" t="F" i="1298" b="1" n="1">function tree_depth( this ) result(res)</line>
        <line t="F" i="1299" b="1" n="1"></line>
        <line t="C" i="1300" b="1" n="1">! The node iterator</line>
        <line t="X" i="1301" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), target, intent(in) :: this</line>
        <line t="X" i="1302" b="1" n="1"></line>
        <line t="C" i="1303" b="1" n="1">! The iterator depth</line>
        <line t="X" i="1304" b="1" n="1">  integer :: res</line>
        <line t="X" i="1305" b="1" n="1"></line>
        <line t="C" i="1306" b="1" n="1">! Local node pointer</line>
        <line t="X" i="1307" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="1308" b="1" n="1"></line>
        <line t="C" i="1309" b="1" n="1">! Initialise navigation pointer</line>
        <line t="X" i="1310" b="1" n="1">  node =&gt; this%node</line>
        <line t="X" i="1311" b="1" n="1"></line>
        <line t="C" i="1312" b="1" n="1">! Compute the depth</line>
        <line t="X" i="1313" b="1" n="1">  res = 0</line>
        <line t="X" i="1314" b="2" n="2">  do while( associated(node%parent) )</line>
        <line t="X" i="1315" b="2" n="2">    res = res + 1</line>
        <line t="X" i="1316" b="2" n="2">    node =&gt; node%parent</line>
        <line t="X" i="1317" b="2" n="1">  end do</line>
        <line t="X" i="1318" b="2" n="1"></line>
        <line t="EF" i="1319" b="2" n="1">end function tree_depth</line>
        <line t="EF" i="1320" b="1" n="1"></line>
        <line t="EF" i="1321" b="1" n="1"></line>
        <line t="C" i="1322" b="1" n="1">! Return the sibling position in a tree (from iterator); root is sibling position 0</line>
        <line k="tree_sibling_position" t="F" i="1323" b="1" n="1">function tree_sibling_position( this ) result(res)</line>
        <line t="F" i="1324" b="1" n="1"></line>
        <line t="C" i="1325" b="1" n="1">! The node iterator</line>
        <line t="X" i="1326" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), target, intent(in) :: this</line>
        <line t="X" i="1327" b="1" n="1"></line>
        <line t="C" i="1328" b="1" n="1">! The iterator sibling position</line>
        <line t="X" i="1329" b="1" n="1">  integer :: res</line>
        <line t="X" i="1330" b="1" n="1"></line>
        <line t="C" i="1331" b="1" n="1">! Local node pointer</line>
        <line t="X" i="1332" b="1" n="1">  type(t_tree_node), pointer :: node</line>
        <line t="X" i="1333" b="1" n="1"></line>
        <line t="C" i="1334" b="1" n="1">! Initialise navigation pointer</line>
        <line t="X" i="1335" b="1" n="1">  node =&gt; this%node</line>
        <line t="X" i="1336" b="1" n="1"></line>
        <line t="C" i="1337" b="1" n="1">! Compute the sibling position</line>
        <line t="X" i="1338" b="1" n="1">  res = 1</line>
        <line t="X" i="1339" b="2" n="2">  do while( associated(node%previous_sibling) )</line>
        <line t="X" i="1340" b="2" n="2">    res = res + 1</line>
        <line t="X" i="1341" b="2" n="2">    node =&gt; node%previous_sibling</line>
        <line t="X" i="1342" b="2" n="1">  end do</line>
        <line t="X" i="1343" b="2" n="1"></line>
        <line t="EF" i="1344" b="2" n="1">end function tree_sibling_position</line>
        <line t="EF" i="1345" b="1" n="1"></line>
        <line t="EF" i="1346" b="1" n="1"></line>
        <line t="C" i="1347" b="1" n="1">! Clear the whole tree</line>
        <line k="tree_clear_tree" t="S" i="1348" b="1" n="1">subroutine tree_clear_tree( this )</line>
        <line t="S" i="1349" b="1" n="1"></line>
        <line t="C" i="1350" b="1" n="1">! The tree</line>
        <line t="X" i="1351" b="1" n="1">  class(xxtypebase___tree_ftl), intent(inout) :: this</line>
        <line t="X" i="1352" b="1" n="1"></line>
        <line t="C" i="1353" b="1" n="1">! Recursively delete the tree nodes starting at root</line>
        <line t="X" i="1354" b="1" n="1">  call this%root%clear()</line>
        <line t="X" i="1355" b="1" n="1"></line>
        <line t="C" i="1356" b="1" n="1">! Reset the number of children</line>
        <line t="X" i="1357" b="1" n="1">  this%root%children = 0</line>
        <line t="X" i="1358" b="1" n="1"></line>
        <line t="ES" i="1359" b="1" n="1">end subroutine tree_clear_tree</line>
        <line t="ES" i="1360" b="1" n="1"></line>
        <line t="ES" i="1361" b="1" n="1"></line>
        <line t="C" i="1362" b="1" n="1">! Clear the node pointed by the iterator</line>
        <line k="tree_clear_iterator" t="S" i="1363" b="1" n="1">subroutine tree_clear_iterator( iterator )</line>
        <line t="S" i="1364" b="1" n="1"></line>
        <line t="C" i="1365" b="1" n="1">! The node iterator</line>
        <line t="X" i="1366" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: iterator</line>
        <line t="X" i="1367" b="1" n="1"></line>
        <line t="C" i="1368" b="1" n="1">! Local variables</line>
        <line t="X" i="1369" b="1" n="1">  type(t_tree_node), pointer :: node, parent</line>
        <line t="X" i="1370" b="1" n="1"></line>
        <line t="C" i="1371" b="1" n="1">! Keep the nodes before reassigning pointers</line>
        <line t="X" i="1372" b="1" n="1">  node =&gt; iterator%node</line>
        <line t="X" i="1373" b="1" n="1">  parent =&gt; node%parent</line>
        <line t="X" i="1374" b="1" n="1"></line>
        <line t="C" i="1375" b="1" n="1">! Check if node is the first node in the parent</line>
        <line t="X" i="1376" b="2" n="2">  if( associated(parent%first_child,node) ) then</line>
        <line t="X" i="1377" b="2" n="2"></line>
        <line t="C" i="1378" b="2" n="2">!   Set the next node to be the first child in the parent</line>
        <line t="X" i="1379" b="2" n="2">    parent%first_child =&gt; node%next_sibling</line>
        <line t="X" i="1380" b="2" n="2"></line>
        <line t="C" i="1381" b="2" n="2">!   Assign pointers</line>
        <line t="X" i="1382" b="3" n="3">    if( associated(node%next_sibling) ) then</line>
        <line t="X" i="1383" b="3" n="3"></line>
        <line t="C" i="1384" b="3" n="3">!     Not the last node in the siblings</line>
        <line t="X" i="1385" b="3" n="3">      node%next_sibling%previous_sibling =&gt; null()</line>
        <line t="X" i="1386" b="3" n="3"></line>
        <line t="X" i="1387" b="4" n="3">    else</line>
        <line t="X" i="1388" b="4" n="3"></line>
        <line t="C" i="1389" b="4" n="3">!     Last node in the siblings (only one node in the siblings before removal)</line>
        <line t="X" i="1390" b="4" n="3">      parent%last_child =&gt; null()</line>
        <line t="X" i="1391" b="4" n="3"></line>
        <line t="X" i="1392" b="4" n="2">    end if</line>
        <line t="X" i="1393" b="4" n="2"></line>
        <line t="C" i="1394" b="4" n="2">! Check if node is the last child in the parent</line>
        <line t="X" i="1395" b="5" n="2">  else if( associated(parent%last_child,node) ) then</line>
        <line t="X" i="1396" b="5" n="2"></line>
        <line t="C" i="1397" b="5" n="2">!   Set the previous node to be last node in the parent</line>
        <line t="X" i="1398" b="5" n="2">    parent%last_child =&gt; node%previous_sibling</line>
        <line t="X" i="1399" b="5" n="2"></line>
        <line t="C" i="1400" b="5" n="2">!   Assign pointers</line>
        <line t="X" i="1401" b="6" n="3">    if( associated(node%previous_sibling) ) then</line>
        <line t="X" i="1402" b="6" n="3"></line>
        <line t="C" i="1403" b="6" n="3">!     Not the first node in the siblings</line>
        <line t="X" i="1404" b="6" n="3">      node%previous_sibling%next_sibling =&gt; null()</line>
        <line t="X" i="1405" b="6" n="3"></line>
        <line t="X" i="1406" b="7" n="3">    else</line>
        <line t="X" i="1407" b="7" n="3"></line>
        <line t="C" i="1408" b="7" n="3">!     First node in the siblings (only one node in the siblings before removal)</line>
        <line t="C" i="1409" b="7" n="3">!     This line cannot be reached beacuse executions follows the branch</line>
        <line t="C" i="1410" b="7" n="3">!     of the first node in the parent</line>
        <line t="C" i="1411" b="7" n="3">!      parent%first_child =&gt; null()</line>
        <line t="C" i="1412" b="7" n="3"></line>
        <line t="X" i="1413" b="7" n="2">    end if</line>
        <line t="X" i="1414" b="7" n="2"></line>
        <line t="C" i="1415" b="7" n="2">! Generic intermediate nodes (at least three nodes present)</line>
        <line t="X" i="1416" b="8" n="2">  else</line>
        <line t="X" i="1417" b="8" n="2"></line>
        <line t="C" i="1418" b="8" n="2">!   Assign pointers</line>
        <line t="X" i="1419" b="8" n="2">    node%previous_sibling%next_sibling =&gt; node%next_sibling</line>
        <line t="X" i="1420" b="8" n="2">    node%next_sibling%previous_sibling =&gt; node%previous_sibling</line>
        <line t="X" i="1421" b="8" n="2"></line>
        <line t="X" i="1422" b="8" n="1">  end if</line>
        <line t="X" i="1423" b="8" n="1"></line>
        <line t="C" i="1424" b="8" n="1">! Remove one chlid from parent</line>
        <line t="X" i="1425" b="8" n="1">  node%parent%children = node%parent%children - 1</line>
        <line t="X" i="1426" b="8" n="1"></line>
        <line t="C" i="1427" b="8" n="1">! Recursively clear all nodes below the one pointed by the iterator</line>
        <line t="X" i="1428" b="8" n="1">  call node%clear()</line>
        <line t="X" i="1429" b="8" n="1">  deallocate( node )</line>
        <line t="X" i="1430" b="8" n="1"></line>
        <line t="ES" i="1431" b="8" n="1">end subroutine tree_clear_iterator</line>
        <line t="ES" i="1432" b="1" n="1"></line>
        <line t="ES" i="1433" b="1" n="1"></line>
        <line t="C" i="1434" b="1" n="1">! Recursively clear the node and all descendants</line>
        <line k="tree_clear_node" t="S" i="1435" b="1" n="1">recursive subroutine tree_clear_node( this )</line>
        <line t="S" i="1436" b="1" n="1"></line>
        <line t="C" i="1437" b="1" n="1">! The top node</line>
        <line t="X" i="1438" b="1" n="1">  class(t_tree_node), intent(inout) :: this</line>
        <line t="X" i="1439" b="1" n="1"></line>
        <line t="C" i="1440" b="1" n="1">! Local node pointer</line>
        <line t="X" i="1441" b="1" n="1">  type(t_tree_node), pointer :: it</line>
        <line t="X" i="1442" b="1" n="1"></line>
        <line t="C" i="1443" b="1" n="1">! Remove the element stored in the node</line>
        <line t="X" i="1444" b="2" n="2">  if( associated(this%element) ) then</line>
        <line t="X" i="1445" b="2" n="2">    deallocate( this%element )</line>
        <line t="X" i="1446" b="2" n="1">  end if</line>
        <line t="X" i="1447" b="2" n="1"></line>
        <line t="C" i="1448" b="2" n="1">! Check for children</line>
        <line t="X" i="1449" b="3" n="2">  if( associated(this%last_child ) ) then</line>
        <line t="X" i="1450" b="3" n="2"></line>
        <line t="C" i="1451" b="3" n="2">!   Recursively remove all children</line>
        <line t="X" i="1452" b="4" n="3">    do</line>
        <line t="X" i="1453" b="4" n="3"></line>
        <line t="C" i="1454" b="4" n="3">!     The node to delete is always the last one</line>
        <line t="X" i="1455" b="4" n="3">      it =&gt; this%last_child</line>
        <line t="X" i="1456" b="5" n="4">      if( associated(it) ) then</line>
        <line t="X" i="1457" b="5" n="4"></line>
        <line t="C" i="1458" b="5" n="4">!       Reassign the last child pointer before deleting</line>
        <line t="X" i="1459" b="5" n="4">        this%last_child =&gt; this%last_child%previous_sibling</line>
        <line t="X" i="1460" b="5" n="4"></line>
        <line t="C" i="1461" b="5" n="4">!       Delete the last child node</line>
        <line t="X" i="1462" b="5" n="4">        call it%clear()</line>
        <line t="X" i="1463" b="5" n="4">        deallocate( it )</line>
        <line t="X" i="1464" b="5" n="4"></line>
        <line t="X" i="1465" b="6" n="4">      else</line>
        <line t="X" i="1466" b="6" n="4">        exit</line>
        <line t="X" i="1467" b="6" n="3">      end if</line>
        <line t="X" i="1468" b="6" n="3"></line>
        <line t="X" i="1469" b="6" n="2">    end do</line>
        <line t="X" i="1470" b="6" n="2"></line>
        <line t="C" i="1471" b="6" n="2">!   Nullify the child iterators</line>
        <line t="X" i="1472" b="6" n="2">    this%first_child =&gt; null()</line>
        <line t="X" i="1473" b="6" n="2">    this%last_child =&gt; null()</line>
        <line t="X" i="1474" b="6" n="2"></line>
        <line t="X" i="1475" b="6" n="1">  end if</line>
        <line t="X" i="1476" b="6" n="1"></line>
        <line t="ES" i="1477" b="6" n="1">end subroutine tree_clear_node</line>
        <line t="ES" i="1478" b="1" n="1"></line>
        <line t="ES" i="1479" b="1" n="1"></line>
        <line t="C" i="1480" b="1" n="1">! Swap two elements in a tree</line>
        <line k="tree_swap_iterator" t="S" i="1481" b="1" n="1">pure subroutine tree_swap_iterator( this, other )</line>
        <line t="S" i="1482" b="1" n="1"></line>
        <line t="C" i="1483" b="1" n="1">! Iterator to first element</line>
        <line t="X" i="1484" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: this</line>
        <line t="X" i="1485" b="1" n="1"></line>
        <line t="C" i="1486" b="1" n="1">! Iterator to second element</line>
        <line t="X" i="1487" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(inout) :: other</line>
        <line t="X" i="1488" b="1" n="1"></line>
        <line t="C" i="1489" b="1" n="1">! Swap the nodes pointed by the iterators</line>
        <line t="X" i="1490" b="1" n="1">  call this%node%swap( other%node )</line>
        <line t="X" i="1491" b="1" n="1"></line>
        <line t="ES" i="1492" b="1" n="1">end subroutine tree_swap_iterator</line>
        <line t="ES" i="1493" b="1" n="1"></line>
        <line t="ES" i="1494" b="1" n="1"></line>
        <line t="C" i="1495" b="1" n="1">! Swap two elements in a tree</line>
        <line k="tree_swap_node" t="S" i="1496" b="1" n="1">pure subroutine tree_swap_node( this, other )</line>
        <line t="S" i="1497" b="1" n="1"></line>
        <line t="C" i="1498" b="1" n="1">! Iterator to first element</line>
        <line t="X" i="1499" b="1" n="1">  class(t_tree_node), target, intent(inout) :: this</line>
        <line t="X" i="1500" b="1" n="1"></line>
        <line t="C" i="1501" b="1" n="1">! Iterator to second element</line>
        <line t="X" i="1502" b="1" n="1">  type(t_tree_node), target, intent(inout) :: other</line>
        <line t="X" i="1503" b="1" n="1"></line>
        <line t="C" i="1504" b="1" n="1">! Intermediate iterators</line>
        <line t="X" i="1505" b="1" n="1">  type(t_tree_node) :: node</line>
        <line t="X" i="1506" b="1" n="1"></line>
        <line t="C" i="1507" b="1" n="1">! Keep the first node pointers in the temporary storage</line>
        <line t="X" i="1508" b="1" n="1">  node = this</line>
        <line t="X" i="1509" b="1" n="1"></line>
        <line t="C" i="1510" b="1" n="1">! Assign potinters in first node</line>
        <line t="X" i="1511" b="2" n="2">  if( associated(this%next_sibling,other) ) then</line>
        <line t="X" i="1512" b="2" n="2"></line>
        <line t="C" i="1513" b="2" n="2">!   Other is the next node to this in the siblings</line>
        <line t="X" i="1514" b="2" n="2">    this%previous_sibling =&gt; other</line>
        <line t="X" i="1515" b="2" n="2">    this%next_sibling =&gt; other%next_sibling</line>
        <line t="X" i="1516" b="2" n="2"></line>
        <line t="X" i="1517" b="3" n="2">  else if( associated(this%previous_sibling,other) ) then</line>
        <line t="X" i="1518" b="3" n="2"></line>
        <line t="C" i="1519" b="3" n="2">!   Other is the previous node to this in the siblings</line>
        <line t="X" i="1520" b="3" n="2">    this%previous_sibling =&gt; other%previous_sibling</line>
        <line t="X" i="1521" b="3" n="2">    this%next_sibling =&gt; other</line>
        <line t="X" i="1522" b="4" n="2">  else</line>
        <line t="X" i="1523" b="4" n="2"></line>
        <line t="C" i="1524" b="4" n="2">!   Nodes in this and other are not adjacent nodes</line>
        <line t="X" i="1525" b="4" n="2">    this%previous_sibling =&gt; other%previous_sibling</line>
        <line t="X" i="1526" b="4" n="2">    this%next_sibling =&gt; other%next_sibling</line>
        <line t="X" i="1527" b="4" n="2"></line>
        <line t="X" i="1528" b="4" n="1">  end if</line>
        <line t="X" i="1529" b="4" n="1"></line>
        <line t="C" i="1530" b="4" n="1">! Assign pointers in second node</line>
        <line t="X" i="1531" b="5" n="2">  if( associated(other%next_sibling,this) ) then</line>
        <line t="X" i="1532" b="5" n="2"></line>
        <line t="C" i="1533" b="5" n="2">!   This is the next node to other in the siblings</line>
        <line t="X" i="1534" b="5" n="2">    other%previous_sibling =&gt; this</line>
        <line t="X" i="1535" b="5" n="2">    other%next_sibling =&gt; node%next_sibling</line>
        <line t="X" i="1536" b="5" n="2"></line>
        <line t="X" i="1537" b="6" n="2">  else if( associated(other%previous_sibling,this) ) then</line>
        <line t="X" i="1538" b="6" n="2"></line>
        <line t="C" i="1539" b="6" n="2">!   This is the previous node to other in the siblings</line>
        <line t="X" i="1540" b="6" n="2">    other%previous_sibling =&gt; node%previous_sibling</line>
        <line t="X" i="1541" b="6" n="2">    other%next_sibling =&gt; this</line>
        <line t="X" i="1542" b="7" n="2">  else</line>
        <line t="X" i="1543" b="7" n="2"></line>
        <line t="C" i="1544" b="7" n="2">!   Nodes in this and other are not adjacent nodes</line>
        <line t="X" i="1545" b="7" n="2">    other%previous_sibling =&gt; node%previous_sibling</line>
        <line t="X" i="1546" b="7" n="2">    other%next_sibling =&gt; node%next_sibling</line>
        <line t="X" i="1547" b="7" n="2"></line>
        <line t="X" i="1548" b="7" n="1">  end if</line>
        <line t="X" i="1549" b="7" n="1"></line>
        <line t="C" i="1550" b="7" n="1">! Exchange children pointers</line>
        <line t="X" i="1551" b="7" n="1">  this%first_child =&gt; other%first_child</line>
        <line t="X" i="1552" b="7" n="1">  other%first_child =&gt; node%first_child</line>
        <line t="X" i="1553" b="7" n="1">  this%last_child =&gt; other%last_child</line>
        <line t="X" i="1554" b="7" n="1">  other%last_child =&gt; node%last_child</line>
        <line t="X" i="1555" b="7" n="1"></line>
        <line t="C" i="1556" b="7" n="1">! Exchange parents</line>
        <line t="X" i="1557" b="7" n="1">  this%parent =&gt; other%parent</line>
        <line t="X" i="1558" b="7" n="1">  other%parent =&gt; node%parent</line>
        <line t="X" i="1559" b="7" n="1"></line>
        <line t="C" i="1560" b="7" n="1">! Check this at start of the list</line>
        <line t="X" i="1561" b="8" n="2">  if( associated(this%previous_sibling) ) then</line>
        <line t="X" i="1562" b="8" n="2"></line>
        <line t="C" i="1563" b="8" n="2">!   This has not become the first node in its parent</line>
        <line t="X" i="1564" b="8" n="2">    this%previous_sibling%next_sibling =&gt; this</line>
        <line t="X" i="1565" b="8" n="2"></line>
        <line t="X" i="1566" b="9" n="2">  else</line>
        <line t="X" i="1567" b="9" n="2"></line>
        <line t="C" i="1568" b="9" n="2">!   This has become the first node in its parent</line>
        <line t="X" i="1569" b="9" n="2">    this%parent%first_child =&gt; this</line>
        <line t="X" i="1570" b="9" n="2"></line>
        <line t="C" i="1571" b="9" n="2">!   Move the child count from other to this</line>
        <line t="X" i="1572" b="9" n="2">    this%parent%children = this%parent%children + 1</line>
        <line t="X" i="1573" b="9" n="2">    other%parent%children = other%parent%children - 1</line>
        <line t="X" i="1574" b="9" n="2"></line>
        <line t="X" i="1575" b="9" n="1">  end if</line>
        <line t="X" i="1576" b="9" n="1"></line>
        <line t="C" i="1577" b="9" n="1">! Check this at the end of the list</line>
        <line t="X" i="1578" b="10" n="2">  if( associated(this%next_sibling) ) then</line>
        <line t="X" i="1579" b="10" n="2"></line>
        <line t="C" i="1580" b="10" n="2">!   This has not become the last node in its parent</line>
        <line t="X" i="1581" b="10" n="2">    this%next_sibling%previous_sibling =&gt; this</line>
        <line t="X" i="1582" b="10" n="2"></line>
        <line t="X" i="1583" b="11" n="2">  else</line>
        <line t="X" i="1584" b="11" n="2"></line>
        <line t="C" i="1585" b="11" n="2">!   This has become the last node in its parent</line>
        <line t="X" i="1586" b="11" n="2">    this%parent%last_child =&gt; this</line>
        <line t="X" i="1587" b="11" n="2"></line>
        <line t="C" i="1588" b="11" n="2">!   Move the child count from other to this</line>
        <line t="X" i="1589" b="11" n="2">    this%parent%children = this%parent%children + 1</line>
        <line t="X" i="1590" b="11" n="2">    other%parent%children = other%parent%children - 1</line>
        <line t="X" i="1591" b="11" n="2"></line>
        <line t="X" i="1592" b="11" n="1">  end if</line>
        <line t="X" i="1593" b="11" n="1"></line>
        <line t="C" i="1594" b="11" n="1">! Check other at start of the list</line>
        <line t="X" i="1595" b="12" n="2">  if( associated(other%previous_sibling) ) then</line>
        <line t="X" i="1596" b="12" n="2"></line>
        <line t="C" i="1597" b="12" n="2">!   Other has not become the first node in its parent</line>
        <line t="X" i="1598" b="12" n="2">    other%previous_sibling%next_sibling =&gt; other</line>
        <line t="X" i="1599" b="12" n="2"></line>
        <line t="X" i="1600" b="13" n="2">  else</line>
        <line t="X" i="1601" b="13" n="2"></line>
        <line t="C" i="1602" b="13" n="2">!   Other has become the first node in its parent</line>
        <line t="X" i="1603" b="13" n="2">    other%parent%first_child =&gt; other</line>
        <line t="X" i="1604" b="13" n="2"></line>
        <line t="C" i="1605" b="13" n="2">!   Move the child count from this to other</line>
        <line t="X" i="1606" b="13" n="2">    other%parent%children = other%parent%children + 1</line>
        <line t="X" i="1607" b="13" n="2">    this%parent%children = this%parent%children - 1</line>
        <line t="X" i="1608" b="13" n="2"></line>
        <line t="X" i="1609" b="13" n="1">  end if</line>
        <line t="X" i="1610" b="13" n="1"></line>
        <line t="C" i="1611" b="13" n="1">! Check other at the end of the list</line>
        <line t="X" i="1612" b="14" n="2">  if( associated(other%next_sibling) ) then</line>
        <line t="X" i="1613" b="14" n="2"></line>
        <line t="C" i="1614" b="14" n="2">!   Other has not become the last node in its parent</line>
        <line t="X" i="1615" b="14" n="2">    other%next_sibling%previous_sibling =&gt; other</line>
        <line t="X" i="1616" b="14" n="2"></line>
        <line t="X" i="1617" b="15" n="2">  else</line>
        <line t="X" i="1618" b="15" n="2"></line>
        <line t="C" i="1619" b="15" n="2">!   Other has become the last node in its parent</line>
        <line t="X" i="1620" b="15" n="2">    other%parent%last_child =&gt; other</line>
        <line t="X" i="1621" b="15" n="2"></line>
        <line t="C" i="1622" b="15" n="2">!   Move the child count from this to other</line>
        <line t="X" i="1623" b="15" n="2">    other%parent%children = other%parent%children + 1</line>
        <line t="X" i="1624" b="15" n="2">    this%parent%children = this%parent%children - 1</line>
        <line t="X" i="1625" b="15" n="2"></line>
        <line t="X" i="1626" b="15" n="1">  end if</line>
        <line t="X" i="1627" b="15" n="1"></line>
        <line t="ES" i="1628" b="15" n="1">end subroutine tree_swap_node</line>
        <line t="ES" i="1629" b="1" n="1"></line>
        <line t="ES" i="1630" b="1" n="1"></line>
        <line t="C" i="1631" b="1" n="1">! Create a tree from an exisiting tree (assignment operator)</line>
        <line k="tree_assign_from_tree" t="S" i="1632" b="1" n="1">subroutine tree_assign_from_tree( this, other )</line>
        <line t="S" i="1633" b="1" n="1"></line>
        <line t="C" i="1634" b="1" n="1">! The output tree</line>
        <line t="X" i="1635" b="1" n="1">  class(xxtypebase___tree_ftl), intent(out) :: this</line>
        <line t="X" i="1636" b="1" n="1"></line>
        <line t="C" i="1637" b="1" n="1">! The input tree</line>
        <line t="X" i="1638" b="1" n="1">  type(xxtypebase___tree_ftl), intent(in) :: other</line>
        <line t="X" i="1639" b="1" n="1"></line>
        <line t="C" i="1640" b="1" n="1">! Local variables</line>
        <line t="X" i="1641" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: it, oit</line>
        <line t="X" i="1642" b="1" n="1"></line>
        <line t="C" i="1643" b="1" n="1">! Navigate recursively the children in he input tree</line>
        <line t="X" i="1644" b="1" n="1">  it = this%begin()</line>
        <line t="X" i="1645" b="1" n="1">  oit = other%begin()</line>
        <line t="X" i="1646" b="1" n="1">  call tree_add_children_from_tree( it, oit )</line>
        <line t="X" i="1647" b="1" n="1"></line>
        <line t="C" i="1648" b="1" n="1">! Set the number of root children</line>
        <line t="X" i="1649" b="1" n="1">  this%root%children = other%root%children</line>
        <line t="X" i="1650" b="1" n="1"></line>
        <line t="ES" i="1651" b="1" n="1">end subroutine tree_assign_from_tree</line>
        <line t="ES" i="1652" b="1" n="1"></line>
        <line t="ES" i="1653" b="1" n="1"></line>
        <line t="C" i="1654" b="1" n="1">! Copy recursively the nodes from the input to the output</line>
        <line k="tree_add_children_from_tree" t="S" i="1655" b="1" n="1">recursive subroutine tree_add_children_from_tree( itthis, itother )</line>
        <line t="S" i="1656" b="1" n="1"></line>
        <line t="C" i="1657" b="1" n="1">! The output tree iterator</line>
        <line t="X" i="1658" b="1" n="1">  type(xxtypebase___tree_ftl_iterator), intent(inout) :: itthis</line>
        <line t="X" i="1659" b="1" n="1"></line>
        <line t="C" i="1660" b="1" n="1">! The input tree iterator</line>
        <line t="X" i="1661" b="1" n="1">  type(xxtypebase___tree_ftl_iterator), intent(inout) :: itother</line>
        <line t="X" i="1662" b="1" n="1"></line>
        <line t="C" i="1663" b="1" n="1">! Local variables</line>
        <line t="X" i="1664" b="1" n="1">  type(xxtypebase___tree_ftl_iterator) :: itt, ito, ito0</line>
        <line t="X" i="1665" b="1" n="1"></line>
        <line t="C" i="1666" b="1" n="1">! Check if the node has children</line>
        <line t="X" i="1667" b="2" n="2">  if( itother%has_children() ) then</line>
        <line t="X" i="1668" b="2" n="2"></line>
        <line t="C" i="1669" b="2" n="2">!   Set output iterator to point to current node</line>
        <line t="X" i="1670" b="2" n="2">    itt = itthis</line>
        <line t="X" i="1671" b="2" n="2"></line>
        <line t="C" i="1672" b="2" n="2">!   Keep the iterator to the first node in this level</line>
        <line t="X" i="1673" b="2" n="2">    ito0 = itother%tree%begin(itother)</line>
        <line t="X" i="1674" b="2" n="2"></line>
        <line t="C" i="1675" b="2" n="2">!   Loop on the children in the input tree</line>
        <line t="X" i="1676" b="2" n="2">    ito = ito0</line>
        <line t="X" i="1677" b="3" n="3">    do while( ito%associated() )</line>
        <line t="X" i="1678" b="3" n="3"></line>
        <line t="C" i="1679" b="3" n="3">!     Insert the node in its right level</line>
        <line t="X" i="1680" b="4" n="4">      if( ito%associated(ito0) ) then</line>
        <line t="X" i="1681" b="4" n="4"></line>
        <line t="C" i="1682" b="4" n="4">!       First node to be inserted in the following level</line>
        <line t="X" i="1683" b="4" n="4">        call itthis%tree%push_back_child( itt, ito%get_element() )</line>
        <line t="X" i="1684" b="4" n="4"></line>
        <line t="C" i="1685" b="4" n="4">!       Position the iterator in first=last element in next level</line>
        <line t="X" i="1686" b="4" n="4">        itt = itthis%tree%end(itt)</line>
        <line t="X" i="1687" b="4" n="4"></line>
        <line t="X" i="1688" b="5" n="4">      else</line>
        <line t="X" i="1689" b="5" n="4"></line>
        <line t="C" i="1690" b="5" n="4">!       Extra nodes inserted in this level</line>
        <line t="X" i="1691" b="5" n="4">        call itthis%tree%push_back_sibling( itt, ito%get_element() )</line>
        <line t="X" i="1692" b="5" n="4"></line>
        <line t="C" i="1693" b="5" n="4">!       Position the iterator in the last element of this level</line>
        <line t="X" i="1694" b="5" n="4">        itt = itthis%tree%end_sibling(itt)</line>
        <line t="X" i="1695" b="5" n="4"></line>
        <line t="X" i="1696" b="5" n="3">      end if</line>
        <line t="X" i="1697" b="5" n="3"></line>
        <line t="C" i="1698" b="5" n="3">!     Process recursively this node</line>
        <line t="X" i="1699" b="5" n="3">      call tree_add_children_from_tree( itt, ito )</line>
        <line t="X" i="1700" b="5" n="3"></line>
        <line t="C" i="1701" b="5" n="3">!     Iterate</line>
        <line t="X" i="1702" b="5" n="3">      ito = ito%next_sibling()</line>
        <line t="X" i="1703" b="5" n="3"></line>
        <line t="X" i="1704" b="5" n="2">    end do</line>
        <line t="X" i="1705" b="5" n="2"></line>
        <line t="X" i="1706" b="5" n="1">  end if</line>
        <line t="X" i="1707" b="5" n="1"></line>
        <line t="ES" i="1708" b="5" n="1">  end subroutine tree_add_children_from_tree</line>
        <line t="ES" i="1709" b="1" n="1"></line>
        <line t="ES" i="1710" b="1" n="1"></line>
        <line t="C" i="1711" b="1" n="1">! Access to iterator container</line>
        <line k="tree_container_ptr" t="F" i="1712" b="1" n="1">function tree_container_ptr( this ) result(res)</line>
        <line t="F" i="1713" b="1" n="1"></line>
        <line t="C" i="1714" b="1" n="1">! The iterator</line>
        <line t="X" i="1715" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(in) :: this</line>
        <line t="X" i="1716" b="1" n="1"></line>
        <line t="C" i="1717" b="1" n="1">! The pointer to the tree</line>
        <line t="X" i="1718" b="1" n="1">  type(xxtypebase___tree_ftl), pointer :: res</line>
        <line t="X" i="1719" b="1" n="1"></line>
        <line t="C" i="1720" b="1" n="1">! Set the result</line>
        <line t="X" i="1721" b="1" n="1">  res =&gt; this%tree</line>
        <line t="X" i="1722" b="1" n="1"></line>
        <line t="EF" i="1723" b="1" n="1">end function tree_container_ptr</line>
        <line t="EF" i="1724" b="1" n="1"></line>
        <line t="EF" i="1725" b="1" n="1"></line>
        <line t="C" i="1726" b="1" n="1">! Create a tree from an exisiting tree (assignment operator)</line>
        <line k="tree_iterator_assign_from_tree_iterator" t="S" i="1727" b="1" n="1">subroutine tree_iterator_assign_from_tree_iterator( this, other )</line>
        <line t="S" i="1728" b="1" n="1"></line>
        <line t="C" i="1729" b="1" n="1">! The output tree iterator</line>
        <line t="X" i="1730" b="1" n="1">  class(xxtypebase___tree_ftl_iterator), intent(out) :: this</line>
        <line t="X" i="1731" b="1" n="1"></line>
        <line t="C" i="1732" b="1" n="1">! The input tree iterator</line>
        <line t="X" i="1733" b="1" n="1">  type(xxtypebase___tree_ftl_iterator), intent(in) :: other</line>
        <line t="X" i="1734" b="1" n="1"></line>
        <line t="C" i="1735" b="1" n="1">! Assign the pointers</line>
        <line t="X" i="1736" b="1" n="1">  this%node =&gt; other%node</line>
        <line t="X" i="1737" b="1" n="1">  this%tree =&gt; other%tree</line>
        <line t="X" i="1738" b="1" n="1"></line>
        <line t="ES" i="1739" b="1" n="1">end subroutine tree_iterator_assign_from_tree_iterator</line>
        <line t="ES" i="1740" b="1" n="1"></line>
        <line t="ES" i="1741" b="1" n="1"></line>
        <line t="C" i="1742" b="1" n="1">! Implement the assignment between two elements (contained in the container node)</line>
        <line t="C" i="1743" b="1" n="1">! Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess)</line>
        <line t="C" i="1744" b="1" n="1">! at the time thta allows the invocation of assignment operators in the cases when the element implements it</line>
        <line k="element_assign_pointer" t="S" i="1745" b="1" n="1">pure subroutine element_assign_pointer( left, right )</line>
        <line t="S" i="1746" b="1" n="1"></line>
        <line t="C" i="1747" b="1" n="1">! Element to be allocated and assigned (pointer interface)</line>
        <line t="X" i="1748" b="1" n="1">  class(xxtypebase__), pointer, intent(inout) :: left</line>
        <line t="X" i="1749" b="1" n="1"></line>
        <line t="C" i="1750" b="1" n="1">! Source element</line>
        <line t="X" i="1751" b="1" n="1">  class(xxtypebase__), intent(in) :: right</line>
        <line t="X" i="1752" b="1" n="1"></line>
        <line t="C" i="1753" b="1" n="1">! Allocate first. Use mold to allow polymorphic object storage through parent class</line>
        <line t="X" i="1754" b="1" n="1">  allocate( left, mold=right )</line>
        <line t="X" i="1755" b="1" n="1"></line>
        <line t="C" i="1756" b="1" n="1">! Assign explicitly to allow invoking the assignment operator if implemented in the element</line>
        <line t="X" i="1757" b="1" n="1">  left = right</line>
        <line t="X" i="1758" b="1" n="1"></line>
        <line t="ES" i="1759" b="1" n="1">end subroutine element_assign_pointer</line>
        <line t="ES" i="1760" b="1" n="1"></line>
        <line t="ES" i="1761" b="1" n="1"></line>
        <line t="C" i="1762" b="1" n="1">! Implement the assignment between two elements (contained in the container node)</line>
        <line t="C" i="1763" b="1" n="1">! Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess)</line>
        <line t="C" i="1764" b="1" n="1">! at the time thta allows the invocation of assignment operators in the cases when the element implements it</line>
        <line k="element_assign_allocatable" t="S" i="1765" b="1" n="1">pure subroutine element_assign_allocatable( left, right )</line>
        <line t="S" i="1766" b="1" n="1"></line>
        <line t="C" i="1767" b="1" n="1">! Element to be allocated and assigned (allocatable interface)</line>
        <line t="X" i="1768" b="1" n="1">  class(xxtypebase__), allocatable, intent(inout) :: left</line>
        <line t="X" i="1769" b="1" n="1"></line>
        <line t="C" i="1770" b="1" n="1">! Source element</line>
        <line t="X" i="1771" b="1" n="1">  class(xxtypebase__), intent(in) :: right</line>
        <line t="X" i="1772" b="1" n="1"></line>
        <line t="C" i="1773" b="1" n="1">! Allocate first. Use mold to allow polymorphic object storage through parent class</line>
        <line t="X" i="1774" b="1" n="1">  allocate( left, mold=right )</line>
        <line t="X" i="1775" b="1" n="1"></line>
        <line t="C" i="1776" b="1" n="1">! Assign explicitly to allow invoking the assignment operator if implemented in the element</line>
        <line t="X" i="1777" b="1" n="1">  left = right</line>
        <line t="X" i="1778" b="1" n="1"></line>
        <line t="ES" i="1779" b="1" n="1">end subroutine element_assign_allocatable</line>
        <line t="ES" i="1780" b="1" n="1"></line>
        <line t="M" i="1781" b="1" n="1">end module xxmodulebase___tree_ftl</line>
        <line t="M" i="1782" b="1" n="1"></line>
    </code>
</fmx>