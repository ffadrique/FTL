<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FTL: C:/Users/ffadr/Documents/Visual Studio 2019/Projects/FTL/documentation/src/vector.f03 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FTL<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Fortran Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">vector.f03 File Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1t__node.html">xxmodulebase___vector_ftl::t_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector node type.  <a href="structxxmodulebase______vector__ftl_1_1t__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxmodulebase___vector_ftl::xxtypebase___vector_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector container type.  <a href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1xxconstructor______vector__ftl.html">xxmodulebase___vector_ftl::xxconstructor___vector_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor interface.  <a href="interfacexxmodulebase______vector__ftl_1_1xxconstructor______vector__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">xxmodulebase___vector_ftl::comparison</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1predicate.html">xxmodulebase___vector_ftl::predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1binary__predicate.html">xxmodulebase___vector_ftl::binary_predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxmodulebase___vector_ftl::xxtypebase___vector_ftl_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector iterator type.  <a href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1distance.html">xxmodulebase___vector_ftl::distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interfaces for procedures not bound to type.  <a href="interfacexxmodulebase______vector__ftl_1_1distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1swap.html">xxmodulebase___vector_ftl::swap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacexxmodulebase______vector__ftl"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html">xxmodulebase___vector_ftl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ac22de2f2d500c016c3a628067981ee12"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac22de2f2d500c016c3a628067981ee12">xxmodulebase___vector_ftl::vector_default</a> ()</td></tr>
<tr class="memdesc:ac22de2f2d500c016c3a628067981ee12"><td class="mdescLeft">&#160;</td><td class="mdescRight">(1) empty container constructor (default constructor) Constructs an empty container, with no elements.  <a href="namespacexxmodulebase______vector__ftl.html#ac22de2f2d500c016c3a628067981ee12">More...</a><br /></td></tr>
<tr class="separator:ac22de2f2d500c016c3a628067981ee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2172ac4807729f5ced5ca882beb42d3"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ab2172ac4807729f5ced5ca882beb42d3">xxmodulebase___vector_ftl::vector_fill</a> (n, val)</td></tr>
<tr class="memdesc:ab2172ac4807729f5ced5ca882beb42d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(2) fill constructor Constructs a container with n elements. Each element is a copy of val.  <a href="namespacexxmodulebase______vector__ftl.html#ab2172ac4807729f5ced5ca882beb42d3">More...</a><br /></td></tr>
<tr class="separator:ab2172ac4807729f5ced5ca882beb42d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9fa69db2dda505b0debdd4bd32928a"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ada9fa69db2dda505b0debdd4bd32928a">xxmodulebase___vector_ftl::vector_range</a> (first, last)</td></tr>
<tr class="memdesc:ada9fa69db2dda505b0debdd4bd32928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(3) range constructor Constructs a container with as many elements as the range (first,last), with each element constructed from its corresponding element in that range, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type  <a href="namespacexxmodulebase______vector__ftl.html#ada9fa69db2dda505b0debdd4bd32928a">More...</a><br /></td></tr>
<tr class="separator:ada9fa69db2dda505b0debdd4bd32928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068d7489a0ef1f57f83489b7a94d2c06"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a068d7489a0ef1f57f83489b7a94d2c06">xxmodulebase___vector_ftl::vector_copy</a> (other)</td></tr>
<tr class="memdesc:a068d7489a0ef1f57f83489b7a94d2c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">(4) copy constructor Constructs a container with a copy of each of the elements in other, in the same order.  <a href="namespacexxmodulebase______vector__ftl.html#a068d7489a0ef1f57f83489b7a94d2c06">More...</a><br /></td></tr>
<tr class="separator:a068d7489a0ef1f57f83489b7a94d2c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd31d81ff216049645688d944674268"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a1cd31d81ff216049645688d944674268">xxmodulebase___vector_ftl::vector_copy_from_array</a> (val)</td></tr>
<tr class="memdesc:a1cd31d81ff216049645688d944674268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from array.  <a href="namespacexxmodulebase______vector__ftl.html#a1cd31d81ff216049645688d944674268">More...</a><br /></td></tr>
<tr class="separator:a1cd31d81ff216049645688d944674268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c4b43fc00d13281082c4842ec6684"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a9f0c4b43fc00d13281082c4842ec6684">xxmodulebase___vector_ftl::vector_assign_from_vector</a> (this, other)</td></tr>
<tr class="memdesc:a9f0c4b43fc00d13281082c4842ec6684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.  <a href="namespacexxmodulebase______vector__ftl.html#a9f0c4b43fc00d13281082c4842ec6684">More...</a><br /></td></tr>
<tr class="separator:a9f0c4b43fc00d13281082c4842ec6684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71fadb34e35ed36540921822b7284ae"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa71fadb34e35ed36540921822b7284ae">xxmodulebase___vector_ftl::vector_</a> (this)</td></tr>
<tr class="memdesc:aa71fadb34e35ed36540921822b7284ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector destructor Destroys the container object.  <a href="namespacexxmodulebase______vector__ftl.html#aa71fadb34e35ed36540921822b7284ae">More...</a><br /></td></tr>
<tr class="separator:aa71fadb34e35ed36540921822b7284ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6970fb53364dc0c08ef61bd8f75d9e1d">xxmodulebase___vector_ftl::vector_begin</a> (this)</td></tr>
<tr class="memdesc:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to beginning Returns an iterator pointing to the first element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacexxmodulebase______vector__ftl.html#a6970fb53364dc0c08ef61bd8f75d9e1d">More...</a><br /></td></tr>
<tr class="separator:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c121bbcb747aced22089b1a1a7f84a2"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a5c121bbcb747aced22089b1a1a7f84a2">xxmodulebase___vector_ftl::vector_end</a> (this)</td></tr>
<tr class="memdesc:a5c121bbcb747aced22089b1a1a7f84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to end Returns an iterator referring to the last element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacexxmodulebase______vector__ftl.html#a5c121bbcb747aced22089b1a1a7f84a2">More...</a><br /></td></tr>
<tr class="separator:a5c121bbcb747aced22089b1a1a7f84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63172a6c006a0550d0102359cd357d72"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a63172a6c006a0550d0102359cd357d72">xxmodulebase___vector_ftl::vector_empty</a> (this)</td></tr>
<tr class="memdesc:a63172a6c006a0550d0102359cd357d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether container is empty Returns whether the vector container is empty (i.e. whether its size is 0). This function does not modify the container in any way.  <a href="namespacexxmodulebase______vector__ftl.html#a63172a6c006a0550d0102359cd357d72">More...</a><br /></td></tr>
<tr class="separator:a63172a6c006a0550d0102359cd357d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085dbc3c35066690fa745aefb380d1b7"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a085dbc3c35066690fa745aefb380d1b7">xxmodulebase___vector_ftl::vector_size</a> (this)</td></tr>
<tr class="memdesc:a085dbc3c35066690fa745aefb380d1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size Returns the number of elements in the vector container.  <a href="namespacexxmodulebase______vector__ftl.html#a085dbc3c35066690fa745aefb380d1b7">More...</a><br /></td></tr>
<tr class="separator:a085dbc3c35066690fa745aefb380d1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a3e5ca2cad1605f247b49b1ef0af0363b">xxmodulebase___vector_ftl::vector_max_size</a> ()</td></tr>
<tr class="memdesc:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum size Returns the maximum number of elements that the vector container can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached.  <a href="namespacexxmodulebase______vector__ftl.html#a3e5ca2cad1605f247b49b1ef0af0363b">More...</a><br /></td></tr>
<tr class="separator:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af798f0b0b8e76578a9954dd5350fcbee"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af798f0b0b8e76578a9954dd5350fcbee">xxmodulebase___vector_ftl::vector_capacity</a> (this)</td></tr>
<tr class="memdesc:af798f0b0b8e76578a9954dd5350fcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of allocated storage capacity Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space). The capacity of a vector can be explicitly altered by calling member vecto::reserve.  <a href="namespacexxmodulebase______vector__ftl.html#af798f0b0b8e76578a9954dd5350fcbee">More...</a><br /></td></tr>
<tr class="separator:af798f0b0b8e76578a9954dd5350fcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a7cf4f327e8ac97f513950ad0b7bee23d">xxmodulebase___vector_ftl::vector_front</a> (this)</td></tr>
<tr class="memdesc:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element Returns a reference to the first element in the vector container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacexxmodulebase______vector__ftl.html#a7cf4f327e8ac97f513950ad0b7bee23d">More...</a><br /></td></tr>
<tr class="separator:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b404447da579545604b614c3fac8a"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad17b404447da579545604b614c3fac8a">xxmodulebase___vector_ftl::vector_back</a> (this)</td></tr>
<tr class="memdesc:ad17b404447da579545604b614c3fac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element Returns a reference to the last element in the vector container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacexxmodulebase______vector__ftl.html#ad17b404447da579545604b614c3fac8a">More...</a><br /></td></tr>
<tr class="separator:ad17b404447da579545604b614c3fac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4479e9ca761c197765e3e8be65550190"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a4479e9ca761c197765e3e8be65550190">xxmodulebase___vector_ftl::vector_assign_from_range</a> (this, first, last)</td></tr>
<tr class="memdesc:a4479e9ca761c197765e3e8be65550190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (1), the new contents are elements constructed from each of the elements in the range between first and last, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a4479e9ca761c197765e3e8be65550190">More...</a><br /></td></tr>
<tr class="separator:a4479e9ca761c197765e3e8be65550190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af8f8d4c4f9fba98033a5fe496dbcef70">xxmodulebase___vector_ftl::vector_assign_from_fill</a> (this, n, val)</td></tr>
<tr class="memdesc:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (2), the new contents are n elements, each initialized to a copy of val.  <a href="namespacexxmodulebase______vector__ftl.html#af8f8d4c4f9fba98033a5fe496dbcef70">More...</a><br /></td></tr>
<tr class="separator:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac6b808cfa1bbc3b2e54cd02d53281430">xxmodulebase___vector_ftl::vector_assign_from_array</a> (this, val)</td></tr>
<tr class="memdesc:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a vector from an array.  <a href="namespacexxmodulebase______vector__ftl.html#ac6b808cfa1bbc3b2e54cd02d53281430">More...</a><br /></td></tr>
<tr class="separator:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6597506c25184a35e9274c69bea4455c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6597506c25184a35e9274c69bea4455c">xxmodulebase___vector_ftl::vector_push_front</a> (this, val)</td></tr>
<tr class="memdesc:a6597506c25184a35e9274c69bea4455c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at beginning Inserts a new element at the beginning of the vector, right before its current first element. The content of val is copied (or moved) to the inserted element. This effectively increases the container size by one.  <a href="namespacexxmodulebase______vector__ftl.html#a6597506c25184a35e9274c69bea4455c">More...</a><br /></td></tr>
<tr class="separator:a6597506c25184a35e9274c69bea4455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856bc550e4e33c11424d5b0e3531507e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a856bc550e4e33c11424d5b0e3531507e">xxmodulebase___vector_ftl::vector_pop_front</a> (this)</td></tr>
<tr class="memdesc:a856bc550e4e33c11424d5b0e3531507e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete first element Removes the first element in the vector container, effectively reducing its size by one. This destroys the removed element.  <a href="namespacexxmodulebase______vector__ftl.html#a856bc550e4e33c11424d5b0e3531507e">More...</a><br /></td></tr>
<tr class="separator:a856bc550e4e33c11424d5b0e3531507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777e3c96edd722e8ae569415dd05cbda"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a777e3c96edd722e8ae569415dd05cbda">xxmodulebase___vector_ftl::vector_push_back</a> (this, val)</td></tr>
<tr class="memdesc:a777e3c96edd722e8ae569415dd05cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at the end Adds a new element at the end of the vector container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one.  <a href="namespacexxmodulebase______vector__ftl.html#a777e3c96edd722e8ae569415dd05cbda">More...</a><br /></td></tr>
<tr class="separator:a777e3c96edd722e8ae569415dd05cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a4dc6fd3d3c34f6bbc9ed988e6bcf54b5">xxmodulebase___vector_ftl::vector_pop_back</a> (this)</td></tr>
<tr class="memdesc:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete last element Removes the last element in the vector container, effectively reducing the container size by one. This destroys the removed element.  <a href="namespacexxmodulebase______vector__ftl.html#a4dc6fd3d3c34f6bbc9ed988e6bcf54b5">More...</a><br /></td></tr>
<tr class="separator:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2561a414ffc51a6153378705dda3e2"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a3a2561a414ffc51a6153378705dda3e2">xxmodulebase___vector_ftl::vector_insert_single</a> (this, iterator, val)</td></tr>
<tr class="memdesc:a3a2561a414ffc51a6153378705dda3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by one. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a3a2561a414ffc51a6153378705dda3e2">More...</a><br /></td></tr>
<tr class="separator:a3a2561a414ffc51a6153378705dda3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1778706c24f73ed7c04382d9c9f848"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6b1778706c24f73ed7c04382d9c9f848">xxmodulebase___vector_ftl::vector_insert_single_at</a> (this, index, val)</td></tr>
<tr class="memdesc:a6b1778706c24f73ed7c04382d9c9f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by one. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a6b1778706c24f73ed7c04382d9c9f848">More...</a><br /></td></tr>
<tr class="separator:a6b1778706c24f73ed7c04382d9c9f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa438341f3726df6e9e34e42f07a71d06"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa438341f3726df6e9e34e42f07a71d06">xxmodulebase___vector_ftl::vector_insert_fill</a> (this, iterator, n, val)</td></tr>
<tr class="memdesc:aa438341f3726df6e9e34e42f07a71d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by n. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#aa438341f3726df6e9e34e42f07a71d06">More...</a><br /></td></tr>
<tr class="separator:aa438341f3726df6e9e34e42f07a71d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d1e9f17969abe336bc20f6f9541da"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a600d1e9f17969abe336bc20f6f9541da">xxmodulebase___vector_ftl::vector_insert_fill_at</a> (this, index, n, val)</td></tr>
<tr class="memdesc:a600d1e9f17969abe336bc20f6f9541da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a600d1e9f17969abe336bc20f6f9541da">More...</a><br /></td></tr>
<tr class="separator:a600d1e9f17969abe336bc20f6f9541da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a9f79a0d75683c1fe6cb99cdde65936aa">xxmodulebase___vector_ftl::vector_insert_range</a> (this, iterator, first, last)</td></tr>
<tr class="memdesc:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted.  <a href="namespacexxmodulebase______vector__ftl.html#a9f79a0d75683c1fe6cb99cdde65936aa">More...</a><br /></td></tr>
<tr class="separator:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b11394297f1206126e5fb1926c244b"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a81b11394297f1206126e5fb1926c244b">xxmodulebase___vector_ftl::vector_insert_range_at</a> (this, index, first, last)</td></tr>
<tr class="memdesc:a81b11394297f1206126e5fb1926c244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted.  <a href="namespacexxmodulebase______vector__ftl.html#a81b11394297f1206126e5fb1926c244b">More...</a><br /></td></tr>
<tr class="separator:a81b11394297f1206126e5fb1926c244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a51a21d1c3b3cd2d83d70418f902a01fa">xxmodulebase___vector_ftl::vector_insert_array</a> (this, iterator, val)</td></tr>
<tr class="memdesc:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the size of the array. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a51a21d1c3b3cd2d83d70418f902a01fa">More...</a><br /></td></tr>
<tr class="separator:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8013588260e0a76eb434e7d901642610"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8013588260e0a76eb434e7d901642610">xxmodulebase___vector_ftl::vector_insert_array_at</a> (this, index, val)</td></tr>
<tr class="memdesc:a8013588260e0a76eb434e7d901642610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a8013588260e0a76eb434e7d901642610">More...</a><br /></td></tr>
<tr class="separator:a8013588260e0a76eb434e7d901642610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ceda421c23eb7713c04248e894dd6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ae10ceda421c23eb7713c04248e894dd6">xxmodulebase___vector_ftl::vector_erase_single</a> (this, iterator)</td></tr>
<tr class="memdesc:ae10ceda421c23eb7713c04248e894dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a single element (position) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#ae10ceda421c23eb7713c04248e894dd6">More...</a><br /></td></tr>
<tr class="separator:ae10ceda421c23eb7713c04248e894dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dd8752f465f7cdd28fcfac73b5abab"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a31dd8752f465f7cdd28fcfac73b5abab">xxmodulebase___vector_ftl::vector_erase_single_at</a> (this, index)</td></tr>
<tr class="memdesc:a31dd8752f465f7cdd28fcfac73b5abab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a single element (position by absolute index) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated.  <a href="namespacexxmodulebase______vector__ftl.html#a31dd8752f465f7cdd28fcfac73b5abab">More...</a><br /></td></tr>
<tr class="separator:a31dd8752f465f7cdd28fcfac73b5abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6b8965bf3ca02635ba07733095020"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad3a6b8965bf3ca02635ba07733095020">xxmodulebase___vector_ftl::vector_erase_range</a> (this, first, last)</td></tr>
<tr class="memdesc:ad3a6b8965bf3ca02635ba07733095020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#ad3a6b8965bf3ca02635ba07733095020">More...</a><br /></td></tr>
<tr class="separator:ad3a6b8965bf3ca02635ba07733095020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac9c13bdd61489b6ee6f0a6f3972dc15b">xxmodulebase___vector_ftl::vector_erase_range_at</a> (this, ifirst, ilast)</td></tr>
<tr class="memdesc:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed.  <a href="namespacexxmodulebase______vector__ftl.html#ac9c13bdd61489b6ee6f0a6f3972dc15b">More...</a><br /></td></tr>
<tr class="separator:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934f13e9ec300de57a75e4ddcdd0394"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a1934f13e9ec300de57a75e4ddcdd0394">xxmodulebase___vector_ftl::vector_swap</a> (this, other)</td></tr>
<tr class="memdesc:a1934f13e9ec300de57a75e4ddcdd0394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content Exchanges the content of the container by the content of other, which is another vector of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in other before the call, and the elements of other are those which were in this. All iterators, references and pointers remain valid for the swapped objects.  <a href="namespacexxmodulebase______vector__ftl.html#a1934f13e9ec300de57a75e4ddcdd0394">More...</a><br /></td></tr>
<tr class="separator:a1934f13e9ec300de57a75e4ddcdd0394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb8b4cd18bfc5c3812e372779510735"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8eb8b4cd18bfc5c3812e372779510735">xxmodulebase___vector_ftl::vector_resize</a> (this, n, val)</td></tr>
<tr class="memdesc:a8eb8b4cd18bfc5c3812e372779510735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized.  <a href="namespacexxmodulebase______vector__ftl.html#a8eb8b4cd18bfc5c3812e372779510735">More...</a><br /></td></tr>
<tr class="separator:a8eb8b4cd18bfc5c3812e372779510735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad829da9e508913f888d2784bb44fbc8e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad829da9e508913f888d2784bb44fbc8e">xxmodulebase___vector_ftl::vector_clear</a> (this)</td></tr>
<tr class="memdesc:ad829da9e508913f888d2784bb44fbc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear content Removes all elements from the vector container (which are destroyed) and leaving the container with a size of 0.  <a href="namespacexxmodulebase______vector__ftl.html#ad829da9e508913f888d2784bb44fbc8e">More...</a><br /></td></tr>
<tr class="separator:ad829da9e508913f888d2784bb44fbc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace15fda8e6184f543ffbb91a278ce251"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ace15fda8e6184f543ffbb91a278ce251">xxmodulebase___vector_ftl::vector_at_get</a> (this, index)</td></tr>
<tr class="memdesc:ace15fda8e6184f543ffbb91a278ce251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given position.  <a href="namespacexxmodulebase______vector__ftl.html#ace15fda8e6184f543ffbb91a278ce251">More...</a><br /></td></tr>
<tr class="separator:ace15fda8e6184f543ffbb91a278ce251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861037895ce3d24453e015e536abb63d"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a861037895ce3d24453e015e536abb63d">xxmodulebase___vector_ftl::vector_element_from_index</a> (this, index)</td></tr>
<tr class="memdesc:a861037895ce3d24453e015e536abb63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value pointed by the index.  <a href="namespacexxmodulebase______vector__ftl.html#a861037895ce3d24453e015e536abb63d">More...</a><br /></td></tr>
<tr class="separator:a861037895ce3d24453e015e536abb63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866f8de383db6264a14e13d09f0fb51b"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a866f8de383db6264a14e13d09f0fb51b">xxmodulebase___vector_ftl::vector_element_ptr_from_index</a> (this, index)</td></tr>
<tr class="memdesc:a866f8de383db6264a14e13d09f0fb51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value pointed by the index.  <a href="namespacexxmodulebase______vector__ftl.html#a866f8de383db6264a14e13d09f0fb51b">More...</a><br /></td></tr>
<tr class="separator:a866f8de383db6264a14e13d09f0fb51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf42b19a13bd697dc6ddafb88709108f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adf42b19a13bd697dc6ddafb88709108f">xxmodulebase___vector_ftl::vector_element_to_index</a> (this, index, element)</td></tr>
<tr class="memdesc:adf42b19a13bd697dc6ddafb88709108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value pointed by the index Provide destructor is the replaced element has complex memory components.  <a href="namespacexxmodulebase______vector__ftl.html#adf42b19a13bd697dc6ddafb88709108f">More...</a><br /></td></tr>
<tr class="separator:adf42b19a13bd697dc6ddafb88709108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06f394ef03d14d3d15e3d7861d98e0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#acb06f394ef03d14d3d15e3d7861d98e0">xxmodulebase___vector_ftl::vector_splice_vector</a> (this, position, source)</td></tr>
<tr class="memdesc:acb06f394ef03d14d3d15e3d7861d98e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (1) transfers all the elements of source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#acb06f394ef03d14d3d15e3d7861d98e0">More...</a><br /></td></tr>
<tr class="separator:acb06f394ef03d14d3d15e3d7861d98e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ada4031bf2360335909542beecbac1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a51ada4031bf2360335909542beecbac1">xxmodulebase___vector_ftl::vector_splice_single</a> (this, position, source, it)</td></tr>
<tr class="memdesc:a51ada4031bf2360335909542beecbac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (2) transfers only the element pointed by iterator from x into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a51ada4031bf2360335909542beecbac1">More...</a><br /></td></tr>
<tr class="separator:a51ada4031bf2360335909542beecbac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8158e1eb388a9d9229efe4bac1554ec7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8158e1eb388a9d9229efe4bac1554ec7">xxmodulebase___vector_ftl::vector_splice_range</a> (this, position, source, first, last)</td></tr>
<tr class="memdesc:a8158e1eb388a9d9229efe4bac1554ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (3) transfers the range (first,last) from source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a8158e1eb388a9d9229efe4bac1554ec7">More...</a><br /></td></tr>
<tr class="separator:a8158e1eb388a9d9229efe4bac1554ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3d89563ebaa91146e5c340870dd650"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ace3d89563ebaa91146e5c340870dd650">xxmodulebase___vector_ftl::vector_splice_nodes</a> (this, position, source, ifirst, ilast)</td></tr>
<tr class="memdesc:ace3d89563ebaa91146e5c340870dd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Actual implementation of splcie at node level.  <a href="namespacexxmodulebase______vector__ftl.html#ace3d89563ebaa91146e5c340870dd650">More...</a><br /></td></tr>
<tr class="separator:ace3d89563ebaa91146e5c340870dd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680497affafe3232ee719cf52aadd8de"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a680497affafe3232ee719cf52aadd8de">xxmodulebase___vector_ftl::vector_remove</a> (this, val)</td></tr>
<tr class="memdesc:a680497affafe3232ee719cf52aadd8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements with specific value Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed.  <a href="namespacexxmodulebase______vector__ftl.html#a680497affafe3232ee719cf52aadd8de">More...</a><br /></td></tr>
<tr class="separator:a680497affafe3232ee719cf52aadd8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc13aace88a74cd6a5497f72b9abc8db"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adc13aace88a74cd6a5497f72b9abc8db">xxmodulebase___vector_ftl::vector_remove_if</a> (this, pred)</td></tr>
<tr class="memdesc:adc13aace88a74cd6a5497f72b9abc8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements fulfilling condition Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. The function calls pred(iget_element()) for each element (where i is an iterator to that element). Any of the elements in the vector for which this returns true, are removed from the container.  <a href="namespacexxmodulebase______vector__ftl.html#adc13aace88a74cd6a5497f72b9abc8db">More...</a><br /></td></tr>
<tr class="separator:adc13aace88a74cd6a5497f72b9abc8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dc7ce6119ce9d537ca66c895b2104f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a73dc7ce6119ce9d537ca66c895b2104f">xxmodulebase___vector_ftl::vector_unique</a> (this, bpred)</td></tr>
<tr class="memdesc:a73dc7ce6119ce9d537ca66c895b2104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate values (1) removes all but the first element from every consecutive group of equal elements in the container. (2) takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(*i,*j)) for all pairs of elements (where i and j are iterators to the elements) and remove j from the vector if the predicate returns true.  <a href="namespacexxmodulebase______vector__ftl.html#a73dc7ce6119ce9d537ca66c895b2104f">More...</a><br /></td></tr>
<tr class="separator:a73dc7ce6119ce9d537ca66c895b2104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d94cb067c77566595e93f29c403fb1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a37d94cb067c77566595e93f29c403fb1">xxmodulebase___vector_ftl::vector_merge</a> (this, other, comp)</td></tr>
<tr class="memdesc:a37d94cb067c77566595e93f29c403fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted vectors Merges other into the vector by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in other (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether other is an lvalue or an rvalue, or whether the value_type supports move-construction or not. (1) Each element of other is inserted at the position that corresponds to its value according to the strict weak ordering defined by operator &lt; or comp. The resulting order of equivalent elements is stable (i.e., equivalent elements preserve the relative order they had before the call, and existing elements precede those equivalent inserted from other). (2) Take a specific predicate (comp) to perform the comparison operation between elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). This function requires that the vector containers have their elements already ordered by value (or by comp) before the call. The function does nothing if (other == this).  <a href="namespacexxmodulebase______vector__ftl.html#a37d94cb067c77566595e93f29c403fb1">More...</a><br /></td></tr>
<tr class="separator:a37d94cb067c77566595e93f29c403fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241450beb546614b735b6221f1f1ebeb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a241450beb546614b735b6221f1f1ebeb">xxmodulebase___vector_ftl::vector_sort</a> (this, compare)</td></tr>
<tr class="memdesc:a241450beb546614b735b6221f1f1ebeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort elements in container Sorts the elements in the vector, altering their position within the container. (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements (2) The sorting is performed by applying an algorithm that uses comp to compare elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). The resulting order of equivalent elements is stable: i.e., equivalent elements preserve the relative order they had before the call. The entire operation does not involve the construction, destruction or copy of any element object. Elements are moved within the container.  <a href="namespacexxmodulebase______vector__ftl.html#a241450beb546614b735b6221f1f1ebeb">More...</a><br /></td></tr>
<tr class="separator:a241450beb546614b735b6221f1f1ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe170dda401536c1f1864968ad3b9500"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#afe170dda401536c1f1864968ad3b9500">xxmodulebase___vector_ftl::quick_sort</a> (this, left, right, compare)</td></tr>
<tr class="memdesc:afe170dda401536c1f1864968ad3b9500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting subroutine (Quick-sort method) algorithm kernel.  <a href="namespacexxmodulebase______vector__ftl.html#afe170dda401536c1f1864968ad3b9500">More...</a><br /></td></tr>
<tr class="separator:afe170dda401536c1f1864968ad3b9500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0baff42772597c4d4136c6fd34b0477"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac0baff42772597c4d4136c6fd34b0477">xxmodulebase___vector_ftl::vector_swap_index</a> (this, index1, index2)</td></tr>
<tr class="memdesc:ac0baff42772597c4d4136c6fd34b0477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two elements in a vector from their indexes.  <a href="namespacexxmodulebase______vector__ftl.html#ac0baff42772597c4d4136c6fd34b0477">More...</a><br /></td></tr>
<tr class="separator:ac0baff42772597c4d4136c6fd34b0477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35a7d025524f49a0396cceeb2b6508e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af35a7d025524f49a0396cceeb2b6508e">xxmodulebase___vector_ftl::vector_iterator_swap_iterators</a> (iter1, iter2)</td></tr>
<tr class="memdesc:af35a7d025524f49a0396cceeb2b6508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes in a vector pointed by iterators.  <a href="namespacexxmodulebase______vector__ftl.html#af35a7d025524f49a0396cceeb2b6508e">More...</a><br /></td></tr>
<tr class="separator:af35a7d025524f49a0396cceeb2b6508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e6c79f4685e68be805772e463853f"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a070e6c79f4685e68be805772e463853f">xxmodulebase___vector_ftl::vector_reverse</a> (this)</td></tr>
<tr class="memdesc:a070e6c79f4685e68be805772e463853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of elements in a vector.  <a href="namespacexxmodulebase______vector__ftl.html#a070e6c79f4685e68be805772e463853f">More...</a><br /></td></tr>
<tr class="separator:a070e6c79f4685e68be805772e463853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cdb1890480c32ffebfab225b42c9da"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa9cdb1890480c32ffebfab225b42c9da">xxmodulebase___vector_ftl::vector_binary_search</a> (this, item, isless, isgreater)</td></tr>
<tr class="memdesc:aa9cdb1890480c32ffebfab225b42c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted vector) front-end.  <a href="namespacexxmodulebase______vector__ftl.html#aa9cdb1890480c32ffebfab225b42c9da">More...</a><br /></td></tr>
<tr class="separator:aa9cdb1890480c32ffebfab225b42c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb1e8e054465553a9e8eec378b8867"><td class="memItemLeft" align="right" valign="top">recursive integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a85bb1e8e054465553a9e8eec378b8867">xxmodulebase___vector_ftl::recursive_binary_search</a> (this, left, right, item, isless, isgreater)</td></tr>
<tr class="memdesc:a85bb1e8e054465553a9e8eec378b8867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted vector) algorithm kernel.  <a href="namespacexxmodulebase______vector__ftl.html#a85bb1e8e054465553a9e8eec378b8867">More...</a><br /></td></tr>
<tr class="separator:a85bb1e8e054465553a9e8eec378b8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab317988a49455132919e794e74d9db52"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ab317988a49455132919e794e74d9db52">xxmodulebase___vector_ftl::vector_select</a> (this, reference, bpred)</td></tr>
<tr class="memdesc:ab317988a49455132919e794e74d9db52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a vector following certain criteria.  <a href="namespacexxmodulebase______vector__ftl.html#ab317988a49455132919e794e74d9db52">More...</a><br /></td></tr>
<tr class="separator:ab317988a49455132919e794e74d9db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0896d34861ba9a92bb51c0297fce80"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a0f0896d34861ba9a92bb51c0297fce80">xxmodulebase___vector_ftl::vector_array</a> (this)</td></tr>
<tr class="memdesc:a0f0896d34861ba9a92bb51c0297fce80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array (allocatabe) of elements from a vector.  <a href="namespacexxmodulebase______vector__ftl.html#a0f0896d34861ba9a92bb51c0297fce80">More...</a><br /></td></tr>
<tr class="separator:a0f0896d34861ba9a92bb51c0297fce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a0de605d88b5eef34e4b8bd1d5a2a7412">xxmodulebase___vector_ftl::element_assign_pointer</a> (left, right)</td></tr>
<tr class="memdesc:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______vector__ftl.html#a0de605d88b5eef34e4b8bd1d5a2a7412">More...</a><br /></td></tr>
<tr class="separator:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c93635598ac0e999a01d27262e06c"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac17c93635598ac0e999a01d27262e06c">xxmodulebase___vector_ftl::element_assign_allocatable</a> (left, right)</td></tr>
<tr class="memdesc:ac17c93635598ac0e999a01d27262e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______vector__ftl.html#ac17c93635598ac0e999a01d27262e06c">More...</a><br /></td></tr>
<tr class="separator:ac17c93635598ac0e999a01d27262e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4f8d9d84ffece2fa9712677026639"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a97d4f8d9d84ffece2fa9712677026639">xxmodulebase___vector_ftl::vector_iterator_next</a> (this)</td></tr>
<tr class="memdesc:a97d4f8d9d84ffece2fa9712677026639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to next node in the vector.  <a href="namespacexxmodulebase______vector__ftl.html#a97d4f8d9d84ffece2fa9712677026639">More...</a><br /></td></tr>
<tr class="separator:a97d4f8d9d84ffece2fa9712677026639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd95590e04683a45d40b4cb3ede460e"><td class="memItemLeft" align="right" valign="top">type(xxtypebase___vector_ftl_iterator) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#abfd95590e04683a45d40b4cb3ede460e">xxmodulebase___vector_ftl::vector_iterator_previous</a> (this)</td></tr>
<tr class="memdesc:abfd95590e04683a45d40b4cb3ede460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to previous node in the vector.  <a href="namespacexxmodulebase______vector__ftl.html#abfd95590e04683a45d40b4cb3ede460e">More...</a><br /></td></tr>
<tr class="separator:abfd95590e04683a45d40b4cb3ede460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a399094ea57e1e6f5a1abf769c38d9fe1">xxmodulebase___vector_ftl::vector_iterator_index</a> (iterator)</td></tr>
<tr class="memdesc:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector index in an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a399094ea57e1e6f5a1abf769c38d9fe1">More...</a><br /></td></tr>
<tr class="separator:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b51358c45ce7ff11e4b45e86e725e4"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a81b51358c45ce7ff11e4b45e86e725e4">xxmodulebase___vector_ftl::vector_iterator_distance</a> (origin, target)</td></tr>
<tr class="memdesc:a81b51358c45ce7ff11e4b45e86e725e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance (number of elements) between two nodes (by iterator)  <a href="namespacexxmodulebase______vector__ftl.html#a81b51358c45ce7ff11e4b45e86e725e4">More...</a><br /></td></tr>
<tr class="separator:a81b51358c45ce7ff11e4b45e86e725e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28584e56306958a555ea5dc78d7c325"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ae28584e56306958a555ea5dc78d7c325">xxmodulebase___vector_ftl::vector_iterator_associated</a> (this)</td></tr>
<tr class="memdesc:ae28584e56306958a555ea5dc78d7c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the association status of an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#ae28584e56306958a555ea5dc78d7c325">More...</a><br /></td></tr>
<tr class="separator:ae28584e56306958a555ea5dc78d7c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13385e157e24114a9d8d38a289766c6"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa13385e157e24114a9d8d38a289766c6">xxmodulebase___vector_ftl::vector_iterator_nullify</a> (this)</td></tr>
<tr class="memdesc:aa13385e157e24114a9d8d38a289766c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#aa13385e157e24114a9d8d38a289766c6">More...</a><br /></td></tr>
<tr class="separator:aa13385e157e24114a9d8d38a289766c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8078ba63473bd35d4855cdb00a698065"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8078ba63473bd35d4855cdb00a698065">xxmodulebase___vector_ftl::vector_iterator_get_element</a> (this)</td></tr>
<tr class="memdesc:a8078ba63473bd35d4855cdb00a698065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an elememnt in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a8078ba63473bd35d4855cdb00a698065">More...</a><br /></td></tr>
<tr class="separator:a8078ba63473bd35d4855cdb00a698065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb01963ba439e4a3186dd2fde150317"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adeb01963ba439e4a3186dd2fde150317">xxmodulebase___vector_ftl::vector_iterator_get_element_ptr</a> (this)</td></tr>
<tr class="memdesc:adeb01963ba439e4a3186dd2fde150317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data elememnt in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#adeb01963ba439e4a3186dd2fde150317">More...</a><br /></td></tr>
<tr class="separator:adeb01963ba439e4a3186dd2fde150317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cba7a597671043c0d460f1885f21ffb"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a2cba7a597671043c0d460f1885f21ffb">xxmodulebase___vector_ftl::vector_iterator_set_element</a> (this, val)</td></tr>
<tr class="memdesc:a2cba7a597671043c0d460f1885f21ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a2cba7a597671043c0d460f1885f21ffb">More...</a><br /></td></tr>
<tr class="separator:a2cba7a597671043c0d460f1885f21ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a99cf28d9f6d17ab4e0512782cdc0a03b">xxmodulebase___vector_ftl::vector_iterator_assign</a> (left, right)</td></tr>
<tr class="memdesc:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an interator from an existing iterator (assignment operator) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a99cf28d9f6d17ab4e0512782cdc0a03b">More...</a><br /></td></tr>
<tr class="separator:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a00942d16c7f4fdedf80c33bbb1f73fed">xxmodulebase___vector_ftl::vector_iterator_equal</a> (left, right)</td></tr>
<tr class="memdesc:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterators (equality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a00942d16c7f4fdedf80c33bbb1f73fed">More...</a><br /></td></tr>
<tr class="separator:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eccd0a8a293145fa7294a672dee9e2"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af0eccd0a8a293145fa7294a672dee9e2">xxmodulebase___vector_ftl::vector_iterator_not_equal</a> (left, right)</td></tr>
<tr class="memdesc:af0eccd0a8a293145fa7294a672dee9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterator (inequality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#af0eccd0a8a293145fa7294a672dee9e2">More...</a><br /></td></tr>
<tr class="separator:af0eccd0a8a293145fa7294a672dee9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4144cda43048fe4d887b6d8af894713"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad4144cda43048fe4d887b6d8af894713">xxmodulebase___vector_ftl::vector_reserve</a> (this, capacity)</td></tr>
<tr class="memdesc:ad4144cda43048fe4d887b6d8af894713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements.  <a href="namespacexxmodulebase______vector__ftl.html#ad4144cda43048fe4d887b6d8af894713">More...</a><br /></td></tr>
<tr class="separator:ad4144cda43048fe4d887b6d8af894713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a624e74d138f86d0f7ce550f8f01d2ec8">xxmodulebase___vector_ftl::vector_realloc</a> (this)</td></tr>
<tr class="memdesc:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal array memory handling (realloc)  <a href="namespacexxmodulebase______vector__ftl.html#a624e74d138f86d0f7ce550f8f01d2ec8">More...</a><br /></td></tr>
<tr class="separator:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a64d60d3cf51a6b56971c81de40544661"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a64d60d3cf51a6b56971c81de40544661">xxmodulebase___vector_ftl::vector_base_capacity</a> = 100</td></tr>
<tr class="memdesc:a64d60d3cf51a6b56971c81de40544661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference vector size parameters.  <a href="namespacexxmodulebase______vector__ftl.html#a64d60d3cf51a6b56971c81de40544661">More...</a><br /></td></tr>
<tr class="separator:a64d60d3cf51a6b56971c81de40544661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d7526b874d8b603ef4793e8112785"><td class="memItemLeft" align="right" valign="top">real, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac40d7526b874d8b603ef4793e8112785">xxmodulebase___vector_ftl::vector_base_capacity_increase</a> = 1.5</td></tr>
<tr class="separator:ac40d7526b874d8b603ef4793e8112785"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
