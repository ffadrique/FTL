<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FTL: xxmodulebase___tree_ftl Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FTL
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Fortran Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">xxmodulebase___tree_ftl Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree node type.  <a href="structxxmodulebase______tree__ftl_1_1t__tree__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______tree__ftl_1_1xxconstructor______tree__ftl.html">xxconstructor___tree_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor interface.  <a href="interfacexxmodulebase______tree__ftl_1_1xxconstructor______tree__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree management type (tree root)  <a href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree iterator type.  <a href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ae9d0339c68bb46e487c165c7360df785"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ae9d0339c68bb46e487c165c7360df785">tree_default</a> ()</td></tr>
<tr class="memdesc:ae9d0339c68bb46e487c165c7360df785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="namespacexxmodulebase______tree__ftl.html#ae9d0339c68bb46e487c165c7360df785">More...</a><br /></td></tr>
<tr class="separator:ae9d0339c68bb46e487c165c7360df785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01cf53a05c2a6d5ad93a7f8fea11609"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af01cf53a05c2a6d5ad93a7f8fea11609">tree_copy</a> (other)</td></tr>
<tr class="memdesc:af01cf53a05c2a6d5ad93a7f8fea11609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="namespacexxmodulebase______tree__ftl.html#af01cf53a05c2a6d5ad93a7f8fea11609">More...</a><br /></td></tr>
<tr class="separator:af01cf53a05c2a6d5ad93a7f8fea11609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665597201084dd41b40acd6a081bb12d"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a665597201084dd41b40acd6a081bb12d">tree_</a> (this)</td></tr>
<tr class="memdesc:a665597201084dd41b40acd6a081bb12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="namespacexxmodulebase______tree__ftl.html#a665597201084dd41b40acd6a081bb12d">More...</a><br /></td></tr>
<tr class="separator:a665597201084dd41b40acd6a081bb12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4383e29b79b9bc92b9bfa091d4eb7c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a7f4383e29b79b9bc92b9bfa091d4eb7c">tree_push_front_child_tree</a> (this, val)</td></tr>
<tr class="memdesc:a7f4383e29b79b9bc92b9bfa091d4eb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node at the beginning of the tree root children list; include element if present.  <a href="namespacexxmodulebase______tree__ftl.html#a7f4383e29b79b9bc92b9bfa091d4eb7c">More...</a><br /></td></tr>
<tr class="separator:a7f4383e29b79b9bc92b9bfa091d4eb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10651f2e743c8eb1df96ead8d5661d5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ad10651f2e743c8eb1df96ead8d5661d5">tree_push_front_child_iterator</a> (iterator, val)</td></tr>
<tr class="memdesc:ad10651f2e743c8eb1df96ead8d5661d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the beginning of the children list; include element if present This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#ad10651f2e743c8eb1df96ead8d5661d5">More...</a><br /></td></tr>
<tr class="separator:ad10651f2e743c8eb1df96ead8d5661d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93890ddf836ea0df1e0af920e814cdbb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a93890ddf836ea0df1e0af920e814cdbb">tree_push_front_child_node</a> (this, val)</td></tr>
<tr class="memdesc:a93890ddf836ea0df1e0af920e814cdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the beginning of the children list; include element if present.  <a href="namespacexxmodulebase______tree__ftl.html#a93890ddf836ea0df1e0af920e814cdbb">More...</a><br /></td></tr>
<tr class="separator:a93890ddf836ea0df1e0af920e814cdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab60afa3276b59add70920bdf2a4fc6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#afab60afa3276b59add70920bdf2a4fc6">tree_push_back_child_tree</a> (this, val)</td></tr>
<tr class="memdesc:afab60afa3276b59add70920bdf2a4fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node at the end of the tree root children list; include element if present.  <a href="namespacexxmodulebase______tree__ftl.html#afab60afa3276b59add70920bdf2a4fc6">More...</a><br /></td></tr>
<tr class="separator:afab60afa3276b59add70920bdf2a4fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c9e2fc1468c001337c0bb695592d3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a4f9c9e2fc1468c001337c0bb695592d3">tree_push_back_child_iterator</a> (iterator, val)</td></tr>
<tr class="memdesc:a4f9c9e2fc1468c001337c0bb695592d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the end of the children list; include element if present This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a4f9c9e2fc1468c001337c0bb695592d3">More...</a><br /></td></tr>
<tr class="separator:a4f9c9e2fc1468c001337c0bb695592d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e86c8c41ed92a51b1b93926bf28e065"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a7e86c8c41ed92a51b1b93926bf28e065">tree_push_back_child_node</a> (this, val)</td></tr>
<tr class="memdesc:a7e86c8c41ed92a51b1b93926bf28e065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the end of the children list; include element if present.  <a href="namespacexxmodulebase______tree__ftl.html#a7e86c8c41ed92a51b1b93926bf28e065">More...</a><br /></td></tr>
<tr class="separator:a7e86c8c41ed92a51b1b93926bf28e065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf01ded85253e0fd1839c1ef3cef2ba7"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#acf01ded85253e0fd1839c1ef3cef2ba7">tree_pop_front_child_tree</a> (this)</td></tr>
<tr class="memdesc:acf01ded85253e0fd1839c1ef3cef2ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node at the beginning of the tree root children list.  <a href="namespacexxmodulebase______tree__ftl.html#acf01ded85253e0fd1839c1ef3cef2ba7">More...</a><br /></td></tr>
<tr class="separator:acf01ded85253e0fd1839c1ef3cef2ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df2040bd6328dfd4a1df4b86b22550"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af7df2040bd6328dfd4a1df4b86b22550">tree_pop_front_child_iterator</a> (iterator)</td></tr>
<tr class="memdesc:af7df2040bd6328dfd4a1df4b86b22550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node at the beginning of the children list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#af7df2040bd6328dfd4a1df4b86b22550">More...</a><br /></td></tr>
<tr class="separator:af7df2040bd6328dfd4a1df4b86b22550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f454169aec25bf91c420fccf86c388"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a62f454169aec25bf91c420fccf86c388">tree_pop_front_child_node</a> (this)</td></tr>
<tr class="memdesc:a62f454169aec25bf91c420fccf86c388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node to the beginning of the children list.  <a href="namespacexxmodulebase______tree__ftl.html#a62f454169aec25bf91c420fccf86c388">More...</a><br /></td></tr>
<tr class="separator:a62f454169aec25bf91c420fccf86c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219fb676b5121b9b94e319f2cc46798"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a8219fb676b5121b9b94e319f2cc46798">tree_pop_back_child_tree</a> (this)</td></tr>
<tr class="memdesc:a8219fb676b5121b9b94e319f2cc46798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node at the beginning of the tree root children list.  <a href="namespacexxmodulebase______tree__ftl.html#a8219fb676b5121b9b94e319f2cc46798">More...</a><br /></td></tr>
<tr class="separator:a8219fb676b5121b9b94e319f2cc46798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfabde266492eed33b5f1daad706a31"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a7cfabde266492eed33b5f1daad706a31">tree_pop_back_child_iterator</a> (iterator)</td></tr>
<tr class="memdesc:a7cfabde266492eed33b5f1daad706a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node at the beginning of the children list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a7cfabde266492eed33b5f1daad706a31">More...</a><br /></td></tr>
<tr class="separator:a7cfabde266492eed33b5f1daad706a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1363746655767cc1f5f777b9b2afd003"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a1363746655767cc1f5f777b9b2afd003">tree_pop_back_child_node</a> (this)</td></tr>
<tr class="memdesc:a1363746655767cc1f5f777b9b2afd003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node to the end of the children list.  <a href="namespacexxmodulebase______tree__ftl.html#a1363746655767cc1f5f777b9b2afd003">More...</a><br /></td></tr>
<tr class="separator:a1363746655767cc1f5f777b9b2afd003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f35e95aaaf517ad463ffe1161c5fb31"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a2f35e95aaaf517ad463ffe1161c5fb31">tree_push_front_sibling</a> (iterator, val)</td></tr>
<tr class="memdesc:a2f35e95aaaf517ad463ffe1161c5fb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the beginning of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a2f35e95aaaf517ad463ffe1161c5fb31">More...</a><br /></td></tr>
<tr class="separator:a2f35e95aaaf517ad463ffe1161c5fb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0437defd3dc3a4ecb07d8587306727b7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a0437defd3dc3a4ecb07d8587306727b7">tree_push_back_sibling</a> (iterator, val)</td></tr>
<tr class="memdesc:a0437defd3dc3a4ecb07d8587306727b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to the end of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a0437defd3dc3a4ecb07d8587306727b7">More...</a><br /></td></tr>
<tr class="separator:a0437defd3dc3a4ecb07d8587306727b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767d852b5757f70d99bde57923995009"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a767d852b5757f70d99bde57923995009">tree_pop_front_sibling</a> (iterator)</td></tr>
<tr class="memdesc:a767d852b5757f70d99bde57923995009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node from the beginning of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a767d852b5757f70d99bde57923995009">More...</a><br /></td></tr>
<tr class="separator:a767d852b5757f70d99bde57923995009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e6cf9f51e7b9112cd95b26c80d736a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ac9e6cf9f51e7b9112cd95b26c80d736a">tree_pop_back_sibling</a> (iterator)</td></tr>
<tr class="memdesc:ac9e6cf9f51e7b9112cd95b26c80d736a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node from the end of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#ac9e6cf9f51e7b9112cd95b26c80d736a">More...</a><br /></td></tr>
<tr class="separator:ac9e6cf9f51e7b9112cd95b26c80d736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f314d2f3cd62b1e409ca4e03285c9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af80f314d2f3cd62b1e409ca4e03285c9">tree_insert_sibling</a> (iterator, val)</td></tr>
<tr class="memdesc:af80f314d2f3cd62b1e409ca4e03285c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node before node pointed by the iterator Iterator remains associated to input iterator This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#af80f314d2f3cd62b1e409ca4e03285c9">More...</a><br /></td></tr>
<tr class="separator:af80f314d2f3cd62b1e409ca4e03285c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b2c15972dc425249b8ebeee56fc2b5"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ac8b2c15972dc425249b8ebeee56fc2b5">tree_erase</a> (iterator)</td></tr>
<tr class="memdesc:ac8b2c15972dc425249b8ebeee56fc2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove node pointed by the iterator Input pointer returns not associated This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#ac8b2c15972dc425249b8ebeee56fc2b5">More...</a><br /></td></tr>
<tr class="separator:ac8b2c15972dc425249b8ebeee56fc2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b0ce91ee92f7c43f9917e505e23c9a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a00b0ce91ee92f7c43f9917e505e23c9a">tree_begin_tree</a> (this)</td></tr>
<tr class="memdesc:a00b0ce91ee92f7c43f9917e505e23c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to first node in the tree.  <a href="namespacexxmodulebase______tree__ftl.html#a00b0ce91ee92f7c43f9917e505e23c9a">More...</a><br /></td></tr>
<tr class="separator:a00b0ce91ee92f7c43f9917e505e23c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8c56518a7a513ec8921a5223a03bd7"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a4e8c56518a7a513ec8921a5223a03bd7">tree_end_tree</a> (this)</td></tr>
<tr class="memdesc:a4e8c56518a7a513ec8921a5223a03bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to last node in the tree.  <a href="namespacexxmodulebase______tree__ftl.html#a4e8c56518a7a513ec8921a5223a03bd7">More...</a><br /></td></tr>
<tr class="separator:a4e8c56518a7a513ec8921a5223a03bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74935c8d3d820f52899f66a5223ce06"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ab74935c8d3d820f52899f66a5223ce06">tree_begin_iterator</a> (this, iterator)</td></tr>
<tr class="memdesc:ab74935c8d3d820f52899f66a5223ce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to first child node in the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#ab74935c8d3d820f52899f66a5223ce06">More...</a><br /></td></tr>
<tr class="separator:ab74935c8d3d820f52899f66a5223ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447db88833081ea88547f820829c5bba"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a447db88833081ea88547f820829c5bba">tree_end_iterator</a> (this, iterator)</td></tr>
<tr class="memdesc:a447db88833081ea88547f820829c5bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to last child node in the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a447db88833081ea88547f820829c5bba">More...</a><br /></td></tr>
<tr class="separator:a447db88833081ea88547f820829c5bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffb60423af612b5d2bd5846d1ac2cc5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#acffb60423af612b5d2bd5846d1ac2cc5">tree_next_tree_node</a> (this)</td></tr>
<tr class="memdesc:acffb60423af612b5d2bd5846d1ac2cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to next node in the tree.  <a href="namespacexxmodulebase______tree__ftl.html#acffb60423af612b5d2bd5846d1ac2cc5">More...</a><br /></td></tr>
<tr class="separator:acffb60423af612b5d2bd5846d1ac2cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d551fb7af929fe7085a45c50cb09ca8"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a0d551fb7af929fe7085a45c50cb09ca8">tree_next_tree_node_up</a> (this)</td></tr>
<tr class="memdesc:a0d551fb7af929fe7085a45c50cb09ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate the tree forward from an exhausted level upwards in the hierarchy When a level is exhausted, the next node is.  <a href="namespacexxmodulebase______tree__ftl.html#a0d551fb7af929fe7085a45c50cb09ca8">More...</a><br /></td></tr>
<tr class="separator:a0d551fb7af929fe7085a45c50cb09ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b61153fcdf3381b71a45d97f2543b85"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a3b61153fcdf3381b71a45d97f2543b85">tree_previous_node</a> (this)</td></tr>
<tr class="memdesc:a3b61153fcdf3381b71a45d97f2543b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to previous node in the tree.  <a href="namespacexxmodulebase______tree__ftl.html#a3b61153fcdf3381b71a45d97f2543b85">More...</a><br /></td></tr>
<tr class="separator:a3b61153fcdf3381b71a45d97f2543b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a544b42ef3dc1d59dd818f91be7925a"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a4a544b42ef3dc1d59dd818f91be7925a">tree_associated</a> (this, other)</td></tr>
<tr class="memdesc:a4a544b42ef3dc1d59dd818f91be7925a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the association status of an iterator This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a4a544b42ef3dc1d59dd818f91be7925a">More...</a><br /></td></tr>
<tr class="separator:a4a544b42ef3dc1d59dd818f91be7925a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af325482bad47d6f3ae6a9785945864ab"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af325482bad47d6f3ae6a9785945864ab">tree_nullify</a> (this)</td></tr>
<tr class="memdesc:af325482bad47d6f3ae6a9785945864ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an iterator.  <a href="namespacexxmodulebase______tree__ftl.html#af325482bad47d6f3ae6a9785945864ab">More...</a><br /></td></tr>
<tr class="separator:af325482bad47d6f3ae6a9785945864ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31869ea0751424d82ece4d5bdb5daea"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af31869ea0751424d82ece4d5bdb5daea">tree_begin_sibling</a> (this, iterator)</td></tr>
<tr class="memdesc:af31869ea0751424d82ece4d5bdb5daea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to first sibling node to the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#af31869ea0751424d82ece4d5bdb5daea">More...</a><br /></td></tr>
<tr class="separator:af31869ea0751424d82ece4d5bdb5daea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d673ea55570ac134699b659deabd8a9"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a5d673ea55570ac134699b659deabd8a9">tree_end_sibling</a> (this, iterator)</td></tr>
<tr class="memdesc:a5d673ea55570ac134699b659deabd8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to last sibling node to the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type.  <a href="namespacexxmodulebase______tree__ftl.html#a5d673ea55570ac134699b659deabd8a9">More...</a><br /></td></tr>
<tr class="separator:a5d673ea55570ac134699b659deabd8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699829e7abc7d2785029b7214d6cf662"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a699829e7abc7d2785029b7214d6cf662">tree_next_sibling</a> (this)</td></tr>
<tr class="memdesc:a699829e7abc7d2785029b7214d6cf662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to next sibling node.  <a href="namespacexxmodulebase______tree__ftl.html#a699829e7abc7d2785029b7214d6cf662">More...</a><br /></td></tr>
<tr class="separator:a699829e7abc7d2785029b7214d6cf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e7951a597de11fd247b38a12c9b93f"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af9e7951a597de11fd247b38a12c9b93f">tree_previous_sibling</a> (this)</td></tr>
<tr class="memdesc:af9e7951a597de11fd247b38a12c9b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to previous sibling node.  <a href="namespacexxmodulebase______tree__ftl.html#af9e7951a597de11fd247b38a12c9b93f">More...</a><br /></td></tr>
<tr class="separator:af9e7951a597de11fd247b38a12c9b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827bd944872794c25d399a75f356f78b"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a827bd944872794c25d399a75f356f78b">tree_has_data</a> (this)</td></tr>
<tr class="memdesc:a827bd944872794c25d399a75f356f78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a node has data.  <a href="namespacexxmodulebase______tree__ftl.html#a827bd944872794c25d399a75f356f78b">More...</a><br /></td></tr>
<tr class="separator:a827bd944872794c25d399a75f356f78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8f2bb3799e8bc7674cf4eec033900f"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a3a8f2bb3799e8bc7674cf4eec033900f">tree_iterator_get_element</a> (this)</td></tr>
<tr class="memdesc:a3a8f2bb3799e8bc7674cf4eec033900f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the data elememnt pointed by the iterator.  <a href="namespacexxmodulebase______tree__ftl.html#a3a8f2bb3799e8bc7674cf4eec033900f">More...</a><br /></td></tr>
<tr class="separator:a3a8f2bb3799e8bc7674cf4eec033900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d9a0050012fd2a9ed262bfa447dc46"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ad0d9a0050012fd2a9ed262bfa447dc46">tree_iterator_get_element_ptr</a> (this)</td></tr>
<tr class="memdesc:ad0d9a0050012fd2a9ed262bfa447dc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data elememnt pointed by the iterator.  <a href="namespacexxmodulebase______tree__ftl.html#ad0d9a0050012fd2a9ed262bfa447dc46">More...</a><br /></td></tr>
<tr class="separator:ad0d9a0050012fd2a9ed262bfa447dc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7519a5d086a03394fac10c6b73654dc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ae7519a5d086a03394fac10c6b73654dc">tree_element_to_iterator</a> (this, val)</td></tr>
<tr class="memdesc:ae7519a5d086a03394fac10c6b73654dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value pointed by the iterator.  <a href="namespacexxmodulebase______tree__ftl.html#ae7519a5d086a03394fac10c6b73654dc">More...</a><br /></td></tr>
<tr class="separator:ae7519a5d086a03394fac10c6b73654dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3227dcdcd68159d53b65826da9eb7c8d"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a3227dcdcd68159d53b65826da9eb7c8d">tree_front</a> (this)</td></tr>
<tr class="memdesc:a3227dcdcd68159d53b65826da9eb7c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">First element in the tree.  <a href="namespacexxmodulebase______tree__ftl.html#a3227dcdcd68159d53b65826da9eb7c8d">More...</a><br /></td></tr>
<tr class="separator:a3227dcdcd68159d53b65826da9eb7c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc72692e555223a6206760bc48c6e6f3"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#acc72692e555223a6206760bc48c6e6f3">tree_back</a> (this)</td></tr>
<tr class="memdesc:acc72692e555223a6206760bc48c6e6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last element in The tree.  <a href="namespacexxmodulebase______tree__ftl.html#acc72692e555223a6206760bc48c6e6f3">More...</a><br /></td></tr>
<tr class="separator:acc72692e555223a6206760bc48c6e6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6edfa6e85a652216e6be12e6ad4d270"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ab6edfa6e85a652216e6be12e6ad4d270">tree_empty_tree</a> (this)</td></tr>
<tr class="memdesc:ab6edfa6e85a652216e6be12e6ad4d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return empty status of tree.  <a href="namespacexxmodulebase______tree__ftl.html#ab6edfa6e85a652216e6be12e6ad4d270">More...</a><br /></td></tr>
<tr class="separator:ab6edfa6e85a652216e6be12e6ad4d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdf288b79d9f2929bff020389ea5fbb"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#acbdf288b79d9f2929bff020389ea5fbb">tree_empty_iterator</a> (this)</td></tr>
<tr class="memdesc:acbdf288b79d9f2929bff020389ea5fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return empty status of node.  <a href="namespacexxmodulebase______tree__ftl.html#acbdf288b79d9f2929bff020389ea5fbb">More...</a><br /></td></tr>
<tr class="separator:acbdf288b79d9f2929bff020389ea5fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36fe48b3d5ce7d4966f6e8148ff5ae"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a7d36fe48b3d5ce7d4966f6e8148ff5ae">tree_empty_node</a> (this)</td></tr>
<tr class="memdesc:a7d36fe48b3d5ce7d4966f6e8148ff5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return empty status of node.  <a href="namespacexxmodulebase______tree__ftl.html#a7d36fe48b3d5ce7d4966f6e8148ff5ae">More...</a><br /></td></tr>
<tr class="separator:a7d36fe48b3d5ce7d4966f6e8148ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6e631fdeea70338c34c51a14f6940"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a74f6e631fdeea70338c34c51a14f6940">tree_has_children</a> (this)</td></tr>
<tr class="memdesc:a74f6e631fdeea70338c34c51a14f6940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether node has children.  <a href="namespacexxmodulebase______tree__ftl.html#a74f6e631fdeea70338c34c51a14f6940">More...</a><br /></td></tr>
<tr class="separator:a74f6e631fdeea70338c34c51a14f6940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5405b3462b8489ea5071f3ed48dc8dc8"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a5405b3462b8489ea5071f3ed48dc8dc8">tree_has_siblings</a> (this)</td></tr>
<tr class="memdesc:a5405b3462b8489ea5071f3ed48dc8dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether node has siblings.  <a href="namespacexxmodulebase______tree__ftl.html#a5405b3462b8489ea5071f3ed48dc8dc8">More...</a><br /></td></tr>
<tr class="separator:a5405b3462b8489ea5071f3ed48dc8dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5075c742f2995f7248b79e76531cb626"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a5075c742f2995f7248b79e76531cb626">tree_children</a> (this)</td></tr>
<tr class="memdesc:a5075c742f2995f7248b79e76531cb626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children in a node.  <a href="namespacexxmodulebase______tree__ftl.html#a5075c742f2995f7248b79e76531cb626">More...</a><br /></td></tr>
<tr class="separator:a5075c742f2995f7248b79e76531cb626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854a188a125e3badee575a243421483b"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a854a188a125e3badee575a243421483b">tree_siblings</a> (this)</td></tr>
<tr class="memdesc:a854a188a125e3badee575a243421483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of siblings of a node.  <a href="namespacexxmodulebase______tree__ftl.html#a854a188a125e3badee575a243421483b">More...</a><br /></td></tr>
<tr class="separator:a854a188a125e3badee575a243421483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d4339c7eedb7a8d466f0206dcfcfe"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a4d5d4339c7eedb7a8d466f0206dcfcfe">tree_parent</a> (this)</td></tr>
<tr class="memdesc:a4d5d4339c7eedb7a8d466f0206dcfcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the parent.  <a href="namespacexxmodulebase______tree__ftl.html#a4d5d4339c7eedb7a8d466f0206dcfcfe">More...</a><br /></td></tr>
<tr class="separator:a4d5d4339c7eedb7a8d466f0206dcfcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c5c49c81b1ae4b630824b5e202252"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ab44c5c49c81b1ae4b630824b5e202252">tree_depth</a> (this)</td></tr>
<tr class="memdesc:ab44c5c49c81b1ae4b630824b5e202252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the depth in a tree (from iterator); root is depth 0.  <a href="namespacexxmodulebase______tree__ftl.html#ab44c5c49c81b1ae4b630824b5e202252">More...</a><br /></td></tr>
<tr class="separator:ab44c5c49c81b1ae4b630824b5e202252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31faacc5a562dff6ce5e579ef26b5a44"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a31faacc5a562dff6ce5e579ef26b5a44">tree_sibling_position</a> (this)</td></tr>
<tr class="memdesc:a31faacc5a562dff6ce5e579ef26b5a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sibling position in a tree (from iterator); root is sibling position 0.  <a href="namespacexxmodulebase______tree__ftl.html#a31faacc5a562dff6ce5e579ef26b5a44">More...</a><br /></td></tr>
<tr class="separator:a31faacc5a562dff6ce5e579ef26b5a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84b083022c8c482c15d4273f68b01e4"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#ae84b083022c8c482c15d4273f68b01e4">tree_clear_tree</a> (this)</td></tr>
<tr class="memdesc:ae84b083022c8c482c15d4273f68b01e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the whole tree.  <a href="namespacexxmodulebase______tree__ftl.html#ae84b083022c8c482c15d4273f68b01e4">More...</a><br /></td></tr>
<tr class="separator:ae84b083022c8c482c15d4273f68b01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81557ed3fcaa3c5245ab26c09b434d37"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a81557ed3fcaa3c5245ab26c09b434d37">tree_clear_iterator</a> (iterator)</td></tr>
<tr class="memdesc:a81557ed3fcaa3c5245ab26c09b434d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the node pointed by the iterator.  <a href="namespacexxmodulebase______tree__ftl.html#a81557ed3fcaa3c5245ab26c09b434d37">More...</a><br /></td></tr>
<tr class="separator:a81557ed3fcaa3c5245ab26c09b434d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af559fe24335d9a00b122aafd5445af85"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#af559fe24335d9a00b122aafd5445af85">tree_clear_node</a> (this)</td></tr>
<tr class="memdesc:af559fe24335d9a00b122aafd5445af85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively clear the node and all descendants.  <a href="namespacexxmodulebase______tree__ftl.html#af559fe24335d9a00b122aafd5445af85">More...</a><br /></td></tr>
<tr class="separator:af559fe24335d9a00b122aafd5445af85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635cec477373d016f01b1b0161dc2e73"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a635cec477373d016f01b1b0161dc2e73">tree_swap_iterator</a> (this, other)</td></tr>
<tr class="memdesc:a635cec477373d016f01b1b0161dc2e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two elements in a tree.  <a href="namespacexxmodulebase______tree__ftl.html#a635cec477373d016f01b1b0161dc2e73">More...</a><br /></td></tr>
<tr class="separator:a635cec477373d016f01b1b0161dc2e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9268e412ad1f793e14fb9ce6eef69696"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a9268e412ad1f793e14fb9ce6eef69696">tree_swap_node</a> (this, other)</td></tr>
<tr class="memdesc:a9268e412ad1f793e14fb9ce6eef69696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two elements in a tree.  <a href="namespacexxmodulebase______tree__ftl.html#a9268e412ad1f793e14fb9ce6eef69696">More...</a><br /></td></tr>
<tr class="separator:a9268e412ad1f793e14fb9ce6eef69696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb72d2357d0a6da7456ec00a6e29ea3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a9bb72d2357d0a6da7456ec00a6e29ea3">tree_assign_from_tree</a> (this, other)</td></tr>
<tr class="memdesc:a9bb72d2357d0a6da7456ec00a6e29ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree from an exisiting tree (assignment operator)  <a href="namespacexxmodulebase______tree__ftl.html#a9bb72d2357d0a6da7456ec00a6e29ea3">More...</a><br /></td></tr>
<tr class="separator:a9bb72d2357d0a6da7456ec00a6e29ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bdbfc4c1032b5e152322f918fd39b6"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a31bdbfc4c1032b5e152322f918fd39b6">tree_add_children_from_tree</a> (itthis, itother)</td></tr>
<tr class="memdesc:a31bdbfc4c1032b5e152322f918fd39b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy recursively the nodes from the input to the output.  <a href="namespacexxmodulebase______tree__ftl.html#a31bdbfc4c1032b5e152322f918fd39b6">More...</a><br /></td></tr>
<tr class="separator:a31bdbfc4c1032b5e152322f918fd39b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73bc25314a78bc204c928bdf2859dc"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#acd73bc25314a78bc204c928bdf2859dc">tree_container_ptr</a> (this)</td></tr>
<tr class="memdesc:acd73bc25314a78bc204c928bdf2859dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to iterator container.  <a href="namespacexxmodulebase______tree__ftl.html#acd73bc25314a78bc204c928bdf2859dc">More...</a><br /></td></tr>
<tr class="separator:acd73bc25314a78bc204c928bdf2859dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b657471b2e34b3979258b1a4fa25d8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#aa7b657471b2e34b3979258b1a4fa25d8">tree_iterator_assign_from_tree_iterator</a> (this, other)</td></tr>
<tr class="memdesc:aa7b657471b2e34b3979258b1a4fa25d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree from an exisiting tree (assignment operator)  <a href="namespacexxmodulebase______tree__ftl.html#aa7b657471b2e34b3979258b1a4fa25d8">More...</a><br /></td></tr>
<tr class="separator:aa7b657471b2e34b3979258b1a4fa25d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d27606913a1fc6ac5408fcd399a903e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a6d27606913a1fc6ac5408fcd399a903e">element_assign_pointer</a> (left, right)</td></tr>
<tr class="memdesc:a6d27606913a1fc6ac5408fcd399a903e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______tree__ftl.html#a6d27606913a1fc6ac5408fcd399a903e">More...</a><br /></td></tr>
<tr class="separator:a6d27606913a1fc6ac5408fcd399a903e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3952939d5e88a7902fcad2be68e084c5"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______tree__ftl.html#a3952939d5e88a7902fcad2be68e084c5">element_assign_allocatable</a> (left, right)</td></tr>
<tr class="memdesc:a3952939d5e88a7902fcad2be68e084c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______tree__ftl.html#a3952939d5e88a7902fcad2be68e084c5">More...</a><br /></td></tr>
<tr class="separator:a3952939d5e88a7902fcad2be68e084c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ae9d0339c68bb46e487c165c7360df785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d0339c68bb46e487c165c7360df785">&#9670;&nbsp;</a></span>tree_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function xxmodulebase___tree_ftl::tree_default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="af01cf53a05c2a6d5ad93a7f8fea11609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01cf53a05c2a6d5ad93a7f8fea11609">&#9670;&nbsp;</a></span>tree_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function xxmodulebase___tree_ftl::tree_copy </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result tree </dd></dl>

</div>
</div>
<a id="a665597201084dd41b40acd6a081bb12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665597201084dd41b40acd6a081bb12d">&#9670;&nbsp;</a></span>tree_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_ </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4383e29b79b9bc92b9bfa091d4eb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4383e29b79b9bc92b9bfa091d4eb7c">&#9670;&nbsp;</a></span>tree_push_front_child_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_front_child_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node at the beginning of the tree root children list; include element if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10651f2e743c8eb1df96ead8d5661d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10651f2e743c8eb1df96ead8d5661d5">&#9670;&nbsp;</a></span>tree_push_front_child_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_front_child_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the beginning of the children list; include element if present This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93890ddf836ea0df1e0af920e814cdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93890ddf836ea0df1e0af920e814cdbb">&#9670;&nbsp;</a></span>tree_push_front_child_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_front_child_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the beginning of the children list; include element if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab60afa3276b59add70920bdf2a4fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab60afa3276b59add70920bdf2a4fc6">&#9670;&nbsp;</a></span>tree_push_back_child_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_back_child_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node at the end of the tree root children list; include element if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f9c9e2fc1468c001337c0bb695592d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9c9e2fc1468c001337c0bb695592d3">&#9670;&nbsp;</a></span>tree_push_back_child_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_back_child_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the end of the children list; include element if present This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e86c8c41ed92a51b1b93926bf28e065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e86c8c41ed92a51b1b93926bf28e065">&#9670;&nbsp;</a></span>tree_push_back_child_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_back_child_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the end of the children list; include element if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf01ded85253e0fd1839c1ef3cef2ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf01ded85253e0fd1839c1ef3cef2ba7">&#9670;&nbsp;</a></span>tree_pop_front_child_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_front_child_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node at the beginning of the tree root children list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7df2040bd6328dfd4a1df4b86b22550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7df2040bd6328dfd4a1df4b86b22550">&#9670;&nbsp;</a></span>tree_pop_front_child_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_front_child_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node at the beginning of the children list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62f454169aec25bf91c420fccf86c388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f454169aec25bf91c420fccf86c388">&#9670;&nbsp;</a></span>tree_pop_front_child_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_front_child_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node to the beginning of the children list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8219fb676b5121b9b94e319f2cc46798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8219fb676b5121b9b94e319f2cc46798">&#9670;&nbsp;</a></span>tree_pop_back_child_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_back_child_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node at the beginning of the tree root children list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfabde266492eed33b5f1daad706a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfabde266492eed33b5f1daad706a31">&#9670;&nbsp;</a></span>tree_pop_back_child_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_back_child_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node at the beginning of the children list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1363746655767cc1f5f777b9b2afd003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1363746655767cc1f5f777b9b2afd003">&#9670;&nbsp;</a></span>tree_pop_back_child_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_pop_back_child_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node to the end of the children list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f35e95aaaf517ad463ffe1161c5fb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f35e95aaaf517ad463ffe1161c5fb31">&#9670;&nbsp;</a></span>tree_push_front_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_front_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the beginning of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0437defd3dc3a4ecb07d8587306727b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0437defd3dc3a4ecb07d8587306727b7">&#9670;&nbsp;</a></span>tree_push_back_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_push_back_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child node to the end of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a767d852b5757f70d99bde57923995009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767d852b5757f70d99bde57923995009">&#9670;&nbsp;</a></span>tree_pop_front_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_pop_front_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node from the beginning of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e6cf9f51e7b9112cd95b26c80d736a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e6cf9f51e7b9112cd95b26c80d736a">&#9670;&nbsp;</a></span>tree_pop_back_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_pop_back_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove child node from the end of the sibling list This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80f314d2f3cd62b1e409ca4e03285c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80f314d2f3cd62b1e409ca4e03285c9">&#9670;&nbsp;</a></span>tree_insert_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_insert_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert node before node pointed by the iterator Iterator remains associated to input iterator This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>Iterator to element used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8b2c15972dc425249b8ebeee56fc2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b2c15972dc425249b8ebeee56fc2b5">&#9670;&nbsp;</a></span>tree_erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_erase </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove node pointed by the iterator Input pointer returns not associated This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>Iterator to element to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b0ce91ee92f7c43f9917e505e23c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b0ce91ee92f7c43f9917e505e23c9a">&#9670;&nbsp;</a></span>tree_begin_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_begin_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to first node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root element </dd></dl>

</div>
</div>
<a id="a4e8c56518a7a513ec8921a5223a03bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8c56518a7a513ec8921a5223a03bd7">&#9670;&nbsp;</a></span>tree_end_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_end_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to last node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root element </dd></dl>

</div>
</div>
<a id="ab74935c8d3d820f52899f66a5223ce06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74935c8d3d820f52899f66a5223ce06">&#9670;&nbsp;</a></span>tree_begin_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_begin_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to first child node in the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>The pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child in the node </dd></dl>

</div>
</div>
<a id="a447db88833081ea88547f820829c5bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447db88833081ea88547f820829c5bba">&#9670;&nbsp;</a></span>tree_end_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_end_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to last child node in the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>The pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child in the node </dd></dl>

</div>
</div>
<a id="acffb60423af612b5d2bd5846d1ac2cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffb60423af612b5d2bd5846d1ac2cc5">&#9670;&nbsp;</a></span>tree_next_tree_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_next_tree_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to next node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output iterator </dd></dl>

</div>
</div>
<a id="a0d551fb7af929fe7085a45c50cb09ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d551fb7af929fe7085a45c50cb09ca8">&#9670;&nbsp;</a></span>tree_next_tree_node_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>) function, pointer xxmodulebase___tree_ftl::tree_next_tree_node_up </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate the tree forward from an exhausted level upwards in the hierarchy When a level is exhausted, the next node is. </p>
<ul>
<li>either a sibling of an already navigated node</li>
<li>or the root and then the navigation is finished <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output iterator </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3b61153fcdf3381b71a45d97f2543b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b61153fcdf3381b71a45d97f2543b85">&#9670;&nbsp;</a></span>tree_previous_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_previous_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to previous node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output iterator </dd></dl>

</div>
</div>
<a id="a4a544b42ef3dc1d59dd818f91be7925a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a544b42ef3dc1d59dd818f91be7925a">&#9670;&nbsp;</a></span>tree_associated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_associated </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the association status of an iterator This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The node iterator (optional association check) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The association status </dd></dl>

</div>
</div>
<a id="af325482bad47d6f3ae6a9785945864ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af325482bad47d6f3ae6a9785945864ab">&#9670;&nbsp;</a></span>tree_nullify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_nullify </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af31869ea0751424d82ece4d5bdb5daea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31869ea0751424d82ece4d5bdb5daea">&#9670;&nbsp;</a></span>tree_begin_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_begin_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to first sibling node to the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>The pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child in the node </dd></dl>

</div>
</div>
<a id="a5d673ea55570ac134699b659deabd8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d673ea55570ac134699b659deabd8a9">&#9670;&nbsp;</a></span>tree_end_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_end_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to last sibling node to the input node This interface is also designed to allow inheritance of the tree type and then to extend also the tree_iterator type such that the derived tree type can invoke this method with the derivied tree_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>The pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child in the node </dd></dl>

</div>
</div>
<a id="a699829e7abc7d2785029b7214d6cf662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699829e7abc7d2785029b7214d6cf662">&#9670;&nbsp;</a></span>tree_next_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_next_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to next sibling node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output iterator </dd></dl>

</div>
</div>
<a id="af9e7951a597de11fd247b38a12c9b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e7951a597de11fd247b38a12c9b93f">&#9670;&nbsp;</a></span>tree_previous_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_previous_sibling </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to previous sibling node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output iterator </dd></dl>

</div>
</div>
<a id="a827bd944872794c25d399a75f356f78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827bd944872794c25d399a75f356f78b">&#9670;&nbsp;</a></span>tree_has_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_has_data </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a node has data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data contents flag (true if node contains data element) </dd></dl>

</div>
</div>
<a id="a3a8f2bb3799e8bc7674cf4eec033900f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8f2bb3799e8bc7674cf4eec033900f">&#9670;&nbsp;</a></span>tree_iterator_get_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___tree_ftl::tree_iterator_get_element </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the data elememnt pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned element </dd></dl>

</div>
</div>
<a id="ad0d9a0050012fd2a9ed262bfa447dc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d9a0050012fd2a9ed262bfa447dc46">&#9670;&nbsp;</a></span>tree_iterator_get_element_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer xxmodulebase___tree_ftl::tree_iterator_get_element_ptr </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data elememnt pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned element </dd></dl>

</div>
</div>
<a id="ae7519a5d086a03394fac10c6b73654dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7519a5d086a03394fac10c6b73654dc">&#9670;&nbsp;</a></span>tree_element_to_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_element_to_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3227dcdcd68159d53b65826da9eb7c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3227dcdcd68159d53b65826da9eb7c8d">&#9670;&nbsp;</a></span>tree_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___tree_ftl::tree_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first element in The tree </dd></dl>

</div>
</div>
<a id="acc72692e555223a6206760bc48c6e6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc72692e555223a6206760bc48c6e6f3">&#9670;&nbsp;</a></span>tree_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___tree_ftl::tree_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last element in The tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first element in the tree </dd></dl>

</div>
</div>
<a id="ab6edfa6e85a652216e6be12e6ad4d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6edfa6e85a652216e6be12e6ad4d270">&#9670;&nbsp;</a></span>tree_empty_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_empty_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return empty status of tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree empty status </dd></dl>

</div>
</div>
<a id="acbdf288b79d9f2929bff020389ea5fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdf288b79d9f2929bff020389ea5fbb">&#9670;&nbsp;</a></span>tree_empty_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_empty_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return empty status of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node empty status </dd></dl>

</div>
</div>
<a id="a7d36fe48b3d5ce7d4966f6e8148ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d36fe48b3d5ce7d4966f6e8148ff5ae">&#9670;&nbsp;</a></span>tree_empty_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_empty_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return empty status of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node empty status </dd></dl>

</div>
</div>
<a id="a74f6e631fdeea70338c34c51a14f6940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f6e631fdeea70338c34c51a14f6940">&#9670;&nbsp;</a></span>tree_has_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_has_children </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether node has children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The children presence status </dd></dl>

</div>
</div>
<a id="a5405b3462b8489ea5071f3ed48dc8dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5405b3462b8489ea5071f3ed48dc8dc8">&#9670;&nbsp;</a></span>tree_has_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___tree_ftl::tree_has_siblings </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether node has siblings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sibling presence status </dd></dl>

</div>
</div>
<a id="a5075c742f2995f7248b79e76531cb626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5075c742f2995f7248b79e76531cb626">&#9670;&nbsp;</a></span>tree_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___tree_ftl::tree_children </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children in a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children </dd></dl>

</div>
</div>
<a id="a854a188a125e3badee575a243421483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854a188a125e3badee575a243421483b">&#9670;&nbsp;</a></span>tree_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___tree_ftl::tree_siblings </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of siblings of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of siblings (excluding self) </dd></dl>

</div>
</div>
<a id="a4d5d4339c7eedb7a8d466f0206dcfcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5d4339c7eedb7a8d466f0206dcfcfe">&#9670;&nbsp;</a></span>tree_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>) function xxmodulebase___tree_ftl::tree_parent </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to the parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent node iterator </dd></dl>

</div>
</div>
<a id="ab44c5c49c81b1ae4b630824b5e202252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44c5c49c81b1ae4b630824b5e202252">&#9670;&nbsp;</a></span>tree_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___tree_ftl::tree_depth </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the depth in a tree (from iterator); root is depth 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator depth </dd></dl>

</div>
</div>
<a id="a31faacc5a562dff6ce5e579ef26b5a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31faacc5a562dff6ce5e579ef26b5a44">&#9670;&nbsp;</a></span>tree_sibling_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___tree_ftl::tree_sibling_position </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sibling position in a tree (from iterator); root is sibling position 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator sibling position </dd></dl>

</div>
</div>
<a id="ae84b083022c8c482c15d4273f68b01e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84b083022c8c482c15d4273f68b01e4">&#9670;&nbsp;</a></span>tree_clear_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_clear_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the whole tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81557ed3fcaa3c5245ab26c09b434d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81557ed3fcaa3c5245ab26c09b434d37">&#9670;&nbsp;</a></span>tree_clear_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_clear_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>The node iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af559fe24335d9a00b122aafd5445af85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af559fe24335d9a00b122aafd5445af85">&#9670;&nbsp;</a></span>tree_clear_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure recursive subroutine xxmodulebase___tree_ftl::tree_clear_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively clear the node and all descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The top node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635cec477373d016f01b1b0161dc2e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635cec477373d016f01b1b0161dc2e73">&#9670;&nbsp;</a></span>tree_swap_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_swap_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two elements in a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>Iterator to first element </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>Iterator to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9268e412ad1f793e14fb9ce6eef69696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9268e412ad1f793e14fb9ce6eef69696">&#9670;&nbsp;</a></span>tree_swap_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::tree_swap_node </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1t__tree__node.html">t_tree_node</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two elements in a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>Iterator to first element </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>Iterator to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bb72d2357d0a6da7456ec00a6e29ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb72d2357d0a6da7456ec00a6e29ea3">&#9670;&nbsp;</a></span>tree_assign_from_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_assign_from_tree </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tree from an exisiting tree (assignment operator) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31bdbfc4c1032b5e152322f918fd39b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bdbfc4c1032b5e152322f918fd39b6">&#9670;&nbsp;</a></span>tree_add_children_from_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">recursive subroutine xxmodulebase___tree_ftl::tree_add_children_from_tree </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>itthis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>itother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy recursively the nodes from the input to the output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itthis</td><td>The output tree iterator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itother</td><td>The input tree iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd73bc25314a78bc204c928bdf2859dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd73bc25314a78bc204c928bdf2859dc">&#9670;&nbsp;</a></span>tree_container_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl.html">xxtypebase___tree_ftl</a>) function, pointer xxmodulebase___tree_ftl::tree_container_ptr </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to iterator container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the tree </dd></dl>

</div>
</div>
<a id="aa7b657471b2e34b3979258b1a4fa25d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b657471b2e34b3979258b1a4fa25d8">&#9670;&nbsp;</a></span>tree_iterator_assign_from_tree_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___tree_ftl::tree_iterator_assign_from_tree_iterator </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______tree__ftl_1_1xxtypebase______tree__ftl__iterator.html">xxtypebase___tree_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tree from an exisiting tree (assignment operator) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output tree iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input tree iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d27606913a1fc6ac5408fcd399a903e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d27606913a1fc6ac5408fcd399a903e">&#9670;&nbsp;</a></span>element_assign_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::element_assign_pointer </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(inout), pointer&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (pointer interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3952939d5e88a7902fcad2be68e084c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3952939d5e88a7902fcad2be68e084c5">&#9670;&nbsp;</a></span>element_assign_allocatable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___tree_ftl::element_assign_allocatable </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (allocatable interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
