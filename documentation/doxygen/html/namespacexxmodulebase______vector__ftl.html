<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FTL: xxmodulebase___vector_ftl Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FTL
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Fortran Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xxmodulebase___vector_ftl Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1binary__predicate.html">binary_predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1distance.html">distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interfaces for procedures not bound to type.  <a href="interfacexxmodulebase______vector__ftl_1_1distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1predicate.html">predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1swap.html">swap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1t__node.html">t_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector node type.  <a href="structxxmodulebase______vector__ftl_1_1t__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacexxmodulebase______vector__ftl_1_1xxconstructor______vector__ftl.html">xxconstructor___vector_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor interface.  <a href="interfacexxmodulebase______vector__ftl_1_1xxconstructor______vector__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector container type.  <a href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector iterator type.  <a href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ac22de2f2d500c016c3a628067981ee12"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac22de2f2d500c016c3a628067981ee12">vector_default</a> ()</td></tr>
<tr class="memdesc:ac22de2f2d500c016c3a628067981ee12"><td class="mdescLeft">&#160;</td><td class="mdescRight">(1) empty container constructor (default constructor) Constructs an empty container, with no elements.  <a href="namespacexxmodulebase______vector__ftl.html#ac22de2f2d500c016c3a628067981ee12">More...</a><br /></td></tr>
<tr class="separator:ac22de2f2d500c016c3a628067981ee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2172ac4807729f5ced5ca882beb42d3"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ab2172ac4807729f5ced5ca882beb42d3">vector_fill</a> (n, val)</td></tr>
<tr class="memdesc:ab2172ac4807729f5ced5ca882beb42d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(2) fill constructor Constructs a container with n elements. Each element is a copy of val.  <a href="namespacexxmodulebase______vector__ftl.html#ab2172ac4807729f5ced5ca882beb42d3">More...</a><br /></td></tr>
<tr class="separator:ab2172ac4807729f5ced5ca882beb42d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9fa69db2dda505b0debdd4bd32928a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ada9fa69db2dda505b0debdd4bd32928a">vector_range</a> (first, last)</td></tr>
<tr class="memdesc:ada9fa69db2dda505b0debdd4bd32928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(3) range constructor Constructs a container with as many elements as the range (first,last), with each element constructed from its corresponding element in that range, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type  <a href="namespacexxmodulebase______vector__ftl.html#ada9fa69db2dda505b0debdd4bd32928a">More...</a><br /></td></tr>
<tr class="separator:ada9fa69db2dda505b0debdd4bd32928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068d7489a0ef1f57f83489b7a94d2c06"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a068d7489a0ef1f57f83489b7a94d2c06">vector_copy</a> (other)</td></tr>
<tr class="memdesc:a068d7489a0ef1f57f83489b7a94d2c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">(4) copy constructor Constructs a container with a copy of each of the elements in other, in the same order.  <a href="namespacexxmodulebase______vector__ftl.html#a068d7489a0ef1f57f83489b7a94d2c06">More...</a><br /></td></tr>
<tr class="separator:a068d7489a0ef1f57f83489b7a94d2c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd31d81ff216049645688d944674268"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a1cd31d81ff216049645688d944674268">vector_copy_from_array</a> (val)</td></tr>
<tr class="memdesc:a1cd31d81ff216049645688d944674268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from array.  <a href="namespacexxmodulebase______vector__ftl.html#a1cd31d81ff216049645688d944674268">More...</a><br /></td></tr>
<tr class="separator:a1cd31d81ff216049645688d944674268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c4b43fc00d13281082c4842ec6684"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a9f0c4b43fc00d13281082c4842ec6684">vector_assign_from_vector</a> (this, other)</td></tr>
<tr class="memdesc:a9f0c4b43fc00d13281082c4842ec6684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.  <a href="namespacexxmodulebase______vector__ftl.html#a9f0c4b43fc00d13281082c4842ec6684">More...</a><br /></td></tr>
<tr class="separator:a9f0c4b43fc00d13281082c4842ec6684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71fadb34e35ed36540921822b7284ae"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa71fadb34e35ed36540921822b7284ae">vector_</a> (this)</td></tr>
<tr class="memdesc:aa71fadb34e35ed36540921822b7284ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector destructor Destroys the container object.  <a href="namespacexxmodulebase______vector__ftl.html#aa71fadb34e35ed36540921822b7284ae">More...</a><br /></td></tr>
<tr class="separator:aa71fadb34e35ed36540921822b7284ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6970fb53364dc0c08ef61bd8f75d9e1d">vector_begin</a> (this)</td></tr>
<tr class="memdesc:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to beginning Returns an iterator pointing to the first element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacexxmodulebase______vector__ftl.html#a6970fb53364dc0c08ef61bd8f75d9e1d">More...</a><br /></td></tr>
<tr class="separator:a6970fb53364dc0c08ef61bd8f75d9e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c121bbcb747aced22089b1a1a7f84a2"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a5c121bbcb747aced22089b1a1a7f84a2">vector_end</a> (this)</td></tr>
<tr class="memdesc:a5c121bbcb747aced22089b1a1a7f84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to end Returns an iterator referring to the last element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacexxmodulebase______vector__ftl.html#a5c121bbcb747aced22089b1a1a7f84a2">More...</a><br /></td></tr>
<tr class="separator:a5c121bbcb747aced22089b1a1a7f84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63172a6c006a0550d0102359cd357d72"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a63172a6c006a0550d0102359cd357d72">vector_empty</a> (this)</td></tr>
<tr class="memdesc:a63172a6c006a0550d0102359cd357d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether container is empty Returns whether the vector container is empty (i.e. whether its size is 0). This function does not modify the container in any way.  <a href="namespacexxmodulebase______vector__ftl.html#a63172a6c006a0550d0102359cd357d72">More...</a><br /></td></tr>
<tr class="separator:a63172a6c006a0550d0102359cd357d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085dbc3c35066690fa745aefb380d1b7"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a085dbc3c35066690fa745aefb380d1b7">vector_size</a> (this)</td></tr>
<tr class="memdesc:a085dbc3c35066690fa745aefb380d1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size Returns the number of elements in the vector container.  <a href="namespacexxmodulebase______vector__ftl.html#a085dbc3c35066690fa745aefb380d1b7">More...</a><br /></td></tr>
<tr class="separator:a085dbc3c35066690fa745aefb380d1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a3e5ca2cad1605f247b49b1ef0af0363b">vector_max_size</a> ()</td></tr>
<tr class="memdesc:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum size Returns the maximum number of elements that the vector container can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached.  <a href="namespacexxmodulebase______vector__ftl.html#a3e5ca2cad1605f247b49b1ef0af0363b">More...</a><br /></td></tr>
<tr class="separator:a3e5ca2cad1605f247b49b1ef0af0363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af798f0b0b8e76578a9954dd5350fcbee"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af798f0b0b8e76578a9954dd5350fcbee">vector_capacity</a> (this)</td></tr>
<tr class="memdesc:af798f0b0b8e76578a9954dd5350fcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of allocated storage capacity Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space). The capacity of a vector can be explicitly altered by calling member vecto::reserve.  <a href="namespacexxmodulebase______vector__ftl.html#af798f0b0b8e76578a9954dd5350fcbee">More...</a><br /></td></tr>
<tr class="separator:af798f0b0b8e76578a9954dd5350fcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a7cf4f327e8ac97f513950ad0b7bee23d">vector_front</a> (this)</td></tr>
<tr class="memdesc:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element Returns a reference to the first element in the vector container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacexxmodulebase______vector__ftl.html#a7cf4f327e8ac97f513950ad0b7bee23d">More...</a><br /></td></tr>
<tr class="separator:a7cf4f327e8ac97f513950ad0b7bee23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b404447da579545604b614c3fac8a"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad17b404447da579545604b614c3fac8a">vector_back</a> (this)</td></tr>
<tr class="memdesc:ad17b404447da579545604b614c3fac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element Returns a reference to the last element in the vector container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacexxmodulebase______vector__ftl.html#ad17b404447da579545604b614c3fac8a">More...</a><br /></td></tr>
<tr class="separator:ad17b404447da579545604b614c3fac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4479e9ca761c197765e3e8be65550190"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a4479e9ca761c197765e3e8be65550190">vector_assign_from_range</a> (this, first, last)</td></tr>
<tr class="memdesc:a4479e9ca761c197765e3e8be65550190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (1), the new contents are elements constructed from each of the elements in the range between first and last, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a4479e9ca761c197765e3e8be65550190">More...</a><br /></td></tr>
<tr class="separator:a4479e9ca761c197765e3e8be65550190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af8f8d4c4f9fba98033a5fe496dbcef70">vector_assign_from_fill</a> (this, n, val)</td></tr>
<tr class="memdesc:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (2), the new contents are n elements, each initialized to a copy of val.  <a href="namespacexxmodulebase______vector__ftl.html#af8f8d4c4f9fba98033a5fe496dbcef70">More...</a><br /></td></tr>
<tr class="separator:af8f8d4c4f9fba98033a5fe496dbcef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac6b808cfa1bbc3b2e54cd02d53281430">vector_assign_from_array</a> (this, val)</td></tr>
<tr class="memdesc:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a vector from an array.  <a href="namespacexxmodulebase______vector__ftl.html#ac6b808cfa1bbc3b2e54cd02d53281430">More...</a><br /></td></tr>
<tr class="separator:ac6b808cfa1bbc3b2e54cd02d53281430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6597506c25184a35e9274c69bea4455c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6597506c25184a35e9274c69bea4455c">vector_push_front</a> (this, val)</td></tr>
<tr class="memdesc:a6597506c25184a35e9274c69bea4455c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at beginning Inserts a new element at the beginning of the vector, right before its current first element. The content of val is copied (or moved) to the inserted element. This effectively increases the container size by one.  <a href="namespacexxmodulebase______vector__ftl.html#a6597506c25184a35e9274c69bea4455c">More...</a><br /></td></tr>
<tr class="separator:a6597506c25184a35e9274c69bea4455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856bc550e4e33c11424d5b0e3531507e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a856bc550e4e33c11424d5b0e3531507e">vector_pop_front</a> (this)</td></tr>
<tr class="memdesc:a856bc550e4e33c11424d5b0e3531507e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete first element Removes the first element in the vector container, effectively reducing its size by one. This destroys the removed element.  <a href="namespacexxmodulebase______vector__ftl.html#a856bc550e4e33c11424d5b0e3531507e">More...</a><br /></td></tr>
<tr class="separator:a856bc550e4e33c11424d5b0e3531507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777e3c96edd722e8ae569415dd05cbda"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a777e3c96edd722e8ae569415dd05cbda">vector_push_back</a> (this, val)</td></tr>
<tr class="memdesc:a777e3c96edd722e8ae569415dd05cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at the end Adds a new element at the end of the vector container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one.  <a href="namespacexxmodulebase______vector__ftl.html#a777e3c96edd722e8ae569415dd05cbda">More...</a><br /></td></tr>
<tr class="separator:a777e3c96edd722e8ae569415dd05cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a4dc6fd3d3c34f6bbc9ed988e6bcf54b5">vector_pop_back</a> (this)</td></tr>
<tr class="memdesc:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete last element Removes the last element in the vector container, effectively reducing the container size by one. This destroys the removed element.  <a href="namespacexxmodulebase______vector__ftl.html#a4dc6fd3d3c34f6bbc9ed988e6bcf54b5">More...</a><br /></td></tr>
<tr class="separator:a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2561a414ffc51a6153378705dda3e2"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a3a2561a414ffc51a6153378705dda3e2">vector_insert_single</a> (this, iterator, val)</td></tr>
<tr class="memdesc:a3a2561a414ffc51a6153378705dda3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by one. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a3a2561a414ffc51a6153378705dda3e2">More...</a><br /></td></tr>
<tr class="separator:a3a2561a414ffc51a6153378705dda3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1778706c24f73ed7c04382d9c9f848"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a6b1778706c24f73ed7c04382d9c9f848">vector_insert_single_at</a> (this, index, val)</td></tr>
<tr class="memdesc:a6b1778706c24f73ed7c04382d9c9f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by one. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a6b1778706c24f73ed7c04382d9c9f848">More...</a><br /></td></tr>
<tr class="separator:a6b1778706c24f73ed7c04382d9c9f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa438341f3726df6e9e34e42f07a71d06"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa438341f3726df6e9e34e42f07a71d06">vector_insert_fill</a> (this, iterator, n, val)</td></tr>
<tr class="memdesc:aa438341f3726df6e9e34e42f07a71d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by n. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#aa438341f3726df6e9e34e42f07a71d06">More...</a><br /></td></tr>
<tr class="separator:aa438341f3726df6e9e34e42f07a71d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d1e9f17969abe336bc20f6f9541da"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a600d1e9f17969abe336bc20f6f9541da">vector_insert_fill_at</a> (this, index, n, val)</td></tr>
<tr class="memdesc:a600d1e9f17969abe336bc20f6f9541da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a600d1e9f17969abe336bc20f6f9541da">More...</a><br /></td></tr>
<tr class="separator:a600d1e9f17969abe336bc20f6f9541da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a9f79a0d75683c1fe6cb99cdde65936aa">vector_insert_range</a> (this, iterator, first, last)</td></tr>
<tr class="memdesc:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted.  <a href="namespacexxmodulebase______vector__ftl.html#a9f79a0d75683c1fe6cb99cdde65936aa">More...</a><br /></td></tr>
<tr class="separator:a9f79a0d75683c1fe6cb99cdde65936aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b11394297f1206126e5fb1926c244b"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a81b11394297f1206126e5fb1926c244b">vector_insert_range_at</a> (this, index, first, last)</td></tr>
<tr class="memdesc:a81b11394297f1206126e5fb1926c244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted.  <a href="namespacexxmodulebase______vector__ftl.html#a81b11394297f1206126e5fb1926c244b">More...</a><br /></td></tr>
<tr class="separator:a81b11394297f1206126e5fb1926c244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a51a21d1c3b3cd2d83d70418f902a01fa">vector_insert_array</a> (this, iterator, val)</td></tr>
<tr class="memdesc:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the size of the array. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a51a21d1c3b3cd2d83d70418f902a01fa">More...</a><br /></td></tr>
<tr class="separator:a51a21d1c3b3cd2d83d70418f902a01fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8013588260e0a76eb434e7d901642610"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8013588260e0a76eb434e7d901642610">vector_insert_array_at</a> (this, index, val)</td></tr>
<tr class="memdesc:a8013588260e0a76eb434e7d901642610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input.  <a href="namespacexxmodulebase______vector__ftl.html#a8013588260e0a76eb434e7d901642610">More...</a><br /></td></tr>
<tr class="separator:a8013588260e0a76eb434e7d901642610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ceda421c23eb7713c04248e894dd6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ae10ceda421c23eb7713c04248e894dd6">vector_erase_single</a> (this, iterator)</td></tr>
<tr class="memdesc:ae10ceda421c23eb7713c04248e894dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a single element (position) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#ae10ceda421c23eb7713c04248e894dd6">More...</a><br /></td></tr>
<tr class="separator:ae10ceda421c23eb7713c04248e894dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dd8752f465f7cdd28fcfac73b5abab"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a31dd8752f465f7cdd28fcfac73b5abab">vector_erase_single_at</a> (this, index)</td></tr>
<tr class="memdesc:a31dd8752f465f7cdd28fcfac73b5abab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a single element (position by absolute index) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated.  <a href="namespacexxmodulebase______vector__ftl.html#a31dd8752f465f7cdd28fcfac73b5abab">More...</a><br /></td></tr>
<tr class="separator:a31dd8752f465f7cdd28fcfac73b5abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6b8965bf3ca02635ba07733095020"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad3a6b8965bf3ca02635ba07733095020">vector_erase_range</a> (this, first, last)</td></tr>
<tr class="memdesc:ad3a6b8965bf3ca02635ba07733095020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#ad3a6b8965bf3ca02635ba07733095020">More...</a><br /></td></tr>
<tr class="separator:ad3a6b8965bf3ca02635ba07733095020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac9c13bdd61489b6ee6f0a6f3972dc15b">vector_erase_range_at</a> (this, ifirst, ilast)</td></tr>
<tr class="memdesc:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed.  <a href="namespacexxmodulebase______vector__ftl.html#ac9c13bdd61489b6ee6f0a6f3972dc15b">More...</a><br /></td></tr>
<tr class="separator:ac9c13bdd61489b6ee6f0a6f3972dc15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934f13e9ec300de57a75e4ddcdd0394"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a1934f13e9ec300de57a75e4ddcdd0394">vector_swap</a> (this, other)</td></tr>
<tr class="memdesc:a1934f13e9ec300de57a75e4ddcdd0394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content Exchanges the content of the container by the content of other, which is another vector of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in other before the call, and the elements of other are those which were in this. All iterators, references and pointers remain valid for the swapped objects.  <a href="namespacexxmodulebase______vector__ftl.html#a1934f13e9ec300de57a75e4ddcdd0394">More...</a><br /></td></tr>
<tr class="separator:a1934f13e9ec300de57a75e4ddcdd0394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb8b4cd18bfc5c3812e372779510735"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8eb8b4cd18bfc5c3812e372779510735">vector_resize</a> (this, n, val)</td></tr>
<tr class="memdesc:a8eb8b4cd18bfc5c3812e372779510735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized.  <a href="namespacexxmodulebase______vector__ftl.html#a8eb8b4cd18bfc5c3812e372779510735">More...</a><br /></td></tr>
<tr class="separator:a8eb8b4cd18bfc5c3812e372779510735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad829da9e508913f888d2784bb44fbc8e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad829da9e508913f888d2784bb44fbc8e">vector_clear</a> (this)</td></tr>
<tr class="memdesc:ad829da9e508913f888d2784bb44fbc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear content Removes all elements from the vector container (which are destroyed) and leaving the container with a size of 0.  <a href="namespacexxmodulebase______vector__ftl.html#ad829da9e508913f888d2784bb44fbc8e">More...</a><br /></td></tr>
<tr class="separator:ad829da9e508913f888d2784bb44fbc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace15fda8e6184f543ffbb91a278ce251"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ace15fda8e6184f543ffbb91a278ce251">vector_at_get</a> (this, index)</td></tr>
<tr class="memdesc:ace15fda8e6184f543ffbb91a278ce251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given position.  <a href="namespacexxmodulebase______vector__ftl.html#ace15fda8e6184f543ffbb91a278ce251">More...</a><br /></td></tr>
<tr class="separator:ace15fda8e6184f543ffbb91a278ce251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861037895ce3d24453e015e536abb63d"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a861037895ce3d24453e015e536abb63d">vector_element_from_index</a> (this, index)</td></tr>
<tr class="memdesc:a861037895ce3d24453e015e536abb63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value pointed by the index.  <a href="namespacexxmodulebase______vector__ftl.html#a861037895ce3d24453e015e536abb63d">More...</a><br /></td></tr>
<tr class="separator:a861037895ce3d24453e015e536abb63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866f8de383db6264a14e13d09f0fb51b"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a866f8de383db6264a14e13d09f0fb51b">vector_element_ptr_from_index</a> (this, index)</td></tr>
<tr class="memdesc:a866f8de383db6264a14e13d09f0fb51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value pointed by the index.  <a href="namespacexxmodulebase______vector__ftl.html#a866f8de383db6264a14e13d09f0fb51b">More...</a><br /></td></tr>
<tr class="separator:a866f8de383db6264a14e13d09f0fb51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf42b19a13bd697dc6ddafb88709108f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adf42b19a13bd697dc6ddafb88709108f">vector_element_to_index</a> (this, index, element)</td></tr>
<tr class="memdesc:adf42b19a13bd697dc6ddafb88709108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value pointed by the index Provide destructor is the replaced element has complex memory components.  <a href="namespacexxmodulebase______vector__ftl.html#adf42b19a13bd697dc6ddafb88709108f">More...</a><br /></td></tr>
<tr class="separator:adf42b19a13bd697dc6ddafb88709108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06f394ef03d14d3d15e3d7861d98e0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#acb06f394ef03d14d3d15e3d7861d98e0">vector_splice_vector</a> (this, position, source)</td></tr>
<tr class="memdesc:acb06f394ef03d14d3d15e3d7861d98e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (1) transfers all the elements of source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#acb06f394ef03d14d3d15e3d7861d98e0">More...</a><br /></td></tr>
<tr class="separator:acb06f394ef03d14d3d15e3d7861d98e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ada4031bf2360335909542beecbac1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a51ada4031bf2360335909542beecbac1">vector_splice_single</a> (this, position, source, it)</td></tr>
<tr class="memdesc:a51ada4031bf2360335909542beecbac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (2) transfers only the element pointed by iterator from x into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a51ada4031bf2360335909542beecbac1">More...</a><br /></td></tr>
<tr class="separator:a51ada4031bf2360335909542beecbac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8158e1eb388a9d9229efe4bac1554ec7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8158e1eb388a9d9229efe4bac1554ec7">vector_splice_range</a> (this, position, source, first, last)</td></tr>
<tr class="memdesc:a8158e1eb388a9d9229efe4bac1554ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (3) transfers the range (first,last) from source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a8158e1eb388a9d9229efe4bac1554ec7">More...</a><br /></td></tr>
<tr class="separator:a8158e1eb388a9d9229efe4bac1554ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3d89563ebaa91146e5c340870dd650"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ace3d89563ebaa91146e5c340870dd650">vector_splice_nodes</a> (this, position, source, ifirst, ilast)</td></tr>
<tr class="memdesc:ace3d89563ebaa91146e5c340870dd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from vector to vector Actual implementation of splcie at node level.  <a href="namespacexxmodulebase______vector__ftl.html#ace3d89563ebaa91146e5c340870dd650">More...</a><br /></td></tr>
<tr class="separator:ace3d89563ebaa91146e5c340870dd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680497affafe3232ee719cf52aadd8de"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a680497affafe3232ee719cf52aadd8de">vector_remove</a> (this, val)</td></tr>
<tr class="memdesc:a680497affafe3232ee719cf52aadd8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements with specific value Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed.  <a href="namespacexxmodulebase______vector__ftl.html#a680497affafe3232ee719cf52aadd8de">More...</a><br /></td></tr>
<tr class="separator:a680497affafe3232ee719cf52aadd8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc13aace88a74cd6a5497f72b9abc8db"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adc13aace88a74cd6a5497f72b9abc8db">vector_remove_if</a> (this, pred)</td></tr>
<tr class="memdesc:adc13aace88a74cd6a5497f72b9abc8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements fulfilling condition Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. The function calls pred(iget_element()) for each element (where i is an iterator to that element). Any of the elements in the vector for which this returns true, are removed from the container.  <a href="namespacexxmodulebase______vector__ftl.html#adc13aace88a74cd6a5497f72b9abc8db">More...</a><br /></td></tr>
<tr class="separator:adc13aace88a74cd6a5497f72b9abc8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dc7ce6119ce9d537ca66c895b2104f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a73dc7ce6119ce9d537ca66c895b2104f">vector_unique</a> (this, bpred)</td></tr>
<tr class="memdesc:a73dc7ce6119ce9d537ca66c895b2104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate values (1) removes all but the first element from every consecutive group of equal elements in the container. (2) takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(*i,*j)) for all pairs of elements (where i and j are iterators to the elements) and remove j from the vector if the predicate returns true.  <a href="namespacexxmodulebase______vector__ftl.html#a73dc7ce6119ce9d537ca66c895b2104f">More...</a><br /></td></tr>
<tr class="separator:a73dc7ce6119ce9d537ca66c895b2104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d94cb067c77566595e93f29c403fb1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a37d94cb067c77566595e93f29c403fb1">vector_merge</a> (this, other, comp)</td></tr>
<tr class="memdesc:a37d94cb067c77566595e93f29c403fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted vectors Merges other into the vector by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in other (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether other is an lvalue or an rvalue, or whether the value_type supports move-construction or not. (1) Each element of other is inserted at the position that corresponds to its value according to the strict weak ordering defined by operator &lt; or comp. The resulting order of equivalent elements is stable (i.e., equivalent elements preserve the relative order they had before the call, and existing elements precede those equivalent inserted from other). (2) Take a specific predicate (comp) to perform the comparison operation between elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). This function requires that the vector containers have their elements already ordered by value (or by comp) before the call. The function does nothing if (other == this).  <a href="namespacexxmodulebase______vector__ftl.html#a37d94cb067c77566595e93f29c403fb1">More...</a><br /></td></tr>
<tr class="separator:a37d94cb067c77566595e93f29c403fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241450beb546614b735b6221f1f1ebeb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a241450beb546614b735b6221f1f1ebeb">vector_sort</a> (this, compare)</td></tr>
<tr class="memdesc:a241450beb546614b735b6221f1f1ebeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort elements in container Sorts the elements in the vector, altering their position within the container. (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements (2) The sorting is performed by applying an algorithm that uses comp to compare elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). The resulting order of equivalent elements is stable: i.e., equivalent elements preserve the relative order they had before the call. The entire operation does not involve the construction, destruction or copy of any element object. Elements are moved within the container.  <a href="namespacexxmodulebase______vector__ftl.html#a241450beb546614b735b6221f1f1ebeb">More...</a><br /></td></tr>
<tr class="separator:a241450beb546614b735b6221f1f1ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe170dda401536c1f1864968ad3b9500"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#afe170dda401536c1f1864968ad3b9500">quick_sort</a> (this, left, right, compare)</td></tr>
<tr class="memdesc:afe170dda401536c1f1864968ad3b9500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting subroutine (Quick-sort method) algorithm kernel.  <a href="namespacexxmodulebase______vector__ftl.html#afe170dda401536c1f1864968ad3b9500">More...</a><br /></td></tr>
<tr class="separator:afe170dda401536c1f1864968ad3b9500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0baff42772597c4d4136c6fd34b0477"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac0baff42772597c4d4136c6fd34b0477">vector_swap_index</a> (this, index1, index2)</td></tr>
<tr class="memdesc:ac0baff42772597c4d4136c6fd34b0477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two elements in a vector from their indexes.  <a href="namespacexxmodulebase______vector__ftl.html#ac0baff42772597c4d4136c6fd34b0477">More...</a><br /></td></tr>
<tr class="separator:ac0baff42772597c4d4136c6fd34b0477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35a7d025524f49a0396cceeb2b6508e"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af35a7d025524f49a0396cceeb2b6508e">vector_iterator_swap_iterators</a> (iter1, iter2)</td></tr>
<tr class="memdesc:af35a7d025524f49a0396cceeb2b6508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes in a vector pointed by iterators.  <a href="namespacexxmodulebase______vector__ftl.html#af35a7d025524f49a0396cceeb2b6508e">More...</a><br /></td></tr>
<tr class="separator:af35a7d025524f49a0396cceeb2b6508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e6c79f4685e68be805772e463853f"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a070e6c79f4685e68be805772e463853f">vector_reverse</a> (this)</td></tr>
<tr class="memdesc:a070e6c79f4685e68be805772e463853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of elements in a vector.  <a href="namespacexxmodulebase______vector__ftl.html#a070e6c79f4685e68be805772e463853f">More...</a><br /></td></tr>
<tr class="separator:a070e6c79f4685e68be805772e463853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cdb1890480c32ffebfab225b42c9da"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa9cdb1890480c32ffebfab225b42c9da">vector_binary_search</a> (this, item, isless, isgreater)</td></tr>
<tr class="memdesc:aa9cdb1890480c32ffebfab225b42c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted vector) front-end.  <a href="namespacexxmodulebase______vector__ftl.html#aa9cdb1890480c32ffebfab225b42c9da">More...</a><br /></td></tr>
<tr class="separator:aa9cdb1890480c32ffebfab225b42c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb1e8e054465553a9e8eec378b8867"><td class="memItemLeft" align="right" valign="top">recursive integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a85bb1e8e054465553a9e8eec378b8867">recursive_binary_search</a> (this, left, right, item, isless, isgreater)</td></tr>
<tr class="memdesc:a85bb1e8e054465553a9e8eec378b8867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted vector) algorithm kernel.  <a href="namespacexxmodulebase______vector__ftl.html#a85bb1e8e054465553a9e8eec378b8867">More...</a><br /></td></tr>
<tr class="separator:a85bb1e8e054465553a9e8eec378b8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab317988a49455132919e794e74d9db52"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ab317988a49455132919e794e74d9db52">vector_select</a> (this, reference, bpred)</td></tr>
<tr class="memdesc:ab317988a49455132919e794e74d9db52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a vector following certain criteria.  <a href="namespacexxmodulebase______vector__ftl.html#ab317988a49455132919e794e74d9db52">More...</a><br /></td></tr>
<tr class="separator:ab317988a49455132919e794e74d9db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0896d34861ba9a92bb51c0297fce80"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a0f0896d34861ba9a92bb51c0297fce80">vector_array</a> (this)</td></tr>
<tr class="memdesc:a0f0896d34861ba9a92bb51c0297fce80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array (allocatabe) of elements from a vector.  <a href="namespacexxmodulebase______vector__ftl.html#a0f0896d34861ba9a92bb51c0297fce80">More...</a><br /></td></tr>
<tr class="separator:a0f0896d34861ba9a92bb51c0297fce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a0de605d88b5eef34e4b8bd1d5a2a7412">element_assign_pointer</a> (left, right)</td></tr>
<tr class="memdesc:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______vector__ftl.html#a0de605d88b5eef34e4b8bd1d5a2a7412">More...</a><br /></td></tr>
<tr class="separator:a0de605d88b5eef34e4b8bd1d5a2a7412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c93635598ac0e999a01d27262e06c"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac17c93635598ac0e999a01d27262e06c">element_assign_allocatable</a> (left, right)</td></tr>
<tr class="memdesc:ac17c93635598ac0e999a01d27262e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacexxmodulebase______vector__ftl.html#ac17c93635598ac0e999a01d27262e06c">More...</a><br /></td></tr>
<tr class="separator:ac17c93635598ac0e999a01d27262e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4f8d9d84ffece2fa9712677026639"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a97d4f8d9d84ffece2fa9712677026639">vector_iterator_next</a> (this)</td></tr>
<tr class="memdesc:a97d4f8d9d84ffece2fa9712677026639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to next node in the vector.  <a href="namespacexxmodulebase______vector__ftl.html#a97d4f8d9d84ffece2fa9712677026639">More...</a><br /></td></tr>
<tr class="separator:a97d4f8d9d84ffece2fa9712677026639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd95590e04683a45d40b4cb3ede460e"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#abfd95590e04683a45d40b4cb3ede460e">vector_iterator_previous</a> (this)</td></tr>
<tr class="memdesc:abfd95590e04683a45d40b4cb3ede460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to previous node in the vector.  <a href="namespacexxmodulebase______vector__ftl.html#abfd95590e04683a45d40b4cb3ede460e">More...</a><br /></td></tr>
<tr class="separator:abfd95590e04683a45d40b4cb3ede460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="memItemLeft" align="right" valign="top">pure integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a399094ea57e1e6f5a1abf769c38d9fe1">vector_iterator_index</a> (iterator)</td></tr>
<tr class="memdesc:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector index in an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a399094ea57e1e6f5a1abf769c38d9fe1">More...</a><br /></td></tr>
<tr class="separator:a399094ea57e1e6f5a1abf769c38d9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b51358c45ce7ff11e4b45e86e725e4"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a81b51358c45ce7ff11e4b45e86e725e4">vector_iterator_distance</a> (origin, target)</td></tr>
<tr class="memdesc:a81b51358c45ce7ff11e4b45e86e725e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance (number of elements) between two nodes (by iterator)  <a href="namespacexxmodulebase______vector__ftl.html#a81b51358c45ce7ff11e4b45e86e725e4">More...</a><br /></td></tr>
<tr class="separator:a81b51358c45ce7ff11e4b45e86e725e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28584e56306958a555ea5dc78d7c325"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ae28584e56306958a555ea5dc78d7c325">vector_iterator_associated</a> (this)</td></tr>
<tr class="memdesc:ae28584e56306958a555ea5dc78d7c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the association status of an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#ae28584e56306958a555ea5dc78d7c325">More...</a><br /></td></tr>
<tr class="separator:ae28584e56306958a555ea5dc78d7c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13385e157e24114a9d8d38a289766c6"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#aa13385e157e24114a9d8d38a289766c6">vector_iterator_nullify</a> (this)</td></tr>
<tr class="memdesc:aa13385e157e24114a9d8d38a289766c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an iterator.  <a href="namespacexxmodulebase______vector__ftl.html#aa13385e157e24114a9d8d38a289766c6">More...</a><br /></td></tr>
<tr class="separator:aa13385e157e24114a9d8d38a289766c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8078ba63473bd35d4855cdb00a698065"><td class="memItemLeft" align="right" valign="top">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a8078ba63473bd35d4855cdb00a698065">vector_iterator_get_element</a> (this)</td></tr>
<tr class="memdesc:a8078ba63473bd35d4855cdb00a698065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an elememnt in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a8078ba63473bd35d4855cdb00a698065">More...</a><br /></td></tr>
<tr class="separator:a8078ba63473bd35d4855cdb00a698065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb01963ba439e4a3186dd2fde150317"><td class="memItemLeft" align="right" valign="top">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#adeb01963ba439e4a3186dd2fde150317">vector_iterator_get_element_ptr</a> (this)</td></tr>
<tr class="memdesc:adeb01963ba439e4a3186dd2fde150317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data elememnt in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#adeb01963ba439e4a3186dd2fde150317">More...</a><br /></td></tr>
<tr class="separator:adeb01963ba439e4a3186dd2fde150317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cba7a597671043c0d460f1885f21ffb"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a2cba7a597671043c0d460f1885f21ffb">vector_iterator_set_element</a> (this, val)</td></tr>
<tr class="memdesc:a2cba7a597671043c0d460f1885f21ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element in the node pointed by the iterator.  <a href="namespacexxmodulebase______vector__ftl.html#a2cba7a597671043c0d460f1885f21ffb">More...</a><br /></td></tr>
<tr class="separator:a2cba7a597671043c0d460f1885f21ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a99cf28d9f6d17ab4e0512782cdc0a03b">vector_iterator_assign</a> (left, right)</td></tr>
<tr class="memdesc:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an interator from an existing iterator (assignment operator) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a99cf28d9f6d17ab4e0512782cdc0a03b">More...</a><br /></td></tr>
<tr class="separator:a99cf28d9f6d17ab4e0512782cdc0a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a00942d16c7f4fdedf80c33bbb1f73fed">vector_iterator_equal</a> (left, right)</td></tr>
<tr class="memdesc:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterators (equality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#a00942d16c7f4fdedf80c33bbb1f73fed">More...</a><br /></td></tr>
<tr class="separator:a00942d16c7f4fdedf80c33bbb1f73fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eccd0a8a293145fa7294a672dee9e2"><td class="memItemLeft" align="right" valign="top">pure logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#af0eccd0a8a293145fa7294a672dee9e2">vector_iterator_not_equal</a> (left, right)</td></tr>
<tr class="memdesc:af0eccd0a8a293145fa7294a672dee9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterator (inequality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacexxmodulebase______vector__ftl.html#af0eccd0a8a293145fa7294a672dee9e2">More...</a><br /></td></tr>
<tr class="separator:af0eccd0a8a293145fa7294a672dee9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4144cda43048fe4d887b6d8af894713"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ad4144cda43048fe4d887b6d8af894713">vector_reserve</a> (this, capacity)</td></tr>
<tr class="memdesc:ad4144cda43048fe4d887b6d8af894713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements.  <a href="namespacexxmodulebase______vector__ftl.html#ad4144cda43048fe4d887b6d8af894713">More...</a><br /></td></tr>
<tr class="separator:ad4144cda43048fe4d887b6d8af894713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a624e74d138f86d0f7ce550f8f01d2ec8">vector_realloc</a> (this)</td></tr>
<tr class="memdesc:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal array memory handling (realloc)  <a href="namespacexxmodulebase______vector__ftl.html#a624e74d138f86d0f7ce550f8f01d2ec8">More...</a><br /></td></tr>
<tr class="separator:a624e74d138f86d0f7ce550f8f01d2ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a64d60d3cf51a6b56971c81de40544661"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#a64d60d3cf51a6b56971c81de40544661">vector_base_capacity</a> = 100</td></tr>
<tr class="memdesc:a64d60d3cf51a6b56971c81de40544661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference vector size parameters.  <a href="namespacexxmodulebase______vector__ftl.html#a64d60d3cf51a6b56971c81de40544661">More...</a><br /></td></tr>
<tr class="separator:a64d60d3cf51a6b56971c81de40544661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d7526b874d8b603ef4793e8112785"><td class="memItemLeft" align="right" valign="top">real, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexxmodulebase______vector__ftl.html#ac40d7526b874d8b603ef4793e8112785">vector_base_capacity_increase</a> = 1.5</td></tr>
<tr class="separator:ac40d7526b874d8b603ef4793e8112785"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ac22de2f2d500c016c3a628067981ee12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22de2f2d500c016c3a628067981ee12">&#9670;&nbsp;</a></span>vector_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(1) empty container constructor (default constructor) Constructs an empty container, with no elements. </p>

</div>
</div>
<a id="ab2172ac4807729f5ced5ca882beb42d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2172ac4807729f5ced5ca882beb42d3">&#9670;&nbsp;</a></span>vector_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_fill </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(2) fill constructor Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to use to fill the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

</div>
</div>
<a id="ada9fa69db2dda505b0debdd4bd32928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9fa69db2dda505b0debdd4bd32928a">&#9670;&nbsp;</a></span>vector_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(3) range constructor Constructs a container with as many elements as the range (first,last), with each element constructed from its corresponding element in that range, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

</div>
</div>
<a id="a068d7489a0ef1f57f83489b7a94d2c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068d7489a0ef1f57f83489b7a94d2c06">&#9670;&nbsp;</a></span>vector_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_copy </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(4) copy constructor Constructs a container with a copy of each of the elements in other, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

</div>
</div>
<a id="a1cd31d81ff216049645688d944674268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd31d81ff216049645688d944674268">&#9670;&nbsp;</a></span>vector_copy_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_copy_from_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

</div>
</div>
<a id="a9f0c4b43fc00d13281082c4842ec6684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c4b43fc00d13281082c4842ec6684">&#9670;&nbsp;</a></span>vector_assign_from_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_assign_from_vector </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa71fadb34e35ed36540921822b7284ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71fadb34e35ed36540921822b7284ae">&#9670;&nbsp;</a></span>vector_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_ </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector destructor Destroys the container object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6970fb53364dc0c08ef61bd8f75d9e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6970fb53364dc0c08ef61bd8f75d9e1d">&#9670;&nbsp;</a></span>vector_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_begin </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to beginning Returns an iterator pointing to the first element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to beginning of the vector </dd></dl>

</div>
</div>
<a id="a5c121bbcb747aced22089b1a1a7f84a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c121bbcb747aced22089b1a1a7f84a2">&#9670;&nbsp;</a></span>vector_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_end </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to end Returns an iterator referring to the last element in the vector container. If the container is empty, the returned iterator value shall not be dereferenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to end of the vector </dd></dl>

</div>
</div>
<a id="a63172a6c006a0550d0102359cd357d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63172a6c006a0550d0102359cd357d72">&#9670;&nbsp;</a></span>vector_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___vector_ftl::vector_empty </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether container is empty Returns whether the vector container is empty (i.e. whether its size is 0). This function does not modify the container in any way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector empty status </dd></dl>

</div>
</div>
<a id="a085dbc3c35066690fa745aefb380d1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085dbc3c35066690fa745aefb380d1b7">&#9670;&nbsp;</a></span>vector_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___vector_ftl::vector_size </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size Returns the number of elements in the vector container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector size </dd></dl>

</div>
</div>
<a id="a3e5ca2cad1605f247b49b1ef0af0363b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5ca2cad1605f247b49b1ef0af0363b">&#9670;&nbsp;</a></span>vector_max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___vector_ftl::vector_max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum size Returns the maximum number of elements that the vector container can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached. </p>

</div>
</div>
<a id="af798f0b0b8e76578a9954dd5350fcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af798f0b0b8e76578a9954dd5350fcbee">&#9670;&nbsp;</a></span>vector_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___vector_ftl::vector_capacity </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of allocated storage capacity Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space). The capacity of a vector can be explicitly altered by calling member vecto::reserve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector capacity </dd></dl>

</div>
</div>
<a id="a7cf4f327e8ac97f513950ad0b7bee23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf4f327e8ac97f513950ad0b7bee23d">&#9670;&nbsp;</a></span>vector_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___vector_ftl::vector_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access first element Returns a reference to the first element in the vector container. Calling this function on an empty container causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element in the first node in the vector </dd></dl>

</div>
</div>
<a id="ad17b404447da579545604b614c3fac8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b404447da579545604b614c3fac8a">&#9670;&nbsp;</a></span>vector_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___vector_ftl::vector_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access last element Returns a reference to the last element in the vector container. Calling this function on an empty container causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element in the last node in the vector </dd></dl>

</div>
</div>
<a id="a4479e9ca761c197765e3e8be65550190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4479e9ca761c197765e3e8be65550190">&#9670;&nbsp;</a></span>vector_assign_from_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_assign_from_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (1), the new contents are elements constructed from each of the elements in the range between first and last, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8f8d4c4f9fba98033a5fe496dbcef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f8d4c4f9fba98033a5fe496dbcef70">&#9670;&nbsp;</a></span>vector_assign_from_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_assign_from_fill </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign new content to container Assigns new contents to the vector container, replacing its current contents, and modifying its size accordingly. (2), the new contents are n elements, each initialized to a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to used to populate the container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b808cfa1bbc3b2e54cd02d53281430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b808cfa1bbc3b2e54cd02d53281430">&#9670;&nbsp;</a></span>vector_assign_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_assign_from_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a vector from an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The input array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6597506c25184a35e9274c69bea4455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6597506c25184a35e9274c69bea4455c">&#9670;&nbsp;</a></span>vector_push_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_push_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element at beginning Inserts a new element at the beginning of the vector, right before its current first element. The content of val is copied (or moved) to the inserted element. This effectively increases the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856bc550e4e33c11424d5b0e3531507e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856bc550e4e33c11424d5b0e3531507e">&#9670;&nbsp;</a></span>vector_pop_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_pop_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete first element Removes the first element in the vector container, effectively reducing its size by one. This destroys the removed element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a777e3c96edd722e8ae569415dd05cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777e3c96edd722e8ae569415dd05cbda">&#9670;&nbsp;</a></span>vector_push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_push_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at the end Adds a new element at the end of the vector container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dc6fd3d3c34f6bbc9ed988e6bcf54b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc6fd3d3c34f6bbc9ed988e6bcf54b5">&#9670;&nbsp;</a></span>vector_pop_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_pop_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete last element Removes the last element in the vector container, effectively reducing the container size by one. This destroys the removed element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a2561a414ffc51a6153378705dda3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2561a414ffc51a6153378705dda3e2">&#9670;&nbsp;</a></span>vector_insert_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_insert_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by one. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a6b1778706c24f73ed7c04382d9c9f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1778706c24f73ed7c04382d9c9f848">&#9670;&nbsp;</a></span>vector_insert_single_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___vector_ftl::vector_insert_single_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by one. Iterator remains associated to the node in input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to element used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index in this of the inserted element </dd></dl>

</div>
</div>
<a id="aa438341f3726df6e9e34e42f07a71d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa438341f3726df6e9e34e42f07a71d06">&#9670;&nbsp;</a></span>vector_insert_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_insert_fill </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by n. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of times to insert the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600d1e9f17969abe336bc20f6f9541da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600d1e9f17969abe336bc20f6f9541da">&#9670;&nbsp;</a></span>vector_insert_fill_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___vector_ftl::vector_insert_fill_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to element used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of times to insert the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in this to the start of the inserted section </dd></dl>

</div>
</div>
<a id="a9f79a0d75683c1fe6cb99cdde65936aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f79a0d75683c1fe6cb99cdde65936aa">&#9670;&nbsp;</a></span>vector_insert_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_insert_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted section </dd></dl>

</div>
</div>
<a id="a81b11394297f1206126e5fb1926c244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b11394297f1206126e5fb1926c244b">&#9670;&nbsp;</a></span>vector_insert_range_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___vector_ftl::vector_insert_range_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting vector is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to element used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in this to the start of the inserted section </dd></dl>

</div>
</div>
<a id="a51a21d1c3b3cd2d83d70418f902a01fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a21d1c3b3cd2d83d70418f902a01fa">&#9670;&nbsp;</a></span>vector_insert_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_insert_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the vector size by the size of the array. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a8013588260e0a76eb434e7d901642610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8013588260e0a76eb434e7d901642610">&#9670;&nbsp;</a></span>vector_insert_array_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___vector_ftl::vector_insert_array_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position (by absolute index) This effectively increases the vector size by n. Iterator remains associated to the node in input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to element used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in this to the start of the inserted section </dd></dl>

</div>
</div>
<a id="ae10ceda421c23eb7713c04248e894dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10ceda421c23eb7713c04248e894dd6">&#9670;&nbsp;</a></span>vector_erase_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_erase_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the vector container either a single element (position) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>Iterator to node to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31dd8752f465f7cdd28fcfac73b5abab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dd8752f465f7cdd28fcfac73b5abab">&#9670;&nbsp;</a></span>vector_erase_single_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_erase_single_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the vector container either a single element (position by absolute index) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to element erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a6b8965bf3ca02635ba07733095020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a6b8965bf3ca02635ba07733095020">&#9670;&nbsp;</a></span>vector_erase_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_erase_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9c13bdd61489b6ee6f0a6f3972dc15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c13bdd61489b6ee6f0a6f3972dc15b">&#9670;&nbsp;</a></span>vector_erase_range_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_erase_range_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ifirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ilast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the vector container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifirst</td><td>Index to first node to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilast</td><td>Index to last node to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1934f13e9ec300de57a75e4ddcdd0394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1934f13e9ec300de57a75e4ddcdd0394">&#9670;&nbsp;</a></span>vector_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_swap </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content Exchanges the content of the container by the content of other, which is another vector of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in other before the call, and the elements of other are those which were in this. All iterators, references and pointers remain valid for the swapped objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The vector to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb8b4cd18bfc5c3812e372779510735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb8b4cd18bfc5c3812e372779510735">&#9670;&nbsp;</a></span>vector_resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_resize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in), optional, target&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the resulting vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to use to initialise traling elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad829da9e508913f888d2784bb44fbc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad829da9e508913f888d2784bb44fbc8e">&#9670;&nbsp;</a></span>vector_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_clear </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear content Removes all elements from the vector container (which are destroyed) and leaving the container with a size of 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace15fda8e6184f543ffbb91a278ce251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace15fda8e6184f543ffbb91a278ce251">&#9670;&nbsp;</a></span>vector_at_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer xxmodulebase___vector_ftl::vector_at_get </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The position in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object to replace </dd></dl>

</div>
</div>
<a id="a861037895ce3d24453e015e536abb63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861037895ce3d24453e015e536abb63d">&#9670;&nbsp;</a></span>vector_element_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___vector_ftl::vector_element_from_index </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value pointed by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned element </dd></dl>

</div>
</div>
<a id="a866f8de383db6264a14e13d09f0fb51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866f8de383db6264a14e13d09f0fb51b">&#9670;&nbsp;</a></span>vector_element_ptr_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer xxmodulebase___vector_ftl::vector_element_ptr_from_index </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value pointed by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned element </dd></dl>

</div>
</div>
<a id="adf42b19a13bd697dc6ddafb88709108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf42b19a13bd697dc6ddafb88709108f">&#9670;&nbsp;</a></span>vector_element_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_element_to_index </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value pointed by the index Provide destructor is the replaced element has complex memory components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb06f394ef03d14d3d15e3d7861d98e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb06f394ef03d14d3d15e3d7861d98e0">&#9670;&nbsp;</a></span>vector_splice_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_splice_vector </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (1) transfers all the elements of source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in vector to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ada4031bf2360335909542beecbac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ada4031bf2360335909542beecbac1">&#9670;&nbsp;</a></span>vector_splice_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_splice_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (2) transfers only the element pointed by iterator from x into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in vector to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>The element position in source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8158e1eb388a9d9229efe4bac1554ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8158e1eb388a9d9229efe4bac1554ec7">&#9670;&nbsp;</a></span>vector_splice_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_splice_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from vector to vector Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (3) transfers the range (first,last) from source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in vector to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first position in source to retrieve elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last position in source to retrieve elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace3d89563ebaa91146e5c340870dd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3d89563ebaa91146e5c340870dd650">&#9670;&nbsp;</a></span>vector_splice_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_splice_nodes </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ifirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ilast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from vector to vector Actual implementation of splcie at node level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in vector to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifirst</td><td>The first position in source to retrieve elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilast</td><td>The last position in source to retrieve elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a680497affafe3232ee719cf52aadd8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680497affafe3232ee719cf52aadd8de">&#9670;&nbsp;</a></span>vector_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_remove </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements with specific value Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to use as comparison for the removal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc13aace88a74cd6a5497f72b9abc8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc13aace88a74cd6a5497f72b9abc8db">&#9670;&nbsp;</a></span>vector_remove_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_remove_if </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1predicate.html">predicate</a>)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements fulfilling condition Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. The function calls pred(iget_element()) for each element (where i is an iterator to that element). Any of the elements in the vector for which this returns true, are removed from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pred</td><td>THe predicate to use for removal selection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73dc7ce6119ce9d537ca66c895b2104f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73dc7ce6119ce9d537ca66c895b2104f">&#9670;&nbsp;</a></span>vector_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_unique </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1binary__predicate.html">binary_predicate</a>), optional&#160;</td>
          <td class="paramname"><em>bpred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove duplicate values (1) removes all but the first element from every consecutive group of equal elements in the container. (2) takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(*i,*j)) for all pairs of elements (where i and j are iterators to the elements) and remove j from the vector if the predicate returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bpred</td><td>The interface for the binary predicate (optional) If the operator is not provided, then operator(==) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d94cb067c77566595e93f29c403fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d94cb067c77566595e93f29c403fb1">&#9670;&nbsp;</a></span>vector_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_merge </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge sorted vectors Merges other into the vector by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in other (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether other is an lvalue or an rvalue, or whether the value_type supports move-construction or not. (1) Each element of other is inserted at the position that corresponds to its value according to the strict weak ordering defined by operator &lt; or comp. The resulting order of equivalent elements is stable (i.e., equivalent elements preserve the relative order they had before the call, and existing elements precede those equivalent inserted from other). (2) Take a specific predicate (comp) to perform the comparison operation between elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). This function requires that the vector containers have their elements already ordered by value (or by comp) before the call. The function does nothing if (other == this). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>the vector to swap </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp</td><td>Comparison function (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a241450beb546614b735b6221f1f1ebeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241450beb546614b735b6221f1f1ebeb">&#9670;&nbsp;</a></span>vector_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_sort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort elements in container Sorts the elements in the vector, altering their position within the container. (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements (2) The sorting is performed by applying an algorithm that uses comp to compare elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). The resulting order of equivalent elements is stable: i.e., equivalent elements preserve the relative order they had before the call. The entire operation does not involve the construction, destruction or copy of any element object. Elements are moved within the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the vector to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">compare</td><td>The interface for the comparison operator (optional) If the operator is not provided, then operator(&lt;) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe170dda401536c1f1864968ad3b9500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe170dda401536c1f1864968ad3b9500">&#9670;&nbsp;</a></span>quick_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">recursive subroutine xxmodulebase___vector_ftl::quick_sort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorting subroutine (Quick-sort method) algorithm kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>Array of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Quick-sort partition left index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Quick-sort partition right index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">compare</td><td>The interface for the comparison operator (optional) If the operator is not provided, then operator(&lt;) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0baff42772597c4d4136c6fd34b0477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0baff42772597c4d4136c6fd34b0477">&#9670;&nbsp;</a></span>vector_swap_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_swap_index </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two elements in a vector from their indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector to have the elementes swapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index1</td><td>Index to first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>Index to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35a7d025524f49a0396cceeb2b6508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35a7d025524f49a0396cceeb2b6508e">&#9670;&nbsp;</a></span>vector_iterator_swap_iterators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_iterator_swap_iterators </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two nodes in a vector pointed by iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter1</td><td>Iterator to first element </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter2</td><td>Iterator to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070e6c79f4685e68be805772e463853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070e6c79f4685e68be805772e463853f">&#9670;&nbsp;</a></span>vector_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_reverse </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the order of elements in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector to reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9cdb1890480c32ffebfab225b42c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cdb1890480c32ffebfab225b42c9da">&#9670;&nbsp;</a></span>vector_binary_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_binary_search </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isless</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isgreater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search subroutine (assumes ascending sorted vector) front-end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The element to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator to the vector element (not associated if not found) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isless</td><td>If the operator is not provided, then operator(&lt;) is assumed </td></tr>
    <tr><td class="paramname">isgreater</td><td>If the operator is not provided, then operator(&gt;) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85bb1e8e054465553a9e8eec378b8867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bb1e8e054465553a9e8eec378b8867">&#9670;&nbsp;</a></span>recursive_binary_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">recursive integer function xxmodulebase___vector_ftl::recursive_binary_search </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isless</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isgreater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search subroutine (assumes ascending sorted vector) algorithm kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Quick-sort partition left position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Quick-sort partition right position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The element to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isless</td><td>If the operator is not provided, then operator(&lt;) is assumed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isgreater</td><td>If the operator is not provided, then operator(&gt;) is assumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index to the vector element (0 if not found) </dd></dl>

</div>
</div>
<a id="ab317988a49455132919e794e74d9db52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab317988a49455132919e794e74d9db52">&#9670;&nbsp;</a></span>vector_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>) function xxmodulebase___vector_ftl::vector_select </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacexxmodulebase______vector__ftl_1_1binary__predicate.html">binary_predicate</a>), optional&#160;</td>
          <td class="paramname"><em>bpred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a vector following certain criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector to search selecting items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>The reference element to use as selecting pattern </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bpred</td><td>The interface for the comparison operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output vector contatining the selectec elements </dd></dl>

</div>
</div>
<a id="a0f0896d34861ba9a92bb51c0297fce80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0896d34861ba9a92bb51c0297fce80">&#9670;&nbsp;</a></span>vector_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, dimension(:), allocatable xxmodulebase___vector_ftl::vector_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an array (allocatabe) of elements from a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned array of elements (unallocated if memory failure) </dd></dl>

</div>
</div>
<a id="a0de605d88b5eef34e4b8bd1d5a2a7412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de605d88b5eef34e4b8bd1d5a2a7412">&#9670;&nbsp;</a></span>element_assign_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::element_assign_pointer </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(inout), pointer&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (pointer interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17c93635598ac0e999a01d27262e06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17c93635598ac0e999a01d27262e06c">&#9670;&nbsp;</a></span>element_assign_allocatable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::element_assign_allocatable </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (allocatable interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d4f8d9d84ffece2fa9712677026639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d4f8d9d84ffece2fa9712677026639">&#9670;&nbsp;</a></span>vector_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_iterator_next </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to next node in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the vector iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to next node in the vector </dd></dl>

</div>
</div>
<a id="abfd95590e04683a45d40b4cb3ede460e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd95590e04683a45d40b4cb3ede460e">&#9670;&nbsp;</a></span>vector_iterator_previous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>) function xxmodulebase___vector_ftl::vector_iterator_previous </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to previous node in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the vector iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous node in the vector </dd></dl>

</div>
</div>
<a id="a399094ea57e1e6f5a1abf769c38d9fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399094ea57e1e6f5a1abf769c38d9fe1">&#9670;&nbsp;</a></span>vector_iterator_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function xxmodulebase___vector_ftl::vector_iterator_index </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vector index in an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>The vector iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector index </dd></dl>

</div>
</div>
<a id="a81b51358c45ce7ff11e4b45e86e725e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b51358c45ce7ff11e4b45e86e725e4">&#9670;&nbsp;</a></span>vector_iterator_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer function xxmodulebase___vector_ftl::vector_iterator_distance </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance (number of elements) between two nodes (by iterator) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The final node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements between the iterators </dd></dl>

</div>
</div>
<a id="ae28584e56306958a555ea5dc78d7c325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28584e56306958a555ea5dc78d7c325">&#9670;&nbsp;</a></span>vector_iterator_associated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___vector_ftl::vector_iterator_associated </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the association status of an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The vector iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The association status </dd></dl>

</div>
</div>
<a id="aa13385e157e24114a9d8d38a289766c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13385e157e24114a9d8d38a289766c6">&#9670;&nbsp;</a></span>vector_iterator_nullify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_iterator_nullify </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8078ba63473bd35d4855cdb00a698065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8078ba63473bd35d4855cdb00a698065">&#9670;&nbsp;</a></span>vector_iterator_get_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, allocatable xxmodulebase___vector_ftl::vector_iterator_get_element </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an elememnt in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned pointer to element </dd></dl>

</div>
</div>
<a id="adeb01963ba439e4a3186dd2fde150317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb01963ba439e4a3186dd2fde150317">&#9670;&nbsp;</a></span>vector_iterator_get_element_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>) function, pointer xxmodulebase___vector_ftl::vector_iterator_get_element_ptr </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data elememnt in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned element </dd></dl>

</div>
</div>
<a id="a2cba7a597671043c0d460f1885f21ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cba7a597671043c0d460f1885f21ffb">&#9670;&nbsp;</a></span>vector_iterator_set_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_iterator_set_element </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxuse_____1_1xxtypebase____.html">xxtypebase__</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99cf28d9f6d17ab4e0512782cdc0a03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cf28d9f6d17ab4e0512782cdc0a03b">&#9670;&nbsp;</a></span>vector_iterator_assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xxmodulebase___vector_ftl::vector_iterator_assign </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(out)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an interator from an existing iterator (assignment operator) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">left</td><td>The output iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The input iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00942d16c7f4fdedf80c33bbb1f73fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00942d16c7f4fdedf80c33bbb1f73fed">&#9670;&nbsp;</a></span>vector_iterator_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___vector_ftl::vector_iterator_equal </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterators (equality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The first iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result </dd></dl>

</div>
</div>
<a id="af0eccd0a8a293145fa7294a672dee9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0eccd0a8a293145fa7294a672dee9e2">&#9670;&nbsp;</a></span>vector_iterator_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function xxmodulebase___vector_ftl::vector_iterator_not_equal </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl__iterator.html">xxtypebase___vector_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterator (inequality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The first iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result </dd></dl>

</div>
</div>
<a id="ad4144cda43048fe4d887b6d8af894713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4144cda43048fe4d887b6d8af894713">&#9670;&nbsp;</a></span>vector_reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_reserve </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The user reqested capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a624e74d138f86d0f7ce550f8f01d2ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624e74d138f86d0f7ce550f8f01d2ec8">&#9670;&nbsp;</a></span>vector_realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine xxmodulebase___vector_ftl::vector_realloc </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structxxmodulebase______vector__ftl_1_1xxtypebase______vector__ftl.html">xxtypebase___vector_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal array memory handling (realloc) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a64d60d3cf51a6b56971c81de40544661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d60d3cf51a6b56971c81de40544661">&#9670;&nbsp;</a></span>vector_base_capacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer, parameter xxmodulebase___vector_ftl::vector_base_capacity = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference vector size parameters. </p>

</div>
</div>
<a id="ac40d7526b874d8b603ef4793e8112785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40d7526b874d8b603ef4793e8112785">&#9670;&nbsp;</a></span>vector_base_capacity_increase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real, parameter xxmodulebase___vector_ftl::vector_base_capacity_increase = 1.5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
